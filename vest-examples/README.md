# Vest Examples

This directory contains examples demonstrating how to use the Vest DSL and combinators from `vest_lib` directly to define and work with binary formats.

## Overview

Each subdirectory is a separate Cargo package that showcases different aspects of Vest:

### Using Vest DSL

- **`triple_dsl`**: Toy example showing how to define a simple binary format with three fields using Vest DSL.
- **`bitcoin_dsl`**: Bitcoin block and transaction format defined using Vest DSL.
- **`mavlink_dsl`**: (Partial) MAVLink protocol message formats defined using Vest DSL.
- **`tls_dsl`**: TLS 1.3 handshake message formats defined using Vest DSL.

### Using Vest Combinators Directly

- **`choice`** & **`enums`**: Example showing how to use the `Choice` combinator to deal with variant formats like tagged unions.
- **`map`** & **`refserializer`**: Examples showing how to use the `Mapped` combinator to convert between structural (tuples and sums) and nominal representations (structs and enums).
- **`opt`**: Example showing how to handle optional fields using the `Opt` and `OptThen` combinators.
- **`pair`** & **`depend`**: Example showing how to use the `Pair` combinator for sequentially composing combinators, including _dependent_ formats where later fields depend on earlier ones.
- **`repeat`**: Example showing how to handle repeated fields using the `Repeat` combinator.
- **`wireguard`**: WireGuard protocol message formats implemented directly using Vest combinators.
- **`asn1`**: ASN.1 primitives in Vest.

## Verifying Examples

First, make sure you have the Vest DSL [vest](https://crates.io/crates/vest) in your path (you can install it via `cargo install vest`).

To verify the examples with Verus:

```sh
cd vest-examples
cargo verus verify -p <example-name>
```

## Using the Vest DSL with `build.rs`

Many examples (like `bitcoin_dsl`, `tls_dsl`, and `mavlink_dsl`) use Vest DSL files (`.vest`) to define binary formats. The `build.rs` script automatically generates Rust code from these definitions at compile time.

### Setup

To use Vest DSL in your project, follow these steps:

1. **Create a `build.rs` script** in your crate root (same level as `Cargo.toml`):

```rust
use std::env;
use std::fs;
use std::path::PathBuf;
use std::process::Command;

fn main() {
    // Tell Cargo to rerun this build script if your .vest file changes
    println!("cargo:rerun-if-changed=src/myformat.vest");

    // Get the output directory where generated files should be placed
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR environment variable not set");
    let out_path = PathBuf::from(&out_dir).join("myformat.rs");

    // Run the vest executable on your .vest file
    let status = Command::new("vest")
        .arg("src/myformat.vest")
        .arg("--output")
        .arg(&out_path)
        .status()
        .expect("Failed to execute vest command");

    if !status.success() {
        panic!("vest command failed with status: {}", status);
    }
}
```

2. **Create your `.vest` file** (e.g., `src/myformat.vest`) with format definitions.

3. **Include the generated module in your code**:

In your `src/lib.rs` or `src/main.rs`, include the generated module:

```rust
pub mod my_format {
    // This module includes the code generated by build.rs from src/myformat.vest
    // The generated file is placed in OUT_DIR/myformat.rs
    include!(concat!(env!("OUT_DIR"), "/myformat.rs"));
}
```

### How It Works

When you run `cargo build`, Cargo first executes your `build.rs` script, which invokes the `vest` CLI on your `.vest` file to generate Verus/Rust code. That code is written into the build output directory (`OUT_DIR`), and your source uses `include!` to pull it into the crate during compilation. The `cargo:rerun-if-changed` line ensures the build script runs again whenever the `.vest` file is modified.
