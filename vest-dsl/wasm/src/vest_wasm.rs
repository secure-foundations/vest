
#![allow(warnings)]
#![allow(unused)]
use vstd::prelude::*;
use vest_lib::regular::modifier::*;
use vest_lib::regular::bytes;
use vest_lib::regular::variant::*;
use vest_lib::regular::sequence::*;
use vest_lib::regular::repetition::*;
use vest_lib::regular::disjoint::DisjointFrom;
use vest_lib::regular::tag::*;
use vest_lib::regular::uints::*;
use vest_lib::utils::*;
use vest_lib::properties::*;
use vest_lib::bitcoin::varint::{BtcVarint, VarInt};
use vest_lib::regular::leb128::*;

macro_rules! impl_wrapper_combinator {
    ($combinator:ty, $combinator_alias:ty) => {
        ::vstd::prelude::verus! {
            impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for $combinator {
                type Type = <$combinator_alias as Combinator<'a, &'a [u8], Vec<u8>>>::Type;
                type SType = <$combinator_alias as Combinator<'a, &'a [u8], Vec<u8>>>::SType;
                fn length(&self, v: Self::SType) -> usize
                { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
                closed spec fn ex_requires(&self) -> bool
                { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
                fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>)
                { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&self.0, s) }
                fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
                { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
            }
        } // verus!
    };
}
verus!{
pub type SpecFuncidx = u64;
pub type Funcidx = u64;
pub type FuncidxRef<'a> = &'a u64;


pub struct SpecFuncidxCombinator(pub SpecFuncidxCombinatorAlias);

impl SpecCombinator for SpecFuncidxCombinator {
    type Type = SpecFuncidx;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecFuncidxCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecFuncidxCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecFuncidxCombinatorAlias = UnsignedLEB128;

pub struct FuncidxCombinator(pub FuncidxCombinatorAlias);

impl View for FuncidxCombinator {
    type V = SpecFuncidxCombinator;
    open spec fn view(&self) -> Self::V { SpecFuncidxCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for FuncidxCombinator {
    type Type = Funcidx;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type FuncidxCombinatorAlias = UnsignedLEB128;


pub open spec fn spec_funcidx() -> SpecFuncidxCombinator {
    SpecFuncidxCombinator(UnsignedLEB128)
}

                
pub fn funcidx<'a>() -> (o: FuncidxCombinator)
    ensures o@ == spec_funcidx(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = FuncidxCombinator(UnsignedLEB128);
    assert({
        &&& combinator@ == spec_funcidx()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_funcidx<'a>(input: &'a [u8]) -> (res: PResult<<FuncidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_funcidx().spec_parse(input@) == Some((n as int, v@)),
        spec_funcidx().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_funcidx().spec_parse(input@) is None,
        spec_funcidx().spec_parse(input@) is None ==> res is Err,
{
    let combinator = funcidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_funcidx<'a>(v: <FuncidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_funcidx().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_funcidx().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_funcidx().spec_serialize(v@))
        },
{
    let combinator = funcidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn funcidx_len<'a>(v: <FuncidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_funcidx().wf(v@),
        spec_funcidx().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_funcidx().spec_serialize(v@).len(),
{
    let combinator = funcidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub spec const SPEC_Vectype_V128: u8 = 123;
pub exec static EXEC_Vectype_V128: u8 ensures EXEC_Vectype_V128 == SPEC_Vectype_V128 { 123 }

#[derive(Structural, Debug, Copy, Clone, PartialEq, Eq)]
pub enum Vectype {
    V128 = 123
}
pub type SpecVectype = Vectype;

pub type VectypeInner = u8;

pub type VectypeInnerRef<'a> = &'a u8;

impl View for Vectype {
    type V = Self;

    open spec fn view(&self) -> Self::V {
        *self
    }
}

impl SpecTryFrom<VectypeInner> for Vectype {
    type Error = ();

    open spec fn spec_try_from(v: VectypeInner) -> Result<Vectype, ()> {
        match v {
            123u8 => Ok(Vectype::V128),
            _ => Err(()),
        }
    }
}

impl SpecTryFrom<Vectype> for VectypeInner {
    type Error = ();

    open spec fn spec_try_from(v: Vectype) -> Result<VectypeInner, ()> {
        match v {
            Vectype::V128 => Ok(SPEC_Vectype_V128),
        }
    }
}

impl TryFrom<VectypeInner> for Vectype {
    type Error = ();

    fn ex_try_from(v: VectypeInner) -> Result<Vectype, ()> {
        match v {
            123u8 => Ok(Vectype::V128),
            _ => Err(()),
        }
    }
}

impl<'a> TryFrom<&'a Vectype> for VectypeInnerRef<'a> {
    type Error = ();

    fn ex_try_from(v: &'a Vectype) -> Result<VectypeInnerRef<'a>, ()> {
        match v {
            Vectype::V128 => Ok(&EXEC_Vectype_V128),
        }
    }
}

pub struct VectypeMapper;

impl View for VectypeMapper {
    type V = Self;

    open spec fn view(&self) -> Self::V {
        *self
    }
}

impl SpecPartialIso for VectypeMapper {
    type Src = VectypeInner;
    type Dst = Vectype;
}

impl SpecPartialIsoProof for VectypeMapper {
    proof fn spec_iso(s: Self::Src) { 
        assert(
            Self::spec_apply(s) matches Ok(v) ==> {
            &&& Self::spec_rev_apply(v) is Ok
            &&& Self::spec_rev_apply(v) matches Ok(s_) && s == s_
        });
    }

    proof fn spec_iso_rev(s: Self::Dst) { 
        assert(
            Self::spec_rev_apply(s) matches Ok(v) ==> {
            &&& Self::spec_apply(v) is Ok
            &&& Self::spec_apply(v) matches Ok(s_) && s == s_
        });
    }
}

impl<'a> PartialIso<'a> for VectypeMapper {
    type Src = VectypeInner;
    type Dst = Vectype;
    type RefSrc = VectypeInnerRef<'a>;
}


pub struct SpecVectypeCombinator(pub SpecVectypeCombinatorAlias);

impl SpecCombinator for SpecVectypeCombinator {
    type Type = SpecVectype;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecVectypeCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecVectypeCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecVectypeCombinatorAlias = TryMap<U8, VectypeMapper>;

pub struct VectypeCombinator(pub VectypeCombinatorAlias);

impl View for VectypeCombinator {
    type V = SpecVectypeCombinator;
    open spec fn view(&self) -> Self::V { SpecVectypeCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for VectypeCombinator {
    type Type = Vectype;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type VectypeCombinatorAlias = TryMap<U8, VectypeMapper>;


pub open spec fn spec_vectype() -> SpecVectypeCombinator {
    SpecVectypeCombinator(TryMap { inner: U8, mapper: VectypeMapper })
}

                
pub fn vectype<'a>() -> (o: VectypeCombinator)
    ensures o@ == spec_vectype(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = VectypeCombinator(TryMap { inner: U8, mapper: VectypeMapper });
    assert({
        &&& combinator@ == spec_vectype()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_vectype<'a>(input: &'a [u8]) -> (res: PResult<<VectypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_vectype().spec_parse(input@) == Some((n as int, v@)),
        spec_vectype().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_vectype().spec_parse(input@) is None,
        spec_vectype().spec_parse(input@) is None ==> res is Err,
{
    let combinator = vectype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_vectype<'a>(v: <VectypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_vectype().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_vectype().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_vectype().spec_serialize(v@))
        },
{
    let combinator = vectype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn vectype_len<'a>(v: <VectypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_vectype().wf(v@),
        spec_vectype().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_vectype().spec_serialize(v@).len(),
{
    let combinator = vectype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecElemidx = u64;
pub type Elemidx = u64;
pub type ElemidxRef<'a> = &'a u64;


pub struct SpecElemidxCombinator(pub SpecElemidxCombinatorAlias);

impl SpecCombinator for SpecElemidxCombinator {
    type Type = SpecElemidx;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecElemidxCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecElemidxCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecElemidxCombinatorAlias = UnsignedLEB128;

pub struct ElemidxCombinator(pub ElemidxCombinatorAlias);

impl View for ElemidxCombinator {
    type V = SpecElemidxCombinator;
    open spec fn view(&self) -> Self::V { SpecElemidxCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ElemidxCombinator {
    type Type = Elemidx;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ElemidxCombinatorAlias = UnsignedLEB128;


pub open spec fn spec_elemidx() -> SpecElemidxCombinator {
    SpecElemidxCombinator(UnsignedLEB128)
}

                
pub fn elemidx<'a>() -> (o: ElemidxCombinator)
    ensures o@ == spec_elemidx(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ElemidxCombinator(UnsignedLEB128);
    assert({
        &&& combinator@ == spec_elemidx()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_elemidx<'a>(input: &'a [u8]) -> (res: PResult<<ElemidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_elemidx().spec_parse(input@) == Some((n as int, v@)),
        spec_elemidx().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_elemidx().spec_parse(input@) is None,
        spec_elemidx().spec_parse(input@) is None ==> res is Err,
{
    let combinator = elemidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_elemidx<'a>(v: <ElemidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_elemidx().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_elemidx().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_elemidx().spec_serialize(v@))
        },
{
    let combinator = elemidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn elemidx_len<'a>(v: <ElemidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_elemidx().wf(v@),
        spec_elemidx().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_elemidx().spec_serialize(v@).len(),
{
    let combinator = elemidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub spec const SPEC_Numtype_I32: u8 = 127;
pub spec const SPEC_Numtype_I64: u8 = 126;
pub spec const SPEC_Numtype_F32: u8 = 125;
pub spec const SPEC_Numtype_F64: u8 = 124;
pub exec static EXEC_Numtype_I32: u8 ensures EXEC_Numtype_I32 == SPEC_Numtype_I32 { 127 }
pub exec static EXEC_Numtype_I64: u8 ensures EXEC_Numtype_I64 == SPEC_Numtype_I64 { 126 }
pub exec static EXEC_Numtype_F32: u8 ensures EXEC_Numtype_F32 == SPEC_Numtype_F32 { 125 }
pub exec static EXEC_Numtype_F64: u8 ensures EXEC_Numtype_F64 == SPEC_Numtype_F64 { 124 }

#[derive(Structural, Debug, Copy, Clone, PartialEq, Eq)]
pub enum Numtype {
    I32 = 127,
I64 = 126,
F32 = 125,
F64 = 124
}
pub type SpecNumtype = Numtype;

pub type NumtypeInner = u8;

pub type NumtypeInnerRef<'a> = &'a u8;

impl View for Numtype {
    type V = Self;

    open spec fn view(&self) -> Self::V {
        *self
    }
}

impl SpecTryFrom<NumtypeInner> for Numtype {
    type Error = ();

    open spec fn spec_try_from(v: NumtypeInner) -> Result<Numtype, ()> {
        match v {
            127u8 => Ok(Numtype::I32),
            126u8 => Ok(Numtype::I64),
            125u8 => Ok(Numtype::F32),
            124u8 => Ok(Numtype::F64),
            _ => Err(()),
        }
    }
}

impl SpecTryFrom<Numtype> for NumtypeInner {
    type Error = ();

    open spec fn spec_try_from(v: Numtype) -> Result<NumtypeInner, ()> {
        match v {
            Numtype::I32 => Ok(SPEC_Numtype_I32),
            Numtype::I64 => Ok(SPEC_Numtype_I64),
            Numtype::F32 => Ok(SPEC_Numtype_F32),
            Numtype::F64 => Ok(SPEC_Numtype_F64),
        }
    }
}

impl TryFrom<NumtypeInner> for Numtype {
    type Error = ();

    fn ex_try_from(v: NumtypeInner) -> Result<Numtype, ()> {
        match v {
            127u8 => Ok(Numtype::I32),
            126u8 => Ok(Numtype::I64),
            125u8 => Ok(Numtype::F32),
            124u8 => Ok(Numtype::F64),
            _ => Err(()),
        }
    }
}

impl<'a> TryFrom<&'a Numtype> for NumtypeInnerRef<'a> {
    type Error = ();

    fn ex_try_from(v: &'a Numtype) -> Result<NumtypeInnerRef<'a>, ()> {
        match v {
            Numtype::I32 => Ok(&EXEC_Numtype_I32),
            Numtype::I64 => Ok(&EXEC_Numtype_I64),
            Numtype::F32 => Ok(&EXEC_Numtype_F32),
            Numtype::F64 => Ok(&EXEC_Numtype_F64),
        }
    }
}

pub struct NumtypeMapper;

impl View for NumtypeMapper {
    type V = Self;

    open spec fn view(&self) -> Self::V {
        *self
    }
}

impl SpecPartialIso for NumtypeMapper {
    type Src = NumtypeInner;
    type Dst = Numtype;
}

impl SpecPartialIsoProof for NumtypeMapper {
    proof fn spec_iso(s: Self::Src) { 
        assert(
            Self::spec_apply(s) matches Ok(v) ==> {
            &&& Self::spec_rev_apply(v) is Ok
            &&& Self::spec_rev_apply(v) matches Ok(s_) && s == s_
        });
    }

    proof fn spec_iso_rev(s: Self::Dst) { 
        assert(
            Self::spec_rev_apply(s) matches Ok(v) ==> {
            &&& Self::spec_apply(v) is Ok
            &&& Self::spec_apply(v) matches Ok(s_) && s == s_
        });
    }
}

impl<'a> PartialIso<'a> for NumtypeMapper {
    type Src = NumtypeInner;
    type Dst = Numtype;
    type RefSrc = NumtypeInnerRef<'a>;
}


pub struct SpecNumtypeCombinator(pub SpecNumtypeCombinatorAlias);

impl SpecCombinator for SpecNumtypeCombinator {
    type Type = SpecNumtype;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecNumtypeCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecNumtypeCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecNumtypeCombinatorAlias = TryMap<U8, NumtypeMapper>;

pub struct NumtypeCombinator(pub NumtypeCombinatorAlias);

impl View for NumtypeCombinator {
    type V = SpecNumtypeCombinator;
    open spec fn view(&self) -> Self::V { SpecNumtypeCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for NumtypeCombinator {
    type Type = Numtype;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type NumtypeCombinatorAlias = TryMap<U8, NumtypeMapper>;


pub open spec fn spec_numtype() -> SpecNumtypeCombinator {
    SpecNumtypeCombinator(TryMap { inner: U8, mapper: NumtypeMapper })
}

                
pub fn numtype<'a>() -> (o: NumtypeCombinator)
    ensures o@ == spec_numtype(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = NumtypeCombinator(TryMap { inner: U8, mapper: NumtypeMapper });
    assert({
        &&& combinator@ == spec_numtype()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_numtype<'a>(input: &'a [u8]) -> (res: PResult<<NumtypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_numtype().spec_parse(input@) == Some((n as int, v@)),
        spec_numtype().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_numtype().spec_parse(input@) is None,
        spec_numtype().spec_parse(input@) is None ==> res is Err,
{
    let combinator = numtype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_numtype<'a>(v: <NumtypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_numtype().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_numtype().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_numtype().spec_serialize(v@))
        },
{
    let combinator = numtype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn numtype_len<'a>(v: <NumtypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_numtype().wf(v@),
        spec_numtype().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_numtype().spec_serialize(v@).len(),
{
    let combinator = numtype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub spec const SPEC_Reftype_FuncRef: u8 = 112;
pub spec const SPEC_Reftype_ExternRef: u8 = 111;
pub exec static EXEC_Reftype_FuncRef: u8 ensures EXEC_Reftype_FuncRef == SPEC_Reftype_FuncRef { 112 }
pub exec static EXEC_Reftype_ExternRef: u8 ensures EXEC_Reftype_ExternRef == SPEC_Reftype_ExternRef { 111 }

#[derive(Structural, Debug, Copy, Clone, PartialEq, Eq)]
pub enum Reftype {
    FuncRef = 112,
ExternRef = 111
}
pub type SpecReftype = Reftype;

pub type ReftypeInner = u8;

pub type ReftypeInnerRef<'a> = &'a u8;

impl View for Reftype {
    type V = Self;

    open spec fn view(&self) -> Self::V {
        *self
    }
}

impl SpecTryFrom<ReftypeInner> for Reftype {
    type Error = ();

    open spec fn spec_try_from(v: ReftypeInner) -> Result<Reftype, ()> {
        match v {
            112u8 => Ok(Reftype::FuncRef),
            111u8 => Ok(Reftype::ExternRef),
            _ => Err(()),
        }
    }
}

impl SpecTryFrom<Reftype> for ReftypeInner {
    type Error = ();

    open spec fn spec_try_from(v: Reftype) -> Result<ReftypeInner, ()> {
        match v {
            Reftype::FuncRef => Ok(SPEC_Reftype_FuncRef),
            Reftype::ExternRef => Ok(SPEC_Reftype_ExternRef),
        }
    }
}

impl TryFrom<ReftypeInner> for Reftype {
    type Error = ();

    fn ex_try_from(v: ReftypeInner) -> Result<Reftype, ()> {
        match v {
            112u8 => Ok(Reftype::FuncRef),
            111u8 => Ok(Reftype::ExternRef),
            _ => Err(()),
        }
    }
}

impl<'a> TryFrom<&'a Reftype> for ReftypeInnerRef<'a> {
    type Error = ();

    fn ex_try_from(v: &'a Reftype) -> Result<ReftypeInnerRef<'a>, ()> {
        match v {
            Reftype::FuncRef => Ok(&EXEC_Reftype_FuncRef),
            Reftype::ExternRef => Ok(&EXEC_Reftype_ExternRef),
        }
    }
}

pub struct ReftypeMapper;

impl View for ReftypeMapper {
    type V = Self;

    open spec fn view(&self) -> Self::V {
        *self
    }
}

impl SpecPartialIso for ReftypeMapper {
    type Src = ReftypeInner;
    type Dst = Reftype;
}

impl SpecPartialIsoProof for ReftypeMapper {
    proof fn spec_iso(s: Self::Src) { 
        assert(
            Self::spec_apply(s) matches Ok(v) ==> {
            &&& Self::spec_rev_apply(v) is Ok
            &&& Self::spec_rev_apply(v) matches Ok(s_) && s == s_
        });
    }

    proof fn spec_iso_rev(s: Self::Dst) { 
        assert(
            Self::spec_rev_apply(s) matches Ok(v) ==> {
            &&& Self::spec_apply(v) is Ok
            &&& Self::spec_apply(v) matches Ok(s_) && s == s_
        });
    }
}

impl<'a> PartialIso<'a> for ReftypeMapper {
    type Src = ReftypeInner;
    type Dst = Reftype;
    type RefSrc = ReftypeInnerRef<'a>;
}


pub struct SpecReftypeCombinator(pub SpecReftypeCombinatorAlias);

impl SpecCombinator for SpecReftypeCombinator {
    type Type = SpecReftype;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecReftypeCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecReftypeCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecReftypeCombinatorAlias = TryMap<U8, ReftypeMapper>;

pub struct ReftypeCombinator(pub ReftypeCombinatorAlias);

impl View for ReftypeCombinator {
    type V = SpecReftypeCombinator;
    open spec fn view(&self) -> Self::V { SpecReftypeCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ReftypeCombinator {
    type Type = Reftype;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ReftypeCombinatorAlias = TryMap<U8, ReftypeMapper>;


pub open spec fn spec_reftype() -> SpecReftypeCombinator {
    SpecReftypeCombinator(TryMap { inner: U8, mapper: ReftypeMapper })
}

                
pub fn reftype<'a>() -> (o: ReftypeCombinator)
    ensures o@ == spec_reftype(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ReftypeCombinator(TryMap { inner: U8, mapper: ReftypeMapper });
    assert({
        &&& combinator@ == spec_reftype()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_reftype<'a>(input: &'a [u8]) -> (res: PResult<<ReftypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_reftype().spec_parse(input@) == Some((n as int, v@)),
        spec_reftype().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_reftype().spec_parse(input@) is None,
        spec_reftype().spec_parse(input@) is None ==> res is Err,
{
    let combinator = reftype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_reftype<'a>(v: <ReftypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_reftype().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_reftype().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_reftype().spec_serialize(v@))
        },
{
    let combinator = reftype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn reftype_len<'a>(v: <ReftypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_reftype().wf(v@),
        spec_reftype().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_reftype().spec_serialize(v@).len(),
{
    let combinator = reftype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub enum SpecValtype {
    NumTy(SpecNumtype),
    VecTy(SpecVectype),
    RefTy(SpecReftype),
}

pub type SpecValtypeInner = Either<SpecNumtype, Either<SpecVectype, SpecReftype>>;

impl SpecFrom<SpecValtype> for SpecValtypeInner {
    open spec fn spec_from(m: SpecValtype) -> SpecValtypeInner {
        match m {
            SpecValtype::NumTy(m) => Either::Left(m),
            SpecValtype::VecTy(m) => Either::Right(Either::Left(m)),
            SpecValtype::RefTy(m) => Either::Right(Either::Right(m)),
        }
    }

}

                
impl SpecFrom<SpecValtypeInner> for SpecValtype {
    open spec fn spec_from(m: SpecValtypeInner) -> SpecValtype {
        match m {
            Either::Left(m) => SpecValtype::NumTy(m),
            Either::Right(Either::Left(m)) => SpecValtype::VecTy(m),
            Either::Right(Either::Right(m)) => SpecValtype::RefTy(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Valtype {
    NumTy(Numtype),
    VecTy(Vectype),
    RefTy(Reftype),
}

pub type ValtypeInner = Either<Numtype, Either<Vectype, Reftype>>;

pub type ValtypeInnerRef<'a> = Either<&'a Numtype, Either<&'a Vectype, &'a Reftype>>;


impl View for Valtype {
    type V = SpecValtype;
    open spec fn view(&self) -> Self::V {
        match self {
            Valtype::NumTy(m) => SpecValtype::NumTy(m@),
            Valtype::VecTy(m) => SpecValtype::VecTy(m@),
            Valtype::RefTy(m) => SpecValtype::RefTy(m@),
        }
    }
}


impl<'a> From<&'a Valtype> for ValtypeInnerRef<'a> {
    fn ex_from(m: &'a Valtype) -> ValtypeInnerRef<'a> {
        match m {
            Valtype::NumTy(m) => Either::Left(m),
            Valtype::VecTy(m) => Either::Right(Either::Left(m)),
            Valtype::RefTy(m) => Either::Right(Either::Right(m)),
        }
    }

}

impl From<ValtypeInner> for Valtype {
    fn ex_from(m: ValtypeInner) -> Valtype {
        match m {
            Either::Left(m) => Valtype::NumTy(m),
            Either::Right(Either::Left(m)) => Valtype::VecTy(m),
            Either::Right(Either::Right(m)) => Valtype::RefTy(m),
        }
    }
    
}


pub struct ValtypeMapper;
impl View for ValtypeMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ValtypeMapper {
    type Src = SpecValtypeInner;
    type Dst = SpecValtype;
}
impl SpecIsoProof for ValtypeMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ValtypeMapper {
    type Src = ValtypeInner;
    type Dst = Valtype;
    type RefSrc = ValtypeInnerRef<'a>;
}

type SpecValtypeCombinatorAlias1 = Choice<SpecVectypeCombinator, SpecReftypeCombinator>;
type SpecValtypeCombinatorAlias2 = Choice<SpecNumtypeCombinator, SpecValtypeCombinatorAlias1>;
impl DisjointFrom<SpecNumtypeCombinator> for SpecVectypeCombinator {
    closed spec fn disjoint_from(&self, other: &SpecNumtypeCombinator) -> bool
    { self.0.disjoint_from(&other.0) }
    proof fn parse_disjoint_on(&self, other: &SpecNumtypeCombinator, buf: Seq<u8>) 
    { self.0.parse_disjoint_on(&other.0, buf); }
}

impl DisjointFrom<SpecNumtypeCombinator> for SpecReftypeCombinator {
    closed spec fn disjoint_from(&self, other: &SpecNumtypeCombinator) -> bool
    { self.0.disjoint_from(&other.0) }
    proof fn parse_disjoint_on(&self, other: &SpecNumtypeCombinator, buf: Seq<u8>) 
    { self.0.parse_disjoint_on(&other.0, buf); }
}

impl DisjointFrom<SpecVectypeCombinator> for SpecReftypeCombinator {
    closed spec fn disjoint_from(&self, other: &SpecVectypeCombinator) -> bool
    { self.0.disjoint_from(&other.0) }
    proof fn parse_disjoint_on(&self, other: &SpecVectypeCombinator, buf: Seq<u8>) 
    { self.0.parse_disjoint_on(&other.0, buf); }
}
pub struct SpecValtypeCombinator(pub SpecValtypeCombinatorAlias);

impl SpecCombinator for SpecValtypeCombinator {
    type Type = SpecValtype;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecValtypeCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecValtypeCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecValtypeCombinatorAlias = Mapped<SpecValtypeCombinatorAlias2, ValtypeMapper>;
type ValtypeCombinatorAlias1 = Choice<VectypeCombinator, ReftypeCombinator>;
type ValtypeCombinatorAlias2 = Choice<NumtypeCombinator, ValtypeCombinator1>;
pub struct ValtypeCombinator1(pub ValtypeCombinatorAlias1);
impl View for ValtypeCombinator1 {
    type V = SpecValtypeCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ValtypeCombinator1, ValtypeCombinatorAlias1);

pub struct ValtypeCombinator2(pub ValtypeCombinatorAlias2);
impl View for ValtypeCombinator2 {
    type V = SpecValtypeCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ValtypeCombinator2, ValtypeCombinatorAlias2);

pub struct ValtypeCombinator(pub ValtypeCombinatorAlias);

impl View for ValtypeCombinator {
    type V = SpecValtypeCombinator;
    open spec fn view(&self) -> Self::V { SpecValtypeCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ValtypeCombinator {
    type Type = Valtype;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ValtypeCombinatorAlias = Mapped<ValtypeCombinator2, ValtypeMapper>;


pub open spec fn spec_valtype() -> SpecValtypeCombinator {
    SpecValtypeCombinator(Mapped { inner: Choice(spec_numtype(), Choice(spec_vectype(), spec_reftype())), mapper: ValtypeMapper })
}

                
pub fn valtype<'a>() -> (o: ValtypeCombinator)
    ensures o@ == spec_valtype(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ValtypeCombinator(Mapped { inner: ValtypeCombinator2(Choice::new(numtype(), ValtypeCombinator1(Choice::new(vectype(), reftype())))), mapper: ValtypeMapper });
    assert({
        &&& combinator@ == spec_valtype()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_valtype<'a>(input: &'a [u8]) -> (res: PResult<<ValtypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_valtype().spec_parse(input@) == Some((n as int, v@)),
        spec_valtype().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_valtype().spec_parse(input@) is None,
        spec_valtype().spec_parse(input@) is None ==> res is Err,
{
    let combinator = valtype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_valtype<'a>(v: <ValtypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_valtype().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_valtype().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_valtype().spec_serialize(v@))
        },
{
    let combinator = valtype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn valtype_len<'a>(v: <ValtypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_valtype().wf(v@),
        spec_valtype().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_valtype().spec_serialize(v@).len(),
{
    let combinator = valtype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecResulttype {
    pub l: u64,
    pub v: Seq<SpecValtype>,
}

pub type SpecResulttypeInner = (u64, Seq<SpecValtype>);


impl SpecFrom<SpecResulttype> for SpecResulttypeInner {
    open spec fn spec_from(m: SpecResulttype) -> SpecResulttypeInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecResulttypeInner> for SpecResulttype {
    open spec fn spec_from(m: SpecResulttypeInner) -> SpecResulttype {
        let (l, v) = m;
        SpecResulttype { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Resulttype {
    pub l: u64,
    pub v: RepeatResult<Valtype>,
}

impl View for Resulttype {
    type V = SpecResulttype;

    open spec fn view(&self) -> Self::V {
        SpecResulttype {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type ResulttypeInner = (u64, RepeatResult<Valtype>);

pub type ResulttypeInnerRef<'a> = (&'a u64, &'a RepeatResult<Valtype>);
impl<'a> From<&'a Resulttype> for ResulttypeInnerRef<'a> {
    fn ex_from(m: &'a Resulttype) -> ResulttypeInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl From<ResulttypeInner> for Resulttype {
    fn ex_from(m: ResulttypeInner) -> Resulttype {
        let (l, v) = m;
        Resulttype { l, v }
    }
}

pub struct ResulttypeMapper;
impl View for ResulttypeMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ResulttypeMapper {
    type Src = SpecResulttypeInner;
    type Dst = SpecResulttype;
}
impl SpecIsoProof for ResulttypeMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ResulttypeMapper {
    type Src = ResulttypeInner;
    type Dst = Resulttype;
    type RefSrc = ResulttypeInnerRef<'a>;
}

pub struct SpecResulttypeCombinator(pub SpecResulttypeCombinatorAlias);

impl SpecCombinator for SpecResulttypeCombinator {
    type Type = SpecResulttype;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecResulttypeCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecResulttypeCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecResulttypeCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecValtypeCombinator>>, ResulttypeMapper>;

pub struct ResulttypeCombinator(pub ResulttypeCombinatorAlias);

impl View for ResulttypeCombinator {
    type V = SpecResulttypeCombinator;
    open spec fn view(&self) -> Self::V { SpecResulttypeCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ResulttypeCombinator {
    type Type = Resulttype;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ResulttypeCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<ValtypeCombinator>, ResulttypeCont0>, ResulttypeMapper>;


pub open spec fn spec_resulttype() -> SpecResulttypeCombinator {
    SpecResulttypeCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_resulttype_cont0(deps)),
        mapper: ResulttypeMapper,
    })
}

pub open spec fn spec_resulttype_cont0(deps: u64) -> RepeatN<SpecValtypeCombinator> {
    let l = deps;
    RepeatN(spec_valtype(), l.spec_into())
}

impl View for ResulttypeCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecValtypeCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_resulttype_cont0(deps)
        }
    }
}

                
pub fn resulttype<'a>() -> (o: ResulttypeCombinator)
    ensures o@ == spec_resulttype(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ResulttypeCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, ResulttypeCont0),
        mapper: ResulttypeMapper,
    });
    assert({
        &&& combinator@ == spec_resulttype()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_resulttype<'a>(input: &'a [u8]) -> (res: PResult<<ResulttypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_resulttype().spec_parse(input@) == Some((n as int, v@)),
        spec_resulttype().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_resulttype().spec_parse(input@) is None,
        spec_resulttype().spec_parse(input@) is None ==> res is Err,
{
    let combinator = resulttype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_resulttype<'a>(v: <ResulttypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_resulttype().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_resulttype().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_resulttype().spec_serialize(v@))
        },
{
    let combinator = resulttype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn resulttype_len<'a>(v: <ResulttypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_resulttype().wf(v@),
        spec_resulttype().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_resulttype().spec_serialize(v@).len(),
{
    let combinator = resulttype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct ResulttypeCont0;
type ResulttypeCont0Type<'a, 'b> = &'b u64;
type ResulttypeCont0SType<'a, 'x> = &'x u64;
type ResulttypeCont0Input<'a, 'b, 'x> = POrSType<ResulttypeCont0Type<'a, 'b>, ResulttypeCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<ResulttypeCont0Input<'a, 'b, 'x>> for ResulttypeCont0 {
    type Output = RepeatN<ValtypeCombinator>;

    open spec fn requires(&self, deps: ResulttypeCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: ResulttypeCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_resulttype_cont0(deps@)
    }

    fn apply(&self, deps: ResulttypeCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(valtype(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(valtype(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecFunctype {
    pub tag: u8,
    pub params: SpecResulttype,
    pub results: SpecResulttype,
}

pub type SpecFunctypeInner = (u8, (SpecResulttype, SpecResulttype));


impl SpecFrom<SpecFunctype> for SpecFunctypeInner {
    open spec fn spec_from(m: SpecFunctype) -> SpecFunctypeInner {
        (m.tag, (m.params, m.results))
    }
}

impl SpecFrom<SpecFunctypeInner> for SpecFunctype {
    open spec fn spec_from(m: SpecFunctypeInner) -> SpecFunctype {
        let (tag, (params, results)) = m;
        SpecFunctype { tag, params, results }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Functype {
    pub tag: u8,
    pub params: Resulttype,
    pub results: Resulttype,
}

impl View for Functype {
    type V = SpecFunctype;

    open spec fn view(&self) -> Self::V {
        SpecFunctype {
            tag: self.tag@,
            params: self.params@,
            results: self.results@,
        }
    }
}
pub type FunctypeInner = (u8, (Resulttype, Resulttype));

pub type FunctypeInnerRef<'a> = (&'a u8, (&'a Resulttype, &'a Resulttype));
impl<'a> From<&'a Functype> for FunctypeInnerRef<'a> {
    fn ex_from(m: &'a Functype) -> FunctypeInnerRef<'a> {
        (&m.tag, (&m.params, &m.results))
    }
}

impl From<FunctypeInner> for Functype {
    fn ex_from(m: FunctypeInner) -> Functype {
        let (tag, (params, results)) = m;
        Functype { tag, params, results }
    }
}

pub struct FunctypeMapper;
impl View for FunctypeMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for FunctypeMapper {
    type Src = SpecFunctypeInner;
    type Dst = SpecFunctype;
}
impl SpecIsoProof for FunctypeMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for FunctypeMapper {
    type Src = FunctypeInner;
    type Dst = Functype;
    type RefSrc = FunctypeInnerRef<'a>;
}
pub const FUNCTYPETAG_CONST: u8 = 96;
type SpecFunctypeCombinatorAlias1 = (SpecResulttypeCombinator, SpecResulttypeCombinator);
type SpecFunctypeCombinatorAlias2 = (Refined<U8, TagPred<u8>>, SpecFunctypeCombinatorAlias1);
pub struct SpecFunctypeCombinator(pub SpecFunctypeCombinatorAlias);

impl SpecCombinator for SpecFunctypeCombinator {
    type Type = SpecFunctype;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecFunctypeCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecFunctypeCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecFunctypeCombinatorAlias = Mapped<SpecFunctypeCombinatorAlias2, FunctypeMapper>;
type FunctypeCombinatorAlias1 = (ResulttypeCombinator, ResulttypeCombinator);
type FunctypeCombinatorAlias2 = (Refined<U8, TagPred<u8>>, FunctypeCombinator1);
pub struct FunctypeCombinator1(pub FunctypeCombinatorAlias1);
impl View for FunctypeCombinator1 {
    type V = SpecFunctypeCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(FunctypeCombinator1, FunctypeCombinatorAlias1);

pub struct FunctypeCombinator2(pub FunctypeCombinatorAlias2);
impl View for FunctypeCombinator2 {
    type V = SpecFunctypeCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(FunctypeCombinator2, FunctypeCombinatorAlias2);

pub struct FunctypeCombinator(pub FunctypeCombinatorAlias);

impl View for FunctypeCombinator {
    type V = SpecFunctypeCombinator;
    open spec fn view(&self) -> Self::V { SpecFunctypeCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for FunctypeCombinator {
    type Type = Functype;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type FunctypeCombinatorAlias = Mapped<FunctypeCombinator2, FunctypeMapper>;


pub open spec fn spec_functype() -> SpecFunctypeCombinator {
    SpecFunctypeCombinator(
    Mapped {
        inner: (Refined { inner: U8, predicate: TagPred(FUNCTYPETAG_CONST) }, (spec_resulttype(), spec_resulttype())),
        mapper: FunctypeMapper,
    })
}

                
pub fn functype<'a>() -> (o: FunctypeCombinator)
    ensures o@ == spec_functype(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = FunctypeCombinator(
    Mapped {
        inner: FunctypeCombinator2((Refined { inner: U8, predicate: TagPred(FUNCTYPETAG_CONST) }, FunctypeCombinator1((resulttype(), resulttype())))),
        mapper: FunctypeMapper,
    });
    assert({
        &&& combinator@ == spec_functype()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_functype<'a>(input: &'a [u8]) -> (res: PResult<<FunctypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_functype().spec_parse(input@) == Some((n as int, v@)),
        spec_functype().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_functype().spec_parse(input@) is None,
        spec_functype().spec_parse(input@) is None ==> res is Err,
{
    let combinator = functype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_functype<'a>(v: <FunctypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_functype().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_functype().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_functype().spec_serialize(v@))
        },
{
    let combinator = functype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn functype_len<'a>(v: <FunctypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_functype().wf(v@),
        spec_functype().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_functype().spec_serialize(v@).len(),
{
    let combinator = functype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecTypesecContent {
    pub l: u64,
    pub v: Seq<SpecFunctype>,
}

pub type SpecTypesecContentInner = (u64, Seq<SpecFunctype>);


impl SpecFrom<SpecTypesecContent> for SpecTypesecContentInner {
    open spec fn spec_from(m: SpecTypesecContent) -> SpecTypesecContentInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecTypesecContentInner> for SpecTypesecContent {
    open spec fn spec_from(m: SpecTypesecContentInner) -> SpecTypesecContent {
        let (l, v) = m;
        SpecTypesecContent { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct TypesecContent {
    pub l: u64,
    pub v: RepeatResult<Functype>,
}

impl View for TypesecContent {
    type V = SpecTypesecContent;

    open spec fn view(&self) -> Self::V {
        SpecTypesecContent {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type TypesecContentInner = (u64, RepeatResult<Functype>);

pub type TypesecContentInnerRef<'a> = (&'a u64, &'a RepeatResult<Functype>);
impl<'a> From<&'a TypesecContent> for TypesecContentInnerRef<'a> {
    fn ex_from(m: &'a TypesecContent) -> TypesecContentInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl From<TypesecContentInner> for TypesecContent {
    fn ex_from(m: TypesecContentInner) -> TypesecContent {
        let (l, v) = m;
        TypesecContent { l, v }
    }
}

pub struct TypesecContentMapper;
impl View for TypesecContentMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for TypesecContentMapper {
    type Src = SpecTypesecContentInner;
    type Dst = SpecTypesecContent;
}
impl SpecIsoProof for TypesecContentMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for TypesecContentMapper {
    type Src = TypesecContentInner;
    type Dst = TypesecContent;
    type RefSrc = TypesecContentInnerRef<'a>;
}

pub struct SpecTypesecContentCombinator(pub SpecTypesecContentCombinatorAlias);

impl SpecCombinator for SpecTypesecContentCombinator {
    type Type = SpecTypesecContent;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTypesecContentCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTypesecContentCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTypesecContentCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecFunctypeCombinator>>, TypesecContentMapper>;

pub struct TypesecContentCombinator(pub TypesecContentCombinatorAlias);

impl View for TypesecContentCombinator {
    type V = SpecTypesecContentCombinator;
    open spec fn view(&self) -> Self::V { SpecTypesecContentCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TypesecContentCombinator {
    type Type = TypesecContent;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TypesecContentCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<FunctypeCombinator>, TypesecContentCont0>, TypesecContentMapper>;


pub open spec fn spec_typesec_content() -> SpecTypesecContentCombinator {
    SpecTypesecContentCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_typesec_content_cont0(deps)),
        mapper: TypesecContentMapper,
    })
}

pub open spec fn spec_typesec_content_cont0(deps: u64) -> RepeatN<SpecFunctypeCombinator> {
    let l = deps;
    RepeatN(spec_functype(), l.spec_into())
}

impl View for TypesecContentCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecFunctypeCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_typesec_content_cont0(deps)
        }
    }
}

                
pub fn typesec_content<'a>() -> (o: TypesecContentCombinator)
    ensures o@ == spec_typesec_content(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TypesecContentCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, TypesecContentCont0),
        mapper: TypesecContentMapper,
    });
    assert({
        &&& combinator@ == spec_typesec_content()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_typesec_content<'a>(input: &'a [u8]) -> (res: PResult<<TypesecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_typesec_content().spec_parse(input@) == Some((n as int, v@)),
        spec_typesec_content().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_typesec_content().spec_parse(input@) is None,
        spec_typesec_content().spec_parse(input@) is None ==> res is Err,
{
    let combinator = typesec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_typesec_content<'a>(v: <TypesecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_typesec_content().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_typesec_content().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_typesec_content().spec_serialize(v@))
        },
{
    let combinator = typesec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn typesec_content_len<'a>(v: <TypesecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_typesec_content().wf(v@),
        spec_typesec_content().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_typesec_content().spec_serialize(v@).len(),
{
    let combinator = typesec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct TypesecContentCont0;
type TypesecContentCont0Type<'a, 'b> = &'b u64;
type TypesecContentCont0SType<'a, 'x> = &'x u64;
type TypesecContentCont0Input<'a, 'b, 'x> = POrSType<TypesecContentCont0Type<'a, 'b>, TypesecContentCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<TypesecContentCont0Input<'a, 'b, 'x>> for TypesecContentCont0 {
    type Output = RepeatN<FunctypeCombinator>;

    open spec fn requires(&self, deps: TypesecContentCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: TypesecContentCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_typesec_content_cont0(deps@)
    }

    fn apply(&self, deps: TypesecContentCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(functype(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(functype(), l.ex_into())
            }
        }
    }
}
                
pub type SpecDataidx = u64;
pub type Dataidx = u64;
pub type DataidxRef<'a> = &'a u64;


pub struct SpecDataidxCombinator(pub SpecDataidxCombinatorAlias);

impl SpecCombinator for SpecDataidxCombinator {
    type Type = SpecDataidx;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecDataidxCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecDataidxCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecDataidxCombinatorAlias = UnsignedLEB128;

pub struct DataidxCombinator(pub DataidxCombinatorAlias);

impl View for DataidxCombinator {
    type V = SpecDataidxCombinator;
    open spec fn view(&self) -> Self::V { SpecDataidxCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for DataidxCombinator {
    type Type = Dataidx;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type DataidxCombinatorAlias = UnsignedLEB128;


pub open spec fn spec_dataidx() -> SpecDataidxCombinator {
    SpecDataidxCombinator(UnsignedLEB128)
}

                
pub fn dataidx<'a>() -> (o: DataidxCombinator)
    ensures o@ == spec_dataidx(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = DataidxCombinator(UnsignedLEB128);
    assert({
        &&& combinator@ == spec_dataidx()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_dataidx<'a>(input: &'a [u8]) -> (res: PResult<<DataidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_dataidx().spec_parse(input@) == Some((n as int, v@)),
        spec_dataidx().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_dataidx().spec_parse(input@) is None,
        spec_dataidx().spec_parse(input@) is None ==> res is Err,
{
    let combinator = dataidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_dataidx<'a>(v: <DataidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_dataidx().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_dataidx().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_dataidx().spec_serialize(v@))
        },
{
    let combinator = dataidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn dataidx_len<'a>(v: <DataidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_dataidx().wf(v@),
        spec_dataidx().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_dataidx().spec_serialize(v@).len(),
{
    let combinator = dataidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecDataDrop = SpecDataidx;
pub type DataDrop = Dataidx;
pub type DataDropRef<'a> = &'a Dataidx;


pub struct SpecDataDropCombinator(pub SpecDataDropCombinatorAlias);

impl SpecCombinator for SpecDataDropCombinator {
    type Type = SpecDataDrop;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecDataDropCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecDataDropCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecDataDropCombinatorAlias = SpecDataidxCombinator;

pub struct DataDropCombinator(pub DataDropCombinatorAlias);

impl View for DataDropCombinator {
    type V = SpecDataDropCombinator;
    open spec fn view(&self) -> Self::V { SpecDataDropCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for DataDropCombinator {
    type Type = DataDrop;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type DataDropCombinatorAlias = DataidxCombinator;


pub open spec fn spec_data_drop() -> SpecDataDropCombinator {
    SpecDataDropCombinator(spec_dataidx())
}

                
pub fn data_drop<'a>() -> (o: DataDropCombinator)
    ensures o@ == spec_data_drop(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = DataDropCombinator(dataidx());
    assert({
        &&& combinator@ == spec_data_drop()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_data_drop<'a>(input: &'a [u8]) -> (res: PResult<<DataDropCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_data_drop().spec_parse(input@) == Some((n as int, v@)),
        spec_data_drop().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_data_drop().spec_parse(input@) is None,
        spec_data_drop().spec_parse(input@) is None ==> res is Err,
{
    let combinator = data_drop();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_data_drop<'a>(v: <DataDropCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_data_drop().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_data_drop().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_data_drop().spec_serialize(v@))
        },
{
    let combinator = data_drop();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn data_drop_len<'a>(v: <DataDropCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_data_drop().wf(v@),
        spec_data_drop().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_data_drop().spec_serialize(v@).len(),
{
    let combinator = data_drop();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecTypeidx = u64;
pub type Typeidx = u64;
pub type TypeidxRef<'a> = &'a u64;


pub struct SpecTypeidxCombinator(pub SpecTypeidxCombinatorAlias);

impl SpecCombinator for SpecTypeidxCombinator {
    type Type = SpecTypeidx;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTypeidxCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTypeidxCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTypeidxCombinatorAlias = UnsignedLEB128;

pub struct TypeidxCombinator(pub TypeidxCombinatorAlias);

impl View for TypeidxCombinator {
    type V = SpecTypeidxCombinator;
    open spec fn view(&self) -> Self::V { SpecTypeidxCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TypeidxCombinator {
    type Type = Typeidx;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TypeidxCombinatorAlias = UnsignedLEB128;


pub open spec fn spec_typeidx() -> SpecTypeidxCombinator {
    SpecTypeidxCombinator(UnsignedLEB128)
}

                
pub fn typeidx<'a>() -> (o: TypeidxCombinator)
    ensures o@ == spec_typeidx(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TypeidxCombinator(UnsignedLEB128);
    assert({
        &&& combinator@ == spec_typeidx()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_typeidx<'a>(input: &'a [u8]) -> (res: PResult<<TypeidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_typeidx().spec_parse(input@) == Some((n as int, v@)),
        spec_typeidx().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_typeidx().spec_parse(input@) is None,
        spec_typeidx().spec_parse(input@) is None ==> res is Err,
{
    let combinator = typeidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_typeidx<'a>(v: <TypeidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_typeidx().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_typeidx().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_typeidx().spec_serialize(v@))
        },
{
    let combinator = typeidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn typeidx_len<'a>(v: <TypeidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_typeidx().wf(v@),
        spec_typeidx().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_typeidx().spec_serialize(v@).len(),
{
    let combinator = typeidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecFuncsecContent {
    pub l: u64,
    pub v: Seq<SpecTypeidx>,
}

pub type SpecFuncsecContentInner = (u64, Seq<SpecTypeidx>);


impl SpecFrom<SpecFuncsecContent> for SpecFuncsecContentInner {
    open spec fn spec_from(m: SpecFuncsecContent) -> SpecFuncsecContentInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecFuncsecContentInner> for SpecFuncsecContent {
    open spec fn spec_from(m: SpecFuncsecContentInner) -> SpecFuncsecContent {
        let (l, v) = m;
        SpecFuncsecContent { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct FuncsecContent {
    pub l: u64,
    pub v: RepeatResult<Typeidx>,
}

impl View for FuncsecContent {
    type V = SpecFuncsecContent;

    open spec fn view(&self) -> Self::V {
        SpecFuncsecContent {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type FuncsecContentInner = (u64, RepeatResult<Typeidx>);

pub type FuncsecContentInnerRef<'a> = (&'a u64, &'a RepeatResult<Typeidx>);
impl<'a> From<&'a FuncsecContent> for FuncsecContentInnerRef<'a> {
    fn ex_from(m: &'a FuncsecContent) -> FuncsecContentInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl From<FuncsecContentInner> for FuncsecContent {
    fn ex_from(m: FuncsecContentInner) -> FuncsecContent {
        let (l, v) = m;
        FuncsecContent { l, v }
    }
}

pub struct FuncsecContentMapper;
impl View for FuncsecContentMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for FuncsecContentMapper {
    type Src = SpecFuncsecContentInner;
    type Dst = SpecFuncsecContent;
}
impl SpecIsoProof for FuncsecContentMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for FuncsecContentMapper {
    type Src = FuncsecContentInner;
    type Dst = FuncsecContent;
    type RefSrc = FuncsecContentInnerRef<'a>;
}

pub struct SpecFuncsecContentCombinator(pub SpecFuncsecContentCombinatorAlias);

impl SpecCombinator for SpecFuncsecContentCombinator {
    type Type = SpecFuncsecContent;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecFuncsecContentCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecFuncsecContentCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecFuncsecContentCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecTypeidxCombinator>>, FuncsecContentMapper>;

pub struct FuncsecContentCombinator(pub FuncsecContentCombinatorAlias);

impl View for FuncsecContentCombinator {
    type V = SpecFuncsecContentCombinator;
    open spec fn view(&self) -> Self::V { SpecFuncsecContentCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for FuncsecContentCombinator {
    type Type = FuncsecContent;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type FuncsecContentCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<TypeidxCombinator>, FuncsecContentCont0>, FuncsecContentMapper>;


pub open spec fn spec_funcsec_content() -> SpecFuncsecContentCombinator {
    SpecFuncsecContentCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_funcsec_content_cont0(deps)),
        mapper: FuncsecContentMapper,
    })
}

pub open spec fn spec_funcsec_content_cont0(deps: u64) -> RepeatN<SpecTypeidxCombinator> {
    let l = deps;
    RepeatN(spec_typeidx(), l.spec_into())
}

impl View for FuncsecContentCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecTypeidxCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_funcsec_content_cont0(deps)
        }
    }
}

                
pub fn funcsec_content<'a>() -> (o: FuncsecContentCombinator)
    ensures o@ == spec_funcsec_content(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = FuncsecContentCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, FuncsecContentCont0),
        mapper: FuncsecContentMapper,
    });
    assert({
        &&& combinator@ == spec_funcsec_content()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_funcsec_content<'a>(input: &'a [u8]) -> (res: PResult<<FuncsecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_funcsec_content().spec_parse(input@) == Some((n as int, v@)),
        spec_funcsec_content().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_funcsec_content().spec_parse(input@) is None,
        spec_funcsec_content().spec_parse(input@) is None ==> res is Err,
{
    let combinator = funcsec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_funcsec_content<'a>(v: <FuncsecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_funcsec_content().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_funcsec_content().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_funcsec_content().spec_serialize(v@))
        },
{
    let combinator = funcsec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn funcsec_content_len<'a>(v: <FuncsecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_funcsec_content().wf(v@),
        spec_funcsec_content().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_funcsec_content().spec_serialize(v@).len(),
{
    let combinator = funcsec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct FuncsecContentCont0;
type FuncsecContentCont0Type<'a, 'b> = &'b u64;
type FuncsecContentCont0SType<'a, 'x> = &'x u64;
type FuncsecContentCont0Input<'a, 'b, 'x> = POrSType<FuncsecContentCont0Type<'a, 'b>, FuncsecContentCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<FuncsecContentCont0Input<'a, 'b, 'x>> for FuncsecContentCont0 {
    type Output = RepeatN<TypeidxCombinator>;

    open spec fn requires(&self, deps: FuncsecContentCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: FuncsecContentCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_funcsec_content_cont0(deps@)
    }

    fn apply(&self, deps: FuncsecContentCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(typeidx(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(typeidx(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecFuncsec {
    pub size: u64,
    pub cont: SpecFuncsecContent,
}

pub type SpecFuncsecInner = (u64, SpecFuncsecContent);


impl SpecFrom<SpecFuncsec> for SpecFuncsecInner {
    open spec fn spec_from(m: SpecFuncsec) -> SpecFuncsecInner {
        (m.size, m.cont)
    }
}

impl SpecFrom<SpecFuncsecInner> for SpecFuncsec {
    open spec fn spec_from(m: SpecFuncsecInner) -> SpecFuncsec {
        let (size, cont) = m;
        SpecFuncsec { size, cont }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Funcsec {
    pub size: u64,
    pub cont: FuncsecContent,
}

impl View for Funcsec {
    type V = SpecFuncsec;

    open spec fn view(&self) -> Self::V {
        SpecFuncsec {
            size: self.size@,
            cont: self.cont@,
        }
    }
}
pub type FuncsecInner = (u64, FuncsecContent);

pub type FuncsecInnerRef<'a> = (&'a u64, &'a FuncsecContent);
impl<'a> From<&'a Funcsec> for FuncsecInnerRef<'a> {
    fn ex_from(m: &'a Funcsec) -> FuncsecInnerRef<'a> {
        (&m.size, &m.cont)
    }
}

impl From<FuncsecInner> for Funcsec {
    fn ex_from(m: FuncsecInner) -> Funcsec {
        let (size, cont) = m;
        Funcsec { size, cont }
    }
}

pub struct FuncsecMapper;
impl View for FuncsecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for FuncsecMapper {
    type Src = SpecFuncsecInner;
    type Dst = SpecFuncsec;
}
impl SpecIsoProof for FuncsecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for FuncsecMapper {
    type Src = FuncsecInner;
    type Dst = Funcsec;
    type RefSrc = FuncsecInnerRef<'a>;
}

pub struct SpecFuncsecCombinator(pub SpecFuncsecCombinatorAlias);

impl SpecCombinator for SpecFuncsecCombinator {
    type Type = SpecFuncsec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecFuncsecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecFuncsecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecFuncsecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, SpecFuncsecContentCombinator>>, FuncsecMapper>;

pub struct FuncsecCombinator(pub FuncsecCombinatorAlias);

impl View for FuncsecCombinator {
    type V = SpecFuncsecCombinator;
    open spec fn view(&self) -> Self::V { SpecFuncsecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for FuncsecCombinator {
    type Type = Funcsec;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type FuncsecCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, FuncsecContentCombinator>, FuncsecCont0>, FuncsecMapper>;


pub open spec fn spec_funcsec() -> SpecFuncsecCombinator {
    SpecFuncsecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_funcsec_cont0(deps)),
        mapper: FuncsecMapper,
    })
}

pub open spec fn spec_funcsec_cont0(deps: u64) -> AndThen<bytes::Variable, SpecFuncsecContentCombinator> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), spec_funcsec_content())
}

impl View for FuncsecCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, SpecFuncsecContentCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_funcsec_cont0(deps)
        }
    }
}

                
pub fn funcsec<'a>() -> (o: FuncsecCombinator)
    ensures o@ == spec_funcsec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = FuncsecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, FuncsecCont0),
        mapper: FuncsecMapper,
    });
    assert({
        &&& combinator@ == spec_funcsec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_funcsec<'a>(input: &'a [u8]) -> (res: PResult<<FuncsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_funcsec().spec_parse(input@) == Some((n as int, v@)),
        spec_funcsec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_funcsec().spec_parse(input@) is None,
        spec_funcsec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = funcsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_funcsec<'a>(v: <FuncsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_funcsec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_funcsec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_funcsec().spec_serialize(v@))
        },
{
    let combinator = funcsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn funcsec_len<'a>(v: <FuncsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_funcsec().wf(v@),
        spec_funcsec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_funcsec().spec_serialize(v@).len(),
{
    let combinator = funcsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct FuncsecCont0;
type FuncsecCont0Type<'a, 'b> = &'b u64;
type FuncsecCont0SType<'a, 'x> = &'x u64;
type FuncsecCont0Input<'a, 'b, 'x> = POrSType<FuncsecCont0Type<'a, 'b>, FuncsecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<FuncsecCont0Input<'a, 'b, 'x>> for FuncsecCont0 {
    type Output = AndThen<bytes::Variable, FuncsecContentCombinator>;

    open spec fn requires(&self, deps: FuncsecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: FuncsecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_funcsec_cont0(deps@)
    }

    fn apply(&self, deps: FuncsecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), funcsec_content())
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), funcsec_content())
            }
        }
    }
}
                
pub type SpecELEMKIND = u8;
pub type ELEMKIND = u8;
pub type ELEMKINDRef<'a> = &'a u8;

pub const ELEMKIND_CONST: u8 = 0;
pub type SpecELEMKINDCombinator = Refined<U8, TagPred<u8>>;
pub type ELEMKINDCombinator = Refined<U8, TagPred<u8>>;


pub open spec fn spec_ELEMKIND() -> SpecELEMKINDCombinator {
    Refined { inner: U8, predicate: TagPred(ELEMKIND_CONST) }
}

pub fn ELEMKIND<'a>() -> (o: ELEMKINDCombinator)
    ensures o@ == spec_ELEMKIND(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = Refined { inner: U8, predicate: TagPred(ELEMKIND_CONST) };
    assert({
        &&& combinator@ == spec_ELEMKIND()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_ELEMKIND<'a>(input: &'a [u8]) -> (res: PResult<<ELEMKINDCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_ELEMKIND().spec_parse(input@) == Some((n as int, v@)),
        spec_ELEMKIND().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_ELEMKIND().spec_parse(input@) is None,
        spec_ELEMKIND().spec_parse(input@) is None ==> res is Err,
{
    let combinator = ELEMKIND();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_ELEMKIND<'a>(v: <ELEMKINDCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_ELEMKIND().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_ELEMKIND().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_ELEMKIND().spec_serialize(v@))
        },
{
    let combinator = ELEMKIND();
    combinator.serialize(v, data, pos)
}

pub fn ELEMKIND_len<'a>(v: <ELEMKINDCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_ELEMKIND().wf(v@),
        spec_ELEMKIND().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_ELEMKIND().spec_serialize(v@).len(),
{
    let combinator = ELEMKIND();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub type SpecF32 = Seq<u8>;
pub type F32<'a> = &'a [u8];
pub type F32Ref<'a> = &'a &'a [u8];


pub struct SpecF32Combinator(pub SpecF32CombinatorAlias);

impl SpecCombinator for SpecF32Combinator {
    type Type = SpecF32;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecF32Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecF32CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecF32CombinatorAlias = bytes::Fixed<4>;

pub struct F32Combinator(pub F32CombinatorAlias);

impl View for F32Combinator {
    type V = SpecF32Combinator;
    open spec fn view(&self) -> Self::V { SpecF32Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for F32Combinator {
    type Type = F32<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type F32CombinatorAlias = bytes::Fixed<4>;


pub open spec fn spec_f32() -> SpecF32Combinator {
    SpecF32Combinator(bytes::Fixed::<4>)
}

                
pub fn f32<'a>() -> (o: F32Combinator)
    ensures o@ == spec_f32(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = F32Combinator(bytes::Fixed::<4>);
    assert({
        &&& combinator@ == spec_f32()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_f32<'a>(input: &'a [u8]) -> (res: PResult<<F32Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_f32().spec_parse(input@) == Some((n as int, v@)),
        spec_f32().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_f32().spec_parse(input@) is None,
        spec_f32().spec_parse(input@) is None ==> res is Err,
{
    let combinator = f32();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_f32<'a>(v: <F32Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_f32().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_f32().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_f32().spec_serialize(v@))
        },
{
    let combinator = f32();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn f32_len<'a>(v: <F32Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_f32().wf(v@),
        spec_f32().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_f32().spec_serialize(v@).len(),
{
    let combinator = f32();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecLocalCompressed {
    pub count: u64,
    pub vt: SpecValtype,
}

pub type SpecLocalCompressedInner = (u64, SpecValtype);


impl SpecFrom<SpecLocalCompressed> for SpecLocalCompressedInner {
    open spec fn spec_from(m: SpecLocalCompressed) -> SpecLocalCompressedInner {
        (m.count, m.vt)
    }
}

impl SpecFrom<SpecLocalCompressedInner> for SpecLocalCompressed {
    open spec fn spec_from(m: SpecLocalCompressedInner) -> SpecLocalCompressed {
        let (count, vt) = m;
        SpecLocalCompressed { count, vt }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct LocalCompressed {
    pub count: u64,
    pub vt: Valtype,
}

impl View for LocalCompressed {
    type V = SpecLocalCompressed;

    open spec fn view(&self) -> Self::V {
        SpecLocalCompressed {
            count: self.count@,
            vt: self.vt@,
        }
    }
}
pub type LocalCompressedInner = (u64, Valtype);

pub type LocalCompressedInnerRef<'a> = (&'a u64, &'a Valtype);
impl<'a> From<&'a LocalCompressed> for LocalCompressedInnerRef<'a> {
    fn ex_from(m: &'a LocalCompressed) -> LocalCompressedInnerRef<'a> {
        (&m.count, &m.vt)
    }
}

impl From<LocalCompressedInner> for LocalCompressed {
    fn ex_from(m: LocalCompressedInner) -> LocalCompressed {
        let (count, vt) = m;
        LocalCompressed { count, vt }
    }
}

pub struct LocalCompressedMapper;
impl View for LocalCompressedMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for LocalCompressedMapper {
    type Src = SpecLocalCompressedInner;
    type Dst = SpecLocalCompressed;
}
impl SpecIsoProof for LocalCompressedMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for LocalCompressedMapper {
    type Src = LocalCompressedInner;
    type Dst = LocalCompressed;
    type RefSrc = LocalCompressedInnerRef<'a>;
}
type SpecLocalCompressedCombinatorAlias1 = (UnsignedLEB128, SpecValtypeCombinator);
pub struct SpecLocalCompressedCombinator(pub SpecLocalCompressedCombinatorAlias);

impl SpecCombinator for SpecLocalCompressedCombinator {
    type Type = SpecLocalCompressed;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecLocalCompressedCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecLocalCompressedCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecLocalCompressedCombinatorAlias = Mapped<SpecLocalCompressedCombinatorAlias1, LocalCompressedMapper>;
type LocalCompressedCombinatorAlias1 = (UnsignedLEB128, ValtypeCombinator);
pub struct LocalCompressedCombinator1(pub LocalCompressedCombinatorAlias1);
impl View for LocalCompressedCombinator1 {
    type V = SpecLocalCompressedCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(LocalCompressedCombinator1, LocalCompressedCombinatorAlias1);

pub struct LocalCompressedCombinator(pub LocalCompressedCombinatorAlias);

impl View for LocalCompressedCombinator {
    type V = SpecLocalCompressedCombinator;
    open spec fn view(&self) -> Self::V { SpecLocalCompressedCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for LocalCompressedCombinator {
    type Type = LocalCompressed;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type LocalCompressedCombinatorAlias = Mapped<LocalCompressedCombinator1, LocalCompressedMapper>;


pub open spec fn spec_local_compressed() -> SpecLocalCompressedCombinator {
    SpecLocalCompressedCombinator(
    Mapped {
        inner: (UnsignedLEB128, spec_valtype()),
        mapper: LocalCompressedMapper,
    })
}

                
pub fn local_compressed<'a>() -> (o: LocalCompressedCombinator)
    ensures o@ == spec_local_compressed(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = LocalCompressedCombinator(
    Mapped {
        inner: LocalCompressedCombinator1((UnsignedLEB128, valtype())),
        mapper: LocalCompressedMapper,
    });
    assert({
        &&& combinator@ == spec_local_compressed()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_local_compressed<'a>(input: &'a [u8]) -> (res: PResult<<LocalCompressedCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_local_compressed().spec_parse(input@) == Some((n as int, v@)),
        spec_local_compressed().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_local_compressed().spec_parse(input@) is None,
        spec_local_compressed().spec_parse(input@) is None ==> res is Err,
{
    let combinator = local_compressed();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_local_compressed<'a>(v: <LocalCompressedCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_local_compressed().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_local_compressed().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_local_compressed().spec_serialize(v@))
        },
{
    let combinator = local_compressed();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn local_compressed_len<'a>(v: <LocalCompressedCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_local_compressed().wf(v@),
        spec_local_compressed().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_local_compressed().spec_serialize(v@).len(),
{
    let combinator = local_compressed();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecLimitMin {
    pub min: u64,
}

pub type SpecLimitMinInner = u64;


impl SpecFrom<SpecLimitMin> for SpecLimitMinInner {
    open spec fn spec_from(m: SpecLimitMin) -> SpecLimitMinInner {
        m.min
    }
}

impl SpecFrom<SpecLimitMinInner> for SpecLimitMin {
    open spec fn spec_from(m: SpecLimitMinInner) -> SpecLimitMin {
        let min = m;
        SpecLimitMin { min }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct LimitMin {
    pub min: u64,
}

impl View for LimitMin {
    type V = SpecLimitMin;

    open spec fn view(&self) -> Self::V {
        SpecLimitMin {
            min: self.min@,
        }
    }
}
pub type LimitMinInner = u64;

pub type LimitMinInnerRef<'a> = &'a u64;
impl<'a> From<&'a LimitMin> for LimitMinInnerRef<'a> {
    fn ex_from(m: &'a LimitMin) -> LimitMinInnerRef<'a> {
        &m.min
    }
}

impl From<LimitMinInner> for LimitMin {
    fn ex_from(m: LimitMinInner) -> LimitMin {
        let min = m;
        LimitMin { min }
    }
}

pub struct LimitMinMapper;
impl View for LimitMinMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for LimitMinMapper {
    type Src = SpecLimitMinInner;
    type Dst = SpecLimitMin;
}
impl SpecIsoProof for LimitMinMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for LimitMinMapper {
    type Src = LimitMinInner;
    type Dst = LimitMin;
    type RefSrc = LimitMinInnerRef<'a>;
}

pub struct SpecLimitMinCombinator(pub SpecLimitMinCombinatorAlias);

impl SpecCombinator for SpecLimitMinCombinator {
    type Type = SpecLimitMin;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecLimitMinCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecLimitMinCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecLimitMinCombinatorAlias = Mapped<UnsignedLEB128, LimitMinMapper>;

pub struct LimitMinCombinator(pub LimitMinCombinatorAlias);

impl View for LimitMinCombinator {
    type V = SpecLimitMinCombinator;
    open spec fn view(&self) -> Self::V { SpecLimitMinCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for LimitMinCombinator {
    type Type = LimitMin;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type LimitMinCombinatorAlias = Mapped<UnsignedLEB128, LimitMinMapper>;


pub open spec fn spec_limit_min() -> SpecLimitMinCombinator {
    SpecLimitMinCombinator(
    Mapped {
        inner: UnsignedLEB128,
        mapper: LimitMinMapper,
    })
}

                
pub fn limit_min<'a>() -> (o: LimitMinCombinator)
    ensures o@ == spec_limit_min(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = LimitMinCombinator(
    Mapped {
        inner: UnsignedLEB128,
        mapper: LimitMinMapper,
    });
    assert({
        &&& combinator@ == spec_limit_min()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_limit_min<'a>(input: &'a [u8]) -> (res: PResult<<LimitMinCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_limit_min().spec_parse(input@) == Some((n as int, v@)),
        spec_limit_min().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_limit_min().spec_parse(input@) is None,
        spec_limit_min().spec_parse(input@) is None ==> res is Err,
{
    let combinator = limit_min();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_limit_min<'a>(v: <LimitMinCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_limit_min().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_limit_min().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_limit_min().spec_serialize(v@))
        },
{
    let combinator = limit_min();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn limit_min_len<'a>(v: <LimitMinCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_limit_min().wf(v@),
        spec_limit_min().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_limit_min().spec_serialize(v@).len(),
{
    let combinator = limit_min();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecLimitMinMax {
    pub min: u64,
    pub max: u64,
}

pub type SpecLimitMinMaxInner = (u64, u64);


impl SpecFrom<SpecLimitMinMax> for SpecLimitMinMaxInner {
    open spec fn spec_from(m: SpecLimitMinMax) -> SpecLimitMinMaxInner {
        (m.min, m.max)
    }
}

impl SpecFrom<SpecLimitMinMaxInner> for SpecLimitMinMax {
    open spec fn spec_from(m: SpecLimitMinMaxInner) -> SpecLimitMinMax {
        let (min, max) = m;
        SpecLimitMinMax { min, max }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct LimitMinMax {
    pub min: u64,
    pub max: u64,
}

impl View for LimitMinMax {
    type V = SpecLimitMinMax;

    open spec fn view(&self) -> Self::V {
        SpecLimitMinMax {
            min: self.min@,
            max: self.max@,
        }
    }
}
pub type LimitMinMaxInner = (u64, u64);

pub type LimitMinMaxInnerRef<'a> = (&'a u64, &'a u64);
impl<'a> From<&'a LimitMinMax> for LimitMinMaxInnerRef<'a> {
    fn ex_from(m: &'a LimitMinMax) -> LimitMinMaxInnerRef<'a> {
        (&m.min, &m.max)
    }
}

impl From<LimitMinMaxInner> for LimitMinMax {
    fn ex_from(m: LimitMinMaxInner) -> LimitMinMax {
        let (min, max) = m;
        LimitMinMax { min, max }
    }
}

pub struct LimitMinMaxMapper;
impl View for LimitMinMaxMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for LimitMinMaxMapper {
    type Src = SpecLimitMinMaxInner;
    type Dst = SpecLimitMinMax;
}
impl SpecIsoProof for LimitMinMaxMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for LimitMinMaxMapper {
    type Src = LimitMinMaxInner;
    type Dst = LimitMinMax;
    type RefSrc = LimitMinMaxInnerRef<'a>;
}
type SpecLimitMinMaxCombinatorAlias1 = (UnsignedLEB128, UnsignedLEB128);
pub struct SpecLimitMinMaxCombinator(pub SpecLimitMinMaxCombinatorAlias);

impl SpecCombinator for SpecLimitMinMaxCombinator {
    type Type = SpecLimitMinMax;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecLimitMinMaxCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecLimitMinMaxCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecLimitMinMaxCombinatorAlias = Mapped<SpecLimitMinMaxCombinatorAlias1, LimitMinMaxMapper>;
type LimitMinMaxCombinatorAlias1 = (UnsignedLEB128, UnsignedLEB128);
pub struct LimitMinMaxCombinator1(pub LimitMinMaxCombinatorAlias1);
impl View for LimitMinMaxCombinator1 {
    type V = SpecLimitMinMaxCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(LimitMinMaxCombinator1, LimitMinMaxCombinatorAlias1);

pub struct LimitMinMaxCombinator(pub LimitMinMaxCombinatorAlias);

impl View for LimitMinMaxCombinator {
    type V = SpecLimitMinMaxCombinator;
    open spec fn view(&self) -> Self::V { SpecLimitMinMaxCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for LimitMinMaxCombinator {
    type Type = LimitMinMax;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type LimitMinMaxCombinatorAlias = Mapped<LimitMinMaxCombinator1, LimitMinMaxMapper>;


pub open spec fn spec_limit_min_max() -> SpecLimitMinMaxCombinator {
    SpecLimitMinMaxCombinator(
    Mapped {
        inner: (UnsignedLEB128, UnsignedLEB128),
        mapper: LimitMinMaxMapper,
    })
}

                
pub fn limit_min_max<'a>() -> (o: LimitMinMaxCombinator)
    ensures o@ == spec_limit_min_max(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = LimitMinMaxCombinator(
    Mapped {
        inner: LimitMinMaxCombinator1((UnsignedLEB128, UnsignedLEB128)),
        mapper: LimitMinMaxMapper,
    });
    assert({
        &&& combinator@ == spec_limit_min_max()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_limit_min_max<'a>(input: &'a [u8]) -> (res: PResult<<LimitMinMaxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_limit_min_max().spec_parse(input@) == Some((n as int, v@)),
        spec_limit_min_max().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_limit_min_max().spec_parse(input@) is None,
        spec_limit_min_max().spec_parse(input@) is None ==> res is Err,
{
    let combinator = limit_min_max();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_limit_min_max<'a>(v: <LimitMinMaxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_limit_min_max().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_limit_min_max().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_limit_min_max().spec_serialize(v@))
        },
{
    let combinator = limit_min_max();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn limit_min_max_len<'a>(v: <LimitMinMaxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_limit_min_max().wf(v@),
        spec_limit_min_max().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_limit_min_max().spec_serialize(v@).len(),
{
    let combinator = limit_min_max();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub enum SpecLimits {
    NoMax(SpecLimitMin),
    Max(SpecLimitMinMax),
}

pub type SpecLimitsInner = Either<SpecLimitMin, SpecLimitMinMax>;

impl SpecFrom<SpecLimits> for SpecLimitsInner {
    open spec fn spec_from(m: SpecLimits) -> SpecLimitsInner {
        match m {
            SpecLimits::NoMax(m) => Either::Left(m),
            SpecLimits::Max(m) => Either::Right(m),
        }
    }

}

                
impl SpecFrom<SpecLimitsInner> for SpecLimits {
    open spec fn spec_from(m: SpecLimitsInner) -> SpecLimits {
        match m {
            Either::Left(m) => SpecLimits::NoMax(m),
            Either::Right(m) => SpecLimits::Max(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Limits {
    NoMax(LimitMin),
    Max(LimitMinMax),
}

pub type LimitsInner = Either<LimitMin, LimitMinMax>;

pub type LimitsInnerRef<'a> = Either<&'a LimitMin, &'a LimitMinMax>;


impl View for Limits {
    type V = SpecLimits;
    open spec fn view(&self) -> Self::V {
        match self {
            Limits::NoMax(m) => SpecLimits::NoMax(m@),
            Limits::Max(m) => SpecLimits::Max(m@),
        }
    }
}


impl<'a> From<&'a Limits> for LimitsInnerRef<'a> {
    fn ex_from(m: &'a Limits) -> LimitsInnerRef<'a> {
        match m {
            Limits::NoMax(m) => Either::Left(m),
            Limits::Max(m) => Either::Right(m),
        }
    }

}

impl From<LimitsInner> for Limits {
    fn ex_from(m: LimitsInner) -> Limits {
        match m {
            Either::Left(m) => Limits::NoMax(m),
            Either::Right(m) => Limits::Max(m),
        }
    }
    
}


pub struct LimitsMapper;
impl View for LimitsMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for LimitsMapper {
    type Src = SpecLimitsInner;
    type Dst = SpecLimits;
}
impl SpecIsoProof for LimitsMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for LimitsMapper {
    type Src = LimitsInner;
    type Dst = Limits;
    type RefSrc = LimitsInnerRef<'a>;
}

pub const LIMITSNOMAX_0_FRONT_CONST: u8 = 0;

pub const LIMITSMAX_0_FRONT_CONST: u8 = 1;

type SpecLimitsCombinatorAlias1 = Choice<Preceded<Tag<U8, u8>, SpecLimitMinCombinator>, Preceded<Tag<U8, u8>, SpecLimitMinMaxCombinator>>;
pub struct SpecLimitsCombinator(pub SpecLimitsCombinatorAlias);

impl SpecCombinator for SpecLimitsCombinator {
    type Type = SpecLimits;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecLimitsCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecLimitsCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecLimitsCombinatorAlias = Mapped<SpecLimitsCombinatorAlias1, LimitsMapper>;


type LimitsCombinatorAlias1 = Choice<Preceded<Tag<U8, u8>, LimitMinCombinator>, Preceded<Tag<U8, u8>, LimitMinMaxCombinator>>;
pub struct LimitsCombinator1(pub LimitsCombinatorAlias1);
impl View for LimitsCombinator1 {
    type V = SpecLimitsCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(LimitsCombinator1, LimitsCombinatorAlias1);

pub struct LimitsCombinator(pub LimitsCombinatorAlias);

impl View for LimitsCombinator {
    type V = SpecLimitsCombinator;
    open spec fn view(&self) -> Self::V { SpecLimitsCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for LimitsCombinator {
    type Type = Limits;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type LimitsCombinatorAlias = Mapped<LimitsCombinator1, LimitsMapper>;


pub open spec fn spec_limits() -> SpecLimitsCombinator {
    SpecLimitsCombinator(Mapped { inner: Choice(Preceded(Tag::spec_new(U8, LIMITSNOMAX_0_FRONT_CONST), spec_limit_min()), Preceded(Tag::spec_new(U8, LIMITSMAX_0_FRONT_CONST), spec_limit_min_max())), mapper: LimitsMapper })
}

                
pub fn limits<'a>() -> (o: LimitsCombinator)
    ensures o@ == spec_limits(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = LimitsCombinator(Mapped { inner: LimitsCombinator1(Choice::new(Preceded(Tag::new(U8, LIMITSNOMAX_0_FRONT_CONST), limit_min()), Preceded(Tag::new(U8, LIMITSMAX_0_FRONT_CONST), limit_min_max()))), mapper: LimitsMapper });
    assert({
        &&& combinator@ == spec_limits()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_limits<'a>(input: &'a [u8]) -> (res: PResult<<LimitsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_limits().spec_parse(input@) == Some((n as int, v@)),
        spec_limits().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_limits().spec_parse(input@) is None,
        spec_limits().spec_parse(input@) is None ==> res is Err,
{
    let combinator = limits();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_limits<'a>(v: <LimitsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_limits().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_limits().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_limits().spec_serialize(v@))
        },
{
    let combinator = limits();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn limits_len<'a>(v: <LimitsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_limits().wf(v@),
        spec_limits().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_limits().spec_serialize(v@).len(),
{
    let combinator = limits();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecMemtype = SpecLimits;
pub type Memtype = Limits;
pub type MemtypeRef<'a> = &'a Limits;


pub struct SpecMemtypeCombinator(pub SpecMemtypeCombinatorAlias);

impl SpecCombinator for SpecMemtypeCombinator {
    type Type = SpecMemtype;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecMemtypeCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecMemtypeCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecMemtypeCombinatorAlias = SpecLimitsCombinator;

pub struct MemtypeCombinator(pub MemtypeCombinatorAlias);

impl View for MemtypeCombinator {
    type V = SpecMemtypeCombinator;
    open spec fn view(&self) -> Self::V { SpecMemtypeCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for MemtypeCombinator {
    type Type = Memtype;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type MemtypeCombinatorAlias = LimitsCombinator;


pub open spec fn spec_memtype() -> SpecMemtypeCombinator {
    SpecMemtypeCombinator(spec_limits())
}

                
pub fn memtype<'a>() -> (o: MemtypeCombinator)
    ensures o@ == spec_memtype(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = MemtypeCombinator(limits());
    assert({
        &&& combinator@ == spec_memtype()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_memtype<'a>(input: &'a [u8]) -> (res: PResult<<MemtypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_memtype().spec_parse(input@) == Some((n as int, v@)),
        spec_memtype().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_memtype().spec_parse(input@) is None,
        spec_memtype().spec_parse(input@) is None ==> res is Err,
{
    let combinator = memtype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_memtype<'a>(v: <MemtypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_memtype().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_memtype().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_memtype().spec_serialize(v@))
        },
{
    let combinator = memtype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn memtype_len<'a>(v: <MemtypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_memtype().wf(v@),
        spec_memtype().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_memtype().spec_serialize(v@).len(),
{
    let combinator = memtype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecMem {
    pub ty: SpecMemtype,
}

pub type SpecMemInner = SpecMemtype;


impl SpecFrom<SpecMem> for SpecMemInner {
    open spec fn spec_from(m: SpecMem) -> SpecMemInner {
        m.ty
    }
}

impl SpecFrom<SpecMemInner> for SpecMem {
    open spec fn spec_from(m: SpecMemInner) -> SpecMem {
        let ty = m;
        SpecMem { ty }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Mem {
    pub ty: Memtype,
}

impl View for Mem {
    type V = SpecMem;

    open spec fn view(&self) -> Self::V {
        SpecMem {
            ty: self.ty@,
        }
    }
}
pub type MemInner = Memtype;

pub type MemInnerRef<'a> = &'a Memtype;
impl<'a> From<&'a Mem> for MemInnerRef<'a> {
    fn ex_from(m: &'a Mem) -> MemInnerRef<'a> {
        &m.ty
    }
}

impl From<MemInner> for Mem {
    fn ex_from(m: MemInner) -> Mem {
        let ty = m;
        Mem { ty }
    }
}

pub struct MemMapper;
impl View for MemMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for MemMapper {
    type Src = SpecMemInner;
    type Dst = SpecMem;
}
impl SpecIsoProof for MemMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for MemMapper {
    type Src = MemInner;
    type Dst = Mem;
    type RefSrc = MemInnerRef<'a>;
}

pub struct SpecMemCombinator(pub SpecMemCombinatorAlias);

impl SpecCombinator for SpecMemCombinator {
    type Type = SpecMem;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecMemCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecMemCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecMemCombinatorAlias = Mapped<SpecMemtypeCombinator, MemMapper>;

pub struct MemCombinator(pub MemCombinatorAlias);

impl View for MemCombinator {
    type V = SpecMemCombinator;
    open spec fn view(&self) -> Self::V { SpecMemCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for MemCombinator {
    type Type = Mem;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type MemCombinatorAlias = Mapped<MemtypeCombinator, MemMapper>;


pub open spec fn spec_mem() -> SpecMemCombinator {
    SpecMemCombinator(
    Mapped {
        inner: spec_memtype(),
        mapper: MemMapper,
    })
}

                
pub fn mem<'a>() -> (o: MemCombinator)
    ensures o@ == spec_mem(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = MemCombinator(
    Mapped {
        inner: memtype(),
        mapper: MemMapper,
    });
    assert({
        &&& combinator@ == spec_mem()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_mem<'a>(input: &'a [u8]) -> (res: PResult<<MemCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_mem().spec_parse(input@) == Some((n as int, v@)),
        spec_mem().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_mem().spec_parse(input@) is None,
        spec_mem().spec_parse(input@) is None ==> res is Err,
{
    let combinator = mem();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_mem<'a>(v: <MemCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_mem().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_mem().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_mem().spec_serialize(v@))
        },
{
    let combinator = mem();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn mem_len<'a>(v: <MemCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_mem().wf(v@),
        spec_mem().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_mem().spec_serialize(v@).len(),
{
    let combinator = mem();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecMemsecContent {
    pub l: u64,
    pub v: Seq<SpecMem>,
}

pub type SpecMemsecContentInner = (u64, Seq<SpecMem>);


impl SpecFrom<SpecMemsecContent> for SpecMemsecContentInner {
    open spec fn spec_from(m: SpecMemsecContent) -> SpecMemsecContentInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecMemsecContentInner> for SpecMemsecContent {
    open spec fn spec_from(m: SpecMemsecContentInner) -> SpecMemsecContent {
        let (l, v) = m;
        SpecMemsecContent { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct MemsecContent {
    pub l: u64,
    pub v: RepeatResult<Mem>,
}

impl View for MemsecContent {
    type V = SpecMemsecContent;

    open spec fn view(&self) -> Self::V {
        SpecMemsecContent {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type MemsecContentInner = (u64, RepeatResult<Mem>);

pub type MemsecContentInnerRef<'a> = (&'a u64, &'a RepeatResult<Mem>);
impl<'a> From<&'a MemsecContent> for MemsecContentInnerRef<'a> {
    fn ex_from(m: &'a MemsecContent) -> MemsecContentInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl From<MemsecContentInner> for MemsecContent {
    fn ex_from(m: MemsecContentInner) -> MemsecContent {
        let (l, v) = m;
        MemsecContent { l, v }
    }
}

pub struct MemsecContentMapper;
impl View for MemsecContentMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for MemsecContentMapper {
    type Src = SpecMemsecContentInner;
    type Dst = SpecMemsecContent;
}
impl SpecIsoProof for MemsecContentMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for MemsecContentMapper {
    type Src = MemsecContentInner;
    type Dst = MemsecContent;
    type RefSrc = MemsecContentInnerRef<'a>;
}

pub struct SpecMemsecContentCombinator(pub SpecMemsecContentCombinatorAlias);

impl SpecCombinator for SpecMemsecContentCombinator {
    type Type = SpecMemsecContent;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecMemsecContentCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecMemsecContentCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecMemsecContentCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecMemCombinator>>, MemsecContentMapper>;

pub struct MemsecContentCombinator(pub MemsecContentCombinatorAlias);

impl View for MemsecContentCombinator {
    type V = SpecMemsecContentCombinator;
    open spec fn view(&self) -> Self::V { SpecMemsecContentCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for MemsecContentCombinator {
    type Type = MemsecContent;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type MemsecContentCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<MemCombinator>, MemsecContentCont0>, MemsecContentMapper>;


pub open spec fn spec_memsec_content() -> SpecMemsecContentCombinator {
    SpecMemsecContentCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_memsec_content_cont0(deps)),
        mapper: MemsecContentMapper,
    })
}

pub open spec fn spec_memsec_content_cont0(deps: u64) -> RepeatN<SpecMemCombinator> {
    let l = deps;
    RepeatN(spec_mem(), l.spec_into())
}

impl View for MemsecContentCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecMemCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_memsec_content_cont0(deps)
        }
    }
}

                
pub fn memsec_content<'a>() -> (o: MemsecContentCombinator)
    ensures o@ == spec_memsec_content(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = MemsecContentCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, MemsecContentCont0),
        mapper: MemsecContentMapper,
    });
    assert({
        &&& combinator@ == spec_memsec_content()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_memsec_content<'a>(input: &'a [u8]) -> (res: PResult<<MemsecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_memsec_content().spec_parse(input@) == Some((n as int, v@)),
        spec_memsec_content().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_memsec_content().spec_parse(input@) is None,
        spec_memsec_content().spec_parse(input@) is None ==> res is Err,
{
    let combinator = memsec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_memsec_content<'a>(v: <MemsecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_memsec_content().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_memsec_content().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_memsec_content().spec_serialize(v@))
        },
{
    let combinator = memsec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn memsec_content_len<'a>(v: <MemsecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_memsec_content().wf(v@),
        spec_memsec_content().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_memsec_content().spec_serialize(v@).len(),
{
    let combinator = memsec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct MemsecContentCont0;
type MemsecContentCont0Type<'a, 'b> = &'b u64;
type MemsecContentCont0SType<'a, 'x> = &'x u64;
type MemsecContentCont0Input<'a, 'b, 'x> = POrSType<MemsecContentCont0Type<'a, 'b>, MemsecContentCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<MemsecContentCont0Input<'a, 'b, 'x>> for MemsecContentCont0 {
    type Output = RepeatN<MemCombinator>;

    open spec fn requires(&self, deps: MemsecContentCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: MemsecContentCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_memsec_content_cont0(deps@)
    }

    fn apply(&self, deps: MemsecContentCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(mem(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(mem(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecMemsec {
    pub size: u64,
    pub cont: SpecMemsecContent,
}

pub type SpecMemsecInner = (u64, SpecMemsecContent);


impl SpecFrom<SpecMemsec> for SpecMemsecInner {
    open spec fn spec_from(m: SpecMemsec) -> SpecMemsecInner {
        (m.size, m.cont)
    }
}

impl SpecFrom<SpecMemsecInner> for SpecMemsec {
    open spec fn spec_from(m: SpecMemsecInner) -> SpecMemsec {
        let (size, cont) = m;
        SpecMemsec { size, cont }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Memsec {
    pub size: u64,
    pub cont: MemsecContent,
}

impl View for Memsec {
    type V = SpecMemsec;

    open spec fn view(&self) -> Self::V {
        SpecMemsec {
            size: self.size@,
            cont: self.cont@,
        }
    }
}
pub type MemsecInner = (u64, MemsecContent);

pub type MemsecInnerRef<'a> = (&'a u64, &'a MemsecContent);
impl<'a> From<&'a Memsec> for MemsecInnerRef<'a> {
    fn ex_from(m: &'a Memsec) -> MemsecInnerRef<'a> {
        (&m.size, &m.cont)
    }
}

impl From<MemsecInner> for Memsec {
    fn ex_from(m: MemsecInner) -> Memsec {
        let (size, cont) = m;
        Memsec { size, cont }
    }
}

pub struct MemsecMapper;
impl View for MemsecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for MemsecMapper {
    type Src = SpecMemsecInner;
    type Dst = SpecMemsec;
}
impl SpecIsoProof for MemsecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for MemsecMapper {
    type Src = MemsecInner;
    type Dst = Memsec;
    type RefSrc = MemsecInnerRef<'a>;
}

pub struct SpecMemsecCombinator(pub SpecMemsecCombinatorAlias);

impl SpecCombinator for SpecMemsecCombinator {
    type Type = SpecMemsec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecMemsecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecMemsecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecMemsecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, SpecMemsecContentCombinator>>, MemsecMapper>;

pub struct MemsecCombinator(pub MemsecCombinatorAlias);

impl View for MemsecCombinator {
    type V = SpecMemsecCombinator;
    open spec fn view(&self) -> Self::V { SpecMemsecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for MemsecCombinator {
    type Type = Memsec;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type MemsecCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, MemsecContentCombinator>, MemsecCont0>, MemsecMapper>;


pub open spec fn spec_memsec() -> SpecMemsecCombinator {
    SpecMemsecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_memsec_cont0(deps)),
        mapper: MemsecMapper,
    })
}

pub open spec fn spec_memsec_cont0(deps: u64) -> AndThen<bytes::Variable, SpecMemsecContentCombinator> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), spec_memsec_content())
}

impl View for MemsecCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, SpecMemsecContentCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_memsec_cont0(deps)
        }
    }
}

                
pub fn memsec<'a>() -> (o: MemsecCombinator)
    ensures o@ == spec_memsec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = MemsecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, MemsecCont0),
        mapper: MemsecMapper,
    });
    assert({
        &&& combinator@ == spec_memsec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_memsec<'a>(input: &'a [u8]) -> (res: PResult<<MemsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_memsec().spec_parse(input@) == Some((n as int, v@)),
        spec_memsec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_memsec().spec_parse(input@) is None,
        spec_memsec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = memsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_memsec<'a>(v: <MemsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_memsec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_memsec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_memsec().spec_serialize(v@))
        },
{
    let combinator = memsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn memsec_len<'a>(v: <MemsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_memsec().wf(v@),
        spec_memsec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_memsec().spec_serialize(v@).len(),
{
    let combinator = memsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct MemsecCont0;
type MemsecCont0Type<'a, 'b> = &'b u64;
type MemsecCont0SType<'a, 'x> = &'x u64;
type MemsecCont0Input<'a, 'b, 'x> = POrSType<MemsecCont0Type<'a, 'b>, MemsecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<MemsecCont0Input<'a, 'b, 'x>> for MemsecCont0 {
    type Output = AndThen<bytes::Variable, MemsecContentCombinator>;

    open spec fn requires(&self, deps: MemsecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: MemsecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_memsec_cont0(deps@)
    }

    fn apply(&self, deps: MemsecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), memsec_content())
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), memsec_content())
            }
        }
    }
}
                

pub struct SpecByteVec {
    pub l: u64,
    pub v: Seq<u8>,
}

pub type SpecByteVecInner = (u64, Seq<u8>);


impl SpecFrom<SpecByteVec> for SpecByteVecInner {
    open spec fn spec_from(m: SpecByteVec) -> SpecByteVecInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecByteVecInner> for SpecByteVec {
    open spec fn spec_from(m: SpecByteVecInner) -> SpecByteVec {
        let (l, v) = m;
        SpecByteVec { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ByteVec {
    pub l: u64,
    pub v: RepeatResult<u8>,
}

impl View for ByteVec {
    type V = SpecByteVec;

    open spec fn view(&self) -> Self::V {
        SpecByteVec {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type ByteVecInner = (u64, RepeatResult<u8>);

pub type ByteVecInnerRef<'a> = (&'a u64, &'a RepeatResult<u8>);
impl<'a> From<&'a ByteVec> for ByteVecInnerRef<'a> {
    fn ex_from(m: &'a ByteVec) -> ByteVecInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl From<ByteVecInner> for ByteVec {
    fn ex_from(m: ByteVecInner) -> ByteVec {
        let (l, v) = m;
        ByteVec { l, v }
    }
}

pub struct ByteVecMapper;
impl View for ByteVecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ByteVecMapper {
    type Src = SpecByteVecInner;
    type Dst = SpecByteVec;
}
impl SpecIsoProof for ByteVecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ByteVecMapper {
    type Src = ByteVecInner;
    type Dst = ByteVec;
    type RefSrc = ByteVecInnerRef<'a>;
}

pub struct SpecByteVecCombinator(pub SpecByteVecCombinatorAlias);

impl SpecCombinator for SpecByteVecCombinator {
    type Type = SpecByteVec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecByteVecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecByteVecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecByteVecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<U8>>, ByteVecMapper>;

pub struct ByteVecCombinator(pub ByteVecCombinatorAlias);

impl View for ByteVecCombinator {
    type V = SpecByteVecCombinator;
    open spec fn view(&self) -> Self::V { SpecByteVecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ByteVecCombinator {
    type Type = ByteVec;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ByteVecCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<U8>, ByteVecCont0>, ByteVecMapper>;


pub open spec fn spec_byte_vec() -> SpecByteVecCombinator {
    SpecByteVecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_byte_vec_cont0(deps)),
        mapper: ByteVecMapper,
    })
}

pub open spec fn spec_byte_vec_cont0(deps: u64) -> RepeatN<U8> {
    let l = deps;
    RepeatN(U8, l.spec_into())
}

impl View for ByteVecCont0 {
    type V = spec_fn(u64) -> RepeatN<U8>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_byte_vec_cont0(deps)
        }
    }
}

                
pub fn byte_vec<'a>() -> (o: ByteVecCombinator)
    ensures o@ == spec_byte_vec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ByteVecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, ByteVecCont0),
        mapper: ByteVecMapper,
    });
    assert({
        &&& combinator@ == spec_byte_vec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_byte_vec<'a>(input: &'a [u8]) -> (res: PResult<<ByteVecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_byte_vec().spec_parse(input@) == Some((n as int, v@)),
        spec_byte_vec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_byte_vec().spec_parse(input@) is None,
        spec_byte_vec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = byte_vec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_byte_vec<'a>(v: <ByteVecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_byte_vec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_byte_vec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_byte_vec().spec_serialize(v@))
        },
{
    let combinator = byte_vec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn byte_vec_len<'a>(v: <ByteVecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_byte_vec().wf(v@),
        spec_byte_vec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_byte_vec().spec_serialize(v@).len(),
{
    let combinator = byte_vec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct ByteVecCont0;
type ByteVecCont0Type<'a, 'b> = &'b u64;
type ByteVecCont0SType<'a, 'x> = &'x u64;
type ByteVecCont0Input<'a, 'b, 'x> = POrSType<ByteVecCont0Type<'a, 'b>, ByteVecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<ByteVecCont0Input<'a, 'b, 'x>> for ByteVecCont0 {
    type Output = RepeatN<U8>;

    open spec fn requires(&self, deps: ByteVecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: ByteVecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_byte_vec_cont0(deps@)
    }

    fn apply(&self, deps: ByteVecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(U8, l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(U8, l.ex_into())
            }
        }
    }
}
                
pub type SpecName = SpecByteVec;
pub type Name = ByteVec;
pub type NameRef<'a> = &'a ByteVec;


pub struct SpecNameCombinator(pub SpecNameCombinatorAlias);

impl SpecCombinator for SpecNameCombinator {
    type Type = SpecName;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecNameCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecNameCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecNameCombinatorAlias = SpecByteVecCombinator;

pub struct NameCombinator(pub NameCombinatorAlias);

impl View for NameCombinator {
    type V = SpecNameCombinator;
    open spec fn view(&self) -> Self::V { SpecNameCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for NameCombinator {
    type Type = Name;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type NameCombinatorAlias = ByteVecCombinator;


pub open spec fn spec_name() -> SpecNameCombinator {
    SpecNameCombinator(spec_byte_vec())
}

                
pub fn name<'a>() -> (o: NameCombinator)
    ensures o@ == spec_name(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = NameCombinator(byte_vec());
    assert({
        &&& combinator@ == spec_name()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_name<'a>(input: &'a [u8]) -> (res: PResult<<NameCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_name().spec_parse(input@) == Some((n as int, v@)),
        spec_name().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_name().spec_parse(input@) is None,
        spec_name().spec_parse(input@) is None ==> res is Err,
{
    let combinator = name();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_name<'a>(v: <NameCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_name().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_name().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_name().spec_serialize(v@))
        },
{
    let combinator = name();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn name_len<'a>(v: <NameCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_name().wf(v@),
        spec_name().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_name().spec_serialize(v@).len(),
{
    let combinator = name();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecEmpty = Seq<u8>;
pub type Empty<'a> = &'a [u8];
pub type EmptyRef<'a> = &'a &'a [u8];


pub struct SpecEmptyCombinator(pub SpecEmptyCombinatorAlias);

impl SpecCombinator for SpecEmptyCombinator {
    type Type = SpecEmpty;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecEmptyCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecEmptyCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecEmptyCombinatorAlias = bytes::Fixed<0>;

pub struct EmptyCombinator(pub EmptyCombinatorAlias);

impl View for EmptyCombinator {
    type V = SpecEmptyCombinator;
    open spec fn view(&self) -> Self::V { SpecEmptyCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for EmptyCombinator {
    type Type = Empty<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type EmptyCombinatorAlias = bytes::Fixed<0>;


pub open spec fn spec_empty() -> SpecEmptyCombinator {
    SpecEmptyCombinator(bytes::Fixed::<0>)
}

                
pub fn empty<'a>() -> (o: EmptyCombinator)
    ensures o@ == spec_empty(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = EmptyCombinator(bytes::Fixed::<0>);
    assert({
        &&& combinator@ == spec_empty()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_empty<'a>(input: &'a [u8]) -> (res: PResult<<EmptyCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_empty().spec_parse(input@) == Some((n as int, v@)),
        spec_empty().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_empty().spec_parse(input@) is None,
        spec_empty().spec_parse(input@) is None ==> res is Err,
{
    let combinator = empty();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_empty<'a>(v: <EmptyCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_empty().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_empty().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_empty().spec_serialize(v@))
        },
{
    let combinator = empty();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn empty_len<'a>(v: <EmptyCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_empty().wf(v@),
        spec_empty().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_empty().spec_serialize(v@).len(),
{
    let combinator = empty();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecSelectT {
    pub l: u64,
    pub v: Seq<SpecValtype>,
}

pub type SpecSelectTInner = (u64, Seq<SpecValtype>);


impl SpecFrom<SpecSelectT> for SpecSelectTInner {
    open spec fn spec_from(m: SpecSelectT) -> SpecSelectTInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecSelectTInner> for SpecSelectT {
    open spec fn spec_from(m: SpecSelectTInner) -> SpecSelectT {
        let (l, v) = m;
        SpecSelectT { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct SelectT {
    pub l: u64,
    pub v: RepeatResult<Valtype>,
}

impl View for SelectT {
    type V = SpecSelectT;

    open spec fn view(&self) -> Self::V {
        SpecSelectT {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type SelectTInner = (u64, RepeatResult<Valtype>);

pub type SelectTInnerRef<'a> = (&'a u64, &'a RepeatResult<Valtype>);
impl<'a> From<&'a SelectT> for SelectTInnerRef<'a> {
    fn ex_from(m: &'a SelectT) -> SelectTInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl From<SelectTInner> for SelectT {
    fn ex_from(m: SelectTInner) -> SelectT {
        let (l, v) = m;
        SelectT { l, v }
    }
}

pub struct SelectTMapper;
impl View for SelectTMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for SelectTMapper {
    type Src = SpecSelectTInner;
    type Dst = SpecSelectT;
}
impl SpecIsoProof for SelectTMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for SelectTMapper {
    type Src = SelectTInner;
    type Dst = SelectT;
    type RefSrc = SelectTInnerRef<'a>;
}

pub struct SpecSelectTCombinator(pub SpecSelectTCombinatorAlias);

impl SpecCombinator for SpecSelectTCombinator {
    type Type = SpecSelectT;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecSelectTCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecSelectTCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecSelectTCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecValtypeCombinator>>, SelectTMapper>;

pub struct SelectTCombinator(pub SelectTCombinatorAlias);

impl View for SelectTCombinator {
    type V = SpecSelectTCombinator;
    open spec fn view(&self) -> Self::V { SpecSelectTCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for SelectTCombinator {
    type Type = SelectT;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type SelectTCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<ValtypeCombinator>, SelectTCont0>, SelectTMapper>;


pub open spec fn spec_select_t() -> SpecSelectTCombinator {
    SpecSelectTCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_select_t_cont0(deps)),
        mapper: SelectTMapper,
    })
}

pub open spec fn spec_select_t_cont0(deps: u64) -> RepeatN<SpecValtypeCombinator> {
    let l = deps;
    RepeatN(spec_valtype(), l.spec_into())
}

impl View for SelectTCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecValtypeCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_select_t_cont0(deps)
        }
    }
}

                
pub fn select_t<'a>() -> (o: SelectTCombinator)
    ensures o@ == spec_select_t(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = SelectTCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, SelectTCont0),
        mapper: SelectTMapper,
    });
    assert({
        &&& combinator@ == spec_select_t()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_select_t<'a>(input: &'a [u8]) -> (res: PResult<<SelectTCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_select_t().spec_parse(input@) == Some((n as int, v@)),
        spec_select_t().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_select_t().spec_parse(input@) is None,
        spec_select_t().spec_parse(input@) is None ==> res is Err,
{
    let combinator = select_t();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_select_t<'a>(v: <SelectTCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_select_t().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_select_t().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_select_t().spec_serialize(v@))
        },
{
    let combinator = select_t();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn select_t_len<'a>(v: <SelectTCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_select_t().wf(v@),
        spec_select_t().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_select_t().spec_serialize(v@).len(),
{
    let combinator = select_t();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct SelectTCont0;
type SelectTCont0Type<'a, 'b> = &'b u64;
type SelectTCont0SType<'a, 'x> = &'x u64;
type SelectTCont0Input<'a, 'b, 'x> = POrSType<SelectTCont0Type<'a, 'b>, SelectTCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<SelectTCont0Input<'a, 'b, 'x>> for SelectTCont0 {
    type Output = RepeatN<ValtypeCombinator>;

    open spec fn requires(&self, deps: SelectTCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: SelectTCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_select_t_cont0(deps@)
    }

    fn apply(&self, deps: SelectTCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(valtype(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(valtype(), l.ex_into())
            }
        }
    }
}
                

pub enum SpecInstrParametric {
    Drop(SpecEmpty),
    Select(SpecEmpty),
    SelectT(SpecSelectT),
}

pub type SpecInstrParametricInner = Either<SpecEmpty, Either<SpecEmpty, SpecSelectT>>;

impl SpecFrom<SpecInstrParametric> for SpecInstrParametricInner {
    open spec fn spec_from(m: SpecInstrParametric) -> SpecInstrParametricInner {
        match m {
            SpecInstrParametric::Drop(m) => Either::Left(m),
            SpecInstrParametric::Select(m) => Either::Right(Either::Left(m)),
            SpecInstrParametric::SelectT(m) => Either::Right(Either::Right(m)),
        }
    }

}

                
impl SpecFrom<SpecInstrParametricInner> for SpecInstrParametric {
    open spec fn spec_from(m: SpecInstrParametricInner) -> SpecInstrParametric {
        match m {
            Either::Left(m) => SpecInstrParametric::Drop(m),
            Either::Right(Either::Left(m)) => SpecInstrParametric::Select(m),
            Either::Right(Either::Right(m)) => SpecInstrParametric::SelectT(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InstrParametric<'a> {
    Drop(Empty<'a>),
    Select(Empty<'a>),
    SelectT(SelectT),
}

pub type InstrParametricInner<'a> = Either<Empty<'a>, Either<Empty<'a>, SelectT>>;

pub type InstrParametricInnerRef<'a> = Either<&'a Empty<'a>, Either<&'a Empty<'a>, &'a SelectT>>;


impl<'a> View for InstrParametric<'a> {
    type V = SpecInstrParametric;
    open spec fn view(&self) -> Self::V {
        match self {
            InstrParametric::Drop(m) => SpecInstrParametric::Drop(m@),
            InstrParametric::Select(m) => SpecInstrParametric::Select(m@),
            InstrParametric::SelectT(m) => SpecInstrParametric::SelectT(m@),
        }
    }
}


impl<'a> From<&'a InstrParametric<'a>> for InstrParametricInnerRef<'a> {
    fn ex_from(m: &'a InstrParametric<'a>) -> InstrParametricInnerRef<'a> {
        match m {
            InstrParametric::Drop(m) => Either::Left(m),
            InstrParametric::Select(m) => Either::Right(Either::Left(m)),
            InstrParametric::SelectT(m) => Either::Right(Either::Right(m)),
        }
    }

}

impl<'a> From<InstrParametricInner<'a>> for InstrParametric<'a> {
    fn ex_from(m: InstrParametricInner<'a>) -> InstrParametric<'a> {
        match m {
            Either::Left(m) => InstrParametric::Drop(m),
            Either::Right(Either::Left(m)) => InstrParametric::Select(m),
            Either::Right(Either::Right(m)) => InstrParametric::SelectT(m),
        }
    }
    
}


pub struct InstrParametricMapper;
impl View for InstrParametricMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrParametricMapper {
    type Src = SpecInstrParametricInner;
    type Dst = SpecInstrParametric;
}
impl SpecIsoProof for InstrParametricMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrParametricMapper {
    type Src = InstrParametricInner<'a>;
    type Dst = InstrParametric<'a>;
    type RefSrc = InstrParametricInnerRef<'a>;
}

type SpecInstrParametricCombinatorAlias1 = Choice<Cond<SpecEmptyCombinator>, Cond<SpecSelectTCombinator>>;
type SpecInstrParametricCombinatorAlias2 = Choice<Cond<SpecEmptyCombinator>, SpecInstrParametricCombinatorAlias1>;
pub struct SpecInstrParametricCombinator(pub SpecInstrParametricCombinatorAlias);

impl SpecCombinator for SpecInstrParametricCombinator {
    type Type = SpecInstrParametric;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrParametricCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrParametricCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrParametricCombinatorAlias = Mapped<SpecInstrParametricCombinatorAlias2, InstrParametricMapper>;
type InstrParametricCombinatorAlias1 = Choice<Cond<EmptyCombinator>, Cond<SelectTCombinator>>;
type InstrParametricCombinatorAlias2 = Choice<Cond<EmptyCombinator>, InstrParametricCombinator1>;
pub struct InstrParametricCombinator1(pub InstrParametricCombinatorAlias1);
impl View for InstrParametricCombinator1 {
    type V = SpecInstrParametricCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrParametricCombinator1, InstrParametricCombinatorAlias1);

pub struct InstrParametricCombinator2(pub InstrParametricCombinatorAlias2);
impl View for InstrParametricCombinator2 {
    type V = SpecInstrParametricCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrParametricCombinator2, InstrParametricCombinatorAlias2);

pub struct InstrParametricCombinator(pub InstrParametricCombinatorAlias);

impl View for InstrParametricCombinator {
    type V = SpecInstrParametricCombinator;
    open spec fn view(&self) -> Self::V { SpecInstrParametricCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrParametricCombinator {
    type Type = InstrParametric<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrParametricCombinatorAlias = Mapped<InstrParametricCombinator2, InstrParametricMapper>;


pub open spec fn spec_instr_parametric(opcode: u8) -> SpecInstrParametricCombinator {
    SpecInstrParametricCombinator(Mapped { inner: Choice(Cond { cond: opcode == InstrBytecode::SPEC_Drop, inner: spec_empty() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_Select, inner: spec_empty() }, Cond { cond: opcode == InstrBytecode::SPEC_SelectT, inner: spec_select_t() })), mapper: InstrParametricMapper })
}

pub fn instr_parametric<'a>(opcode: u8) -> (o: InstrParametricCombinator)
    ensures o@ == spec_instr_parametric(opcode@),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrParametricCombinator(Mapped { inner: InstrParametricCombinator2(Choice::new(Cond { cond: opcode == InstrBytecode::Drop, inner: empty() }, InstrParametricCombinator1(Choice::new(Cond { cond: opcode == InstrBytecode::Select, inner: empty() }, Cond { cond: opcode == InstrBytecode::SelectT, inner: select_t() })))), mapper: InstrParametricMapper });
    assert({
        &&& combinator@ == spec_instr_parametric(opcode@)
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_parametric<'a>(input: &'a [u8], opcode: u8) -> (res: PResult<<InstrParametricCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_parametric(opcode@).spec_parse(input@) == Some((n as int, v@)),
        spec_instr_parametric(opcode@).spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_parametric(opcode@).spec_parse(input@) is None,
        spec_instr_parametric(opcode@).spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_parametric( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_parametric<'a>(v: <InstrParametricCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize, opcode: u8) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_parametric(opcode@).wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_parametric(opcode@).spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_parametric(opcode@).spec_serialize(v@))
        },
{
    let combinator = instr_parametric( opcode );
    combinator.serialize(v, data, pos)
}

pub fn instr_parametric_len<'a>(v: <InstrParametricCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, opcode: u8) -> (serialize_len: usize)
    requires
        spec_instr_parametric(opcode@).wf(v@),
        spec_instr_parametric(opcode@).spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_parametric(opcode@).spec_serialize(v@).len(),
{
    let combinator = instr_parametric( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}


pub struct SpecByteZero {
    pub zero: u8,
}

pub type SpecByteZeroInner = u8;


impl SpecFrom<SpecByteZero> for SpecByteZeroInner {
    open spec fn spec_from(m: SpecByteZero) -> SpecByteZeroInner {
        m.zero
    }
}

impl SpecFrom<SpecByteZeroInner> for SpecByteZero {
    open spec fn spec_from(m: SpecByteZeroInner) -> SpecByteZero {
        let zero = m;
        SpecByteZero { zero }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ByteZero {
    pub zero: u8,
}

impl View for ByteZero {
    type V = SpecByteZero;

    open spec fn view(&self) -> Self::V {
        SpecByteZero {
            zero: self.zero@,
        }
    }
}
pub type ByteZeroInner = u8;

pub type ByteZeroInnerRef<'a> = &'a u8;
impl<'a> From<&'a ByteZero> for ByteZeroInnerRef<'a> {
    fn ex_from(m: &'a ByteZero) -> ByteZeroInnerRef<'a> {
        &m.zero
    }
}

impl From<ByteZeroInner> for ByteZero {
    fn ex_from(m: ByteZeroInner) -> ByteZero {
        let zero = m;
        ByteZero { zero }
    }
}

pub struct ByteZeroMapper;
impl View for ByteZeroMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ByteZeroMapper {
    type Src = SpecByteZeroInner;
    type Dst = SpecByteZero;
}
impl SpecIsoProof for ByteZeroMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ByteZeroMapper {
    type Src = ByteZeroInner;
    type Dst = ByteZero;
    type RefSrc = ByteZeroInnerRef<'a>;
}
pub const BYTEZEROZERO_CONST: u8 = 0;

pub struct SpecByteZeroCombinator(pub SpecByteZeroCombinatorAlias);

impl SpecCombinator for SpecByteZeroCombinator {
    type Type = SpecByteZero;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecByteZeroCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecByteZeroCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecByteZeroCombinatorAlias = Mapped<Refined<U8, TagPred<u8>>, ByteZeroMapper>;

pub struct ByteZeroCombinator(pub ByteZeroCombinatorAlias);

impl View for ByteZeroCombinator {
    type V = SpecByteZeroCombinator;
    open spec fn view(&self) -> Self::V { SpecByteZeroCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ByteZeroCombinator {
    type Type = ByteZero;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ByteZeroCombinatorAlias = Mapped<Refined<U8, TagPred<u8>>, ByteZeroMapper>;


pub open spec fn spec_byte_zero() -> SpecByteZeroCombinator {
    SpecByteZeroCombinator(
    Mapped {
        inner: Refined { inner: U8, predicate: TagPred(BYTEZEROZERO_CONST) },
        mapper: ByteZeroMapper,
    })
}

                
pub fn byte_zero<'a>() -> (o: ByteZeroCombinator)
    ensures o@ == spec_byte_zero(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ByteZeroCombinator(
    Mapped {
        inner: Refined { inner: U8, predicate: TagPred(BYTEZEROZERO_CONST) },
        mapper: ByteZeroMapper,
    });
    assert({
        &&& combinator@ == spec_byte_zero()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_byte_zero<'a>(input: &'a [u8]) -> (res: PResult<<ByteZeroCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_byte_zero().spec_parse(input@) == Some((n as int, v@)),
        spec_byte_zero().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_byte_zero().spec_parse(input@) is None,
        spec_byte_zero().spec_parse(input@) is None ==> res is Err,
{
    let combinator = byte_zero();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_byte_zero<'a>(v: <ByteZeroCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_byte_zero().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_byte_zero().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_byte_zero().spec_serialize(v@))
        },
{
    let combinator = byte_zero();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn byte_zero_len<'a>(v: <ByteZeroCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_byte_zero().wf(v@),
        spec_byte_zero().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_byte_zero().spec_serialize(v@).len(),
{
    let combinator = byte_zero();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub spec const SPEC_MutT_Const: u8 = 0;
pub spec const SPEC_MutT_Var: u8 = 1;
pub exec static EXEC_MutT_Const: u8 ensures EXEC_MutT_Const == SPEC_MutT_Const { 0 }
pub exec static EXEC_MutT_Var: u8 ensures EXEC_MutT_Var == SPEC_MutT_Var { 1 }

#[derive(Structural, Debug, Copy, Clone, PartialEq, Eq)]
pub enum MutT {
    Const = 0,
Var = 1
}
pub type SpecMutT = MutT;

pub type MutTInner = u8;

pub type MutTInnerRef<'a> = &'a u8;

impl View for MutT {
    type V = Self;

    open spec fn view(&self) -> Self::V {
        *self
    }
}

impl SpecTryFrom<MutTInner> for MutT {
    type Error = ();

    open spec fn spec_try_from(v: MutTInner) -> Result<MutT, ()> {
        match v {
            0u8 => Ok(MutT::Const),
            1u8 => Ok(MutT::Var),
            _ => Err(()),
        }
    }
}

impl SpecTryFrom<MutT> for MutTInner {
    type Error = ();

    open spec fn spec_try_from(v: MutT) -> Result<MutTInner, ()> {
        match v {
            MutT::Const => Ok(SPEC_MutT_Const),
            MutT::Var => Ok(SPEC_MutT_Var),
        }
    }
}

impl TryFrom<MutTInner> for MutT {
    type Error = ();

    fn ex_try_from(v: MutTInner) -> Result<MutT, ()> {
        match v {
            0u8 => Ok(MutT::Const),
            1u8 => Ok(MutT::Var),
            _ => Err(()),
        }
    }
}

impl<'a> TryFrom<&'a MutT> for MutTInnerRef<'a> {
    type Error = ();

    fn ex_try_from(v: &'a MutT) -> Result<MutTInnerRef<'a>, ()> {
        match v {
            MutT::Const => Ok(&EXEC_MutT_Const),
            MutT::Var => Ok(&EXEC_MutT_Var),
        }
    }
}

pub struct MutTMapper;

impl View for MutTMapper {
    type V = Self;

    open spec fn view(&self) -> Self::V {
        *self
    }
}

impl SpecPartialIso for MutTMapper {
    type Src = MutTInner;
    type Dst = MutT;
}

impl SpecPartialIsoProof for MutTMapper {
    proof fn spec_iso(s: Self::Src) { 
        assert(
            Self::spec_apply(s) matches Ok(v) ==> {
            &&& Self::spec_rev_apply(v) is Ok
            &&& Self::spec_rev_apply(v) matches Ok(s_) && s == s_
        });
    }

    proof fn spec_iso_rev(s: Self::Dst) { 
        assert(
            Self::spec_rev_apply(s) matches Ok(v) ==> {
            &&& Self::spec_apply(v) is Ok
            &&& Self::spec_apply(v) matches Ok(s_) && s == s_
        });
    }
}

impl<'a> PartialIso<'a> for MutTMapper {
    type Src = MutTInner;
    type Dst = MutT;
    type RefSrc = MutTInnerRef<'a>;
}


pub struct SpecMutTCombinator(pub SpecMutTCombinatorAlias);

impl SpecCombinator for SpecMutTCombinator {
    type Type = SpecMutT;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecMutTCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecMutTCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecMutTCombinatorAlias = TryMap<U8, MutTMapper>;

pub struct MutTCombinator(pub MutTCombinatorAlias);

impl View for MutTCombinator {
    type V = SpecMutTCombinator;
    open spec fn view(&self) -> Self::V { SpecMutTCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for MutTCombinator {
    type Type = MutT;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type MutTCombinatorAlias = TryMap<U8, MutTMapper>;


pub open spec fn spec_mut_t() -> SpecMutTCombinator {
    SpecMutTCombinator(TryMap { inner: U8, mapper: MutTMapper })
}

                
pub fn mut_t<'a>() -> (o: MutTCombinator)
    ensures o@ == spec_mut_t(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = MutTCombinator(TryMap { inner: U8, mapper: MutTMapper });
    assert({
        &&& combinator@ == spec_mut_t()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_mut_t<'a>(input: &'a [u8]) -> (res: PResult<<MutTCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_mut_t().spec_parse(input@) == Some((n as int, v@)),
        spec_mut_t().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_mut_t().spec_parse(input@) is None,
        spec_mut_t().spec_parse(input@) is None ==> res is Err,
{
    let combinator = mut_t();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_mut_t<'a>(v: <MutTCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_mut_t().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_mut_t().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_mut_t().spec_serialize(v@))
        },
{
    let combinator = mut_t();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn mut_t_len<'a>(v: <MutTCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_mut_t().wf(v@),
        spec_mut_t().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_mut_t().spec_serialize(v@).len(),
{
    let combinator = mut_t();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecGlobaltype {
    pub t: SpecValtype,
    pub m: SpecMutT,
}

pub type SpecGlobaltypeInner = (SpecValtype, SpecMutT);


impl SpecFrom<SpecGlobaltype> for SpecGlobaltypeInner {
    open spec fn spec_from(m: SpecGlobaltype) -> SpecGlobaltypeInner {
        (m.t, m.m)
    }
}

impl SpecFrom<SpecGlobaltypeInner> for SpecGlobaltype {
    open spec fn spec_from(m: SpecGlobaltypeInner) -> SpecGlobaltype {
        let (t, m) = m;
        SpecGlobaltype { t, m }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Globaltype {
    pub t: Valtype,
    pub m: MutT,
}

impl View for Globaltype {
    type V = SpecGlobaltype;

    open spec fn view(&self) -> Self::V {
        SpecGlobaltype {
            t: self.t@,
            m: self.m@,
        }
    }
}
pub type GlobaltypeInner = (Valtype, MutT);

pub type GlobaltypeInnerRef<'a> = (&'a Valtype, &'a MutT);
impl<'a> From<&'a Globaltype> for GlobaltypeInnerRef<'a> {
    fn ex_from(m: &'a Globaltype) -> GlobaltypeInnerRef<'a> {
        (&m.t, &m.m)
    }
}

impl From<GlobaltypeInner> for Globaltype {
    fn ex_from(m: GlobaltypeInner) -> Globaltype {
        let (t, m) = m;
        Globaltype { t, m }
    }
}

pub struct GlobaltypeMapper;
impl View for GlobaltypeMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for GlobaltypeMapper {
    type Src = SpecGlobaltypeInner;
    type Dst = SpecGlobaltype;
}
impl SpecIsoProof for GlobaltypeMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for GlobaltypeMapper {
    type Src = GlobaltypeInner;
    type Dst = Globaltype;
    type RefSrc = GlobaltypeInnerRef<'a>;
}
type SpecGlobaltypeCombinatorAlias1 = (SpecValtypeCombinator, SpecMutTCombinator);
pub struct SpecGlobaltypeCombinator(pub SpecGlobaltypeCombinatorAlias);

impl SpecCombinator for SpecGlobaltypeCombinator {
    type Type = SpecGlobaltype;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecGlobaltypeCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecGlobaltypeCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecGlobaltypeCombinatorAlias = Mapped<SpecGlobaltypeCombinatorAlias1, GlobaltypeMapper>;
type GlobaltypeCombinatorAlias1 = (ValtypeCombinator, MutTCombinator);
pub struct GlobaltypeCombinator1(pub GlobaltypeCombinatorAlias1);
impl View for GlobaltypeCombinator1 {
    type V = SpecGlobaltypeCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(GlobaltypeCombinator1, GlobaltypeCombinatorAlias1);

pub struct GlobaltypeCombinator(pub GlobaltypeCombinatorAlias);

impl View for GlobaltypeCombinator {
    type V = SpecGlobaltypeCombinator;
    open spec fn view(&self) -> Self::V { SpecGlobaltypeCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for GlobaltypeCombinator {
    type Type = Globaltype;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type GlobaltypeCombinatorAlias = Mapped<GlobaltypeCombinator1, GlobaltypeMapper>;


pub open spec fn spec_globaltype() -> SpecGlobaltypeCombinator {
    SpecGlobaltypeCombinator(
    Mapped {
        inner: (spec_valtype(), spec_mut_t()),
        mapper: GlobaltypeMapper,
    })
}

                
pub fn globaltype<'a>() -> (o: GlobaltypeCombinator)
    ensures o@ == spec_globaltype(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = GlobaltypeCombinator(
    Mapped {
        inner: GlobaltypeCombinator1((valtype(), mut_t())),
        mapper: GlobaltypeMapper,
    });
    assert({
        &&& combinator@ == spec_globaltype()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_globaltype<'a>(input: &'a [u8]) -> (res: PResult<<GlobaltypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_globaltype().spec_parse(input@) == Some((n as int, v@)),
        spec_globaltype().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_globaltype().spec_parse(input@) is None,
        spec_globaltype().spec_parse(input@) is None ==> res is Err,
{
    let combinator = globaltype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_globaltype<'a>(v: <GlobaltypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_globaltype().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_globaltype().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_globaltype().spec_serialize(v@))
        },
{
    let combinator = globaltype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn globaltype_len<'a>(v: <GlobaltypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_globaltype().wf(v@),
        spec_globaltype().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_globaltype().spec_serialize(v@).len(),
{
    let combinator = globaltype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub mod InstrBytecode {
    use super::*;
    pub spec const SPEC_Unreachable: u8 = 0;
    pub spec const SPEC_Nop: u8 = 1;
    pub spec const SPEC_Block: u8 = 2;
    pub spec const SPEC_Loop: u8 = 3;
    pub spec const SPEC_If: u8 = 4;
    pub spec const SPEC_Else: u8 = 5;
    pub spec const SPEC_End: u8 = 11;
    pub spec const SPEC_Br: u8 = 12;
    pub spec const SPEC_BrIf: u8 = 13;
    pub spec const SPEC_BrTable: u8 = 14;
    pub spec const SPEC_Ret: u8 = 15;
    pub spec const SPEC_Call: u8 = 16;
    pub spec const SPEC_CallIndirect: u8 = 17;
    pub spec const SPEC_RefNull: u8 = 208;
    pub spec const SPEC_RefIsNull: u8 = 209;
    pub spec const SPEC_RefFunc: u8 = 210;
    pub spec const SPEC_Drop: u8 = 26;
    pub spec const SPEC_Select: u8 = 27;
    pub spec const SPEC_SelectT: u8 = 28;
    pub spec const SPEC_LocalGet: u8 = 32;
    pub spec const SPEC_LocalSet: u8 = 33;
    pub spec const SPEC_LocalTee: u8 = 34;
    pub spec const SPEC_GlobalGet: u8 = 35;
    pub spec const SPEC_GlobalSet: u8 = 36;
    pub spec const SPEC_TableGet: u8 = 37;
    pub spec const SPEC_TableSet: u8 = 38;
    pub spec const SPEC_OpcodeFC: u8 = 252;
    pub spec const SPEC_I32Load: u8 = 40;
    pub spec const SPEC_I64Load: u8 = 41;
    pub spec const SPEC_F32Load: u8 = 42;
    pub spec const SPEC_F64Load: u8 = 43;
    pub spec const SPEC_I32Load8S: u8 = 44;
    pub spec const SPEC_I32Load8U: u8 = 45;
    pub spec const SPEC_I32Load16S: u8 = 46;
    pub spec const SPEC_I32Load16U: u8 = 47;
    pub spec const SPEC_I64Load8S: u8 = 48;
    pub spec const SPEC_I64Load8U: u8 = 49;
    pub spec const SPEC_I64Load16S: u8 = 50;
    pub spec const SPEC_I64Load16U: u8 = 51;
    pub spec const SPEC_I64Load32S: u8 = 52;
    pub spec const SPEC_I64Load32U: u8 = 53;
    pub spec const SPEC_I32Store: u8 = 54;
    pub spec const SPEC_I64Store: u8 = 55;
    pub spec const SPEC_F32Store: u8 = 56;
    pub spec const SPEC_F64Store: u8 = 57;
    pub spec const SPEC_I32Store8: u8 = 58;
    pub spec const SPEC_I32Store16: u8 = 59;
    pub spec const SPEC_I64Store8: u8 = 60;
    pub spec const SPEC_I64Store16: u8 = 61;
    pub spec const SPEC_I64Store32: u8 = 62;
    pub spec const SPEC_MemorySize: u8 = 63;
    pub spec const SPEC_MemoryGrow: u8 = 64;
    pub spec const SPEC_I32Const: u8 = 65;
    pub spec const SPEC_I64Const: u8 = 66;
    pub spec const SPEC_F32Const: u8 = 67;
    pub spec const SPEC_F64Const: u8 = 68;
    pub spec const SPEC_I32Eqz: u8 = 69;
    pub spec const SPEC_I32Eq: u8 = 70;
    pub spec const SPEC_I32Ne: u8 = 71;
    pub spec const SPEC_I32LtS: u8 = 72;
    pub spec const SPEC_I32LtU: u8 = 73;
    pub spec const SPEC_I32GtS: u8 = 74;
    pub spec const SPEC_I32GtU: u8 = 75;
    pub spec const SPEC_I32LeS: u8 = 76;
    pub spec const SPEC_I32LeU: u8 = 77;
    pub spec const SPEC_I32GeS: u8 = 78;
    pub spec const SPEC_I32GeU: u8 = 79;
    pub spec const SPEC_I64Eqz: u8 = 80;
    pub spec const SPEC_I64Eq: u8 = 81;
    pub spec const SPEC_I64Ne: u8 = 82;
    pub spec const SPEC_I64LtS: u8 = 83;
    pub spec const SPEC_I64LtU: u8 = 84;
    pub spec const SPEC_I64GtS: u8 = 85;
    pub spec const SPEC_I64GtU: u8 = 86;
    pub spec const SPEC_I64LeS: u8 = 87;
    pub spec const SPEC_I64LeU: u8 = 88;
    pub spec const SPEC_I64GeS: u8 = 89;
    pub spec const SPEC_I64GeU: u8 = 90;
    pub spec const SPEC_F32Eq: u8 = 91;
    pub spec const SPEC_F32Ne: u8 = 92;
    pub spec const SPEC_F32Lt: u8 = 93;
    pub spec const SPEC_F32Gt: u8 = 94;
    pub spec const SPEC_F32Le: u8 = 95;
    pub spec const SPEC_F32Ge: u8 = 96;
    pub spec const SPEC_F64Eq: u8 = 97;
    pub spec const SPEC_F64Ne: u8 = 98;
    pub spec const SPEC_F64Lt: u8 = 99;
    pub spec const SPEC_F64Gt: u8 = 100;
    pub spec const SPEC_F64Le: u8 = 101;
    pub spec const SPEC_F64Ge: u8 = 102;
    pub spec const SPEC_I32Clz: u8 = 103;
    pub spec const SPEC_I32Ctz: u8 = 104;
    pub spec const SPEC_I32Popcnt: u8 = 105;
    pub spec const SPEC_I32Add: u8 = 106;
    pub spec const SPEC_I32Sub: u8 = 107;
    pub spec const SPEC_I32Mul: u8 = 108;
    pub spec const SPEC_I32DivS: u8 = 109;
    pub spec const SPEC_I32DivU: u8 = 110;
    pub spec const SPEC_I32RemS: u8 = 111;
    pub spec const SPEC_I32RemU: u8 = 112;
    pub spec const SPEC_I32And: u8 = 113;
    pub spec const SPEC_I32Or: u8 = 114;
    pub spec const SPEC_I32Xor: u8 = 115;
    pub spec const SPEC_I32Shl: u8 = 116;
    pub spec const SPEC_I32ShrS: u8 = 117;
    pub spec const SPEC_I32ShrU: u8 = 118;
    pub spec const SPEC_I32Rotl: u8 = 119;
    pub spec const SPEC_I32Rotr: u8 = 120;
    pub spec const SPEC_I64Clz: u8 = 121;
    pub spec const SPEC_I64Ctz: u8 = 122;
    pub spec const SPEC_I64Popcnt: u8 = 123;
    pub spec const SPEC_I64Add: u8 = 124;
    pub spec const SPEC_I64Sub: u8 = 125;
    pub spec const SPEC_I64Mul: u8 = 126;
    pub spec const SPEC_I64DivS: u8 = 127;
    pub spec const SPEC_I64DivU: u8 = 128;
    pub spec const SPEC_I64RemS: u8 = 129;
    pub spec const SPEC_I64RemU: u8 = 130;
    pub spec const SPEC_I64And: u8 = 131;
    pub spec const SPEC_I64Or: u8 = 132;
    pub spec const SPEC_I64Xor: u8 = 133;
    pub spec const SPEC_I64Shl: u8 = 134;
    pub spec const SPEC_I64ShrS: u8 = 135;
    pub spec const SPEC_I64ShrU: u8 = 136;
    pub spec const SPEC_I64Rotl: u8 = 137;
    pub spec const SPEC_I64Rotr: u8 = 138;
    pub spec const SPEC_F32Abs: u8 = 139;
    pub spec const SPEC_F32Neg: u8 = 140;
    pub spec const SPEC_F32Ceil: u8 = 141;
    pub spec const SPEC_F32Floor: u8 = 142;
    pub spec const SPEC_F32Trunc: u8 = 143;
    pub spec const SPEC_F32Nearest: u8 = 144;
    pub spec const SPEC_F32Sqrt: u8 = 145;
    pub spec const SPEC_F32Add: u8 = 146;
    pub spec const SPEC_F32Sub: u8 = 147;
    pub spec const SPEC_F32Mul: u8 = 148;
    pub spec const SPEC_F32Div: u8 = 149;
    pub spec const SPEC_F32Min: u8 = 150;
    pub spec const SPEC_F32Max: u8 = 151;
    pub spec const SPEC_F32Copysign: u8 = 152;
    pub spec const SPEC_F64Abs: u8 = 153;
    pub spec const SPEC_F64Neg: u8 = 154;
    pub spec const SPEC_F64Ceil: u8 = 155;
    pub spec const SPEC_F64Floor: u8 = 156;
    pub spec const SPEC_F64Trunc: u8 = 157;
    pub spec const SPEC_F64Nearest: u8 = 158;
    pub spec const SPEC_F64Sqrt: u8 = 159;
    pub spec const SPEC_F64Add: u8 = 160;
    pub spec const SPEC_F64Sub: u8 = 161;
    pub spec const SPEC_F64Mul: u8 = 162;
    pub spec const SPEC_F64Div: u8 = 163;
    pub spec const SPEC_F64Min: u8 = 164;
    pub spec const SPEC_F64Max: u8 = 165;
    pub spec const SPEC_F64Copysign: u8 = 166;
    pub spec const SPEC_I32WrapI64: u8 = 167;
    pub spec const SPEC_I32TruncF32S: u8 = 168;
    pub spec const SPEC_I32TruncF32U: u8 = 169;
    pub spec const SPEC_I32TruncF64S: u8 = 170;
    pub spec const SPEC_I32TruncF64U: u8 = 171;
    pub spec const SPEC_I64ExtendI32S: u8 = 172;
    pub spec const SPEC_I64ExtendI32U: u8 = 173;
    pub spec const SPEC_I64TruncF32S: u8 = 174;
    pub spec const SPEC_I64TruncF32U: u8 = 175;
    pub spec const SPEC_I64TruncF64S: u8 = 176;
    pub spec const SPEC_I64TruncF64U: u8 = 177;
    pub spec const SPEC_F32ConvertI32S: u8 = 178;
    pub spec const SPEC_F32ConvertI32U: u8 = 179;
    pub spec const SPEC_F32ConvertI64S: u8 = 180;
    pub spec const SPEC_F32ConvertI64U: u8 = 181;
    pub spec const SPEC_F32DemoteF64: u8 = 182;
    pub spec const SPEC_F64ConvertI32S: u8 = 183;
    pub spec const SPEC_F64ConvertI32U: u8 = 184;
    pub spec const SPEC_F64ConvertI64S: u8 = 185;
    pub spec const SPEC_F64ConvertI64U: u8 = 186;
    pub spec const SPEC_F64PromoteF32: u8 = 187;
    pub spec const SPEC_I32ReinterpretF32: u8 = 188;
    pub spec const SPEC_I64ReinterpretF64: u8 = 189;
    pub spec const SPEC_F32ReinterpretI32: u8 = 190;
    pub spec const SPEC_F64ReinterpretI64: u8 = 191;
    pub spec const SPEC_I32Extend8S: u8 = 192;
    pub spec const SPEC_I32Extend16S: u8 = 193;
    pub spec const SPEC_I64Extend8S: u8 = 194;
    pub spec const SPEC_I64Extend16S: u8 = 195;
    pub spec const SPEC_I64Extend32S: u8 = 196;
    pub spec const SPEC_OpcodeFD: u8 = 253;
    pub exec const Unreachable: u8 ensures Unreachable == SPEC_Unreachable { 0 }
    pub exec const Nop: u8 ensures Nop == SPEC_Nop { 1 }
    pub exec const Block: u8 ensures Block == SPEC_Block { 2 }
    pub exec const Loop: u8 ensures Loop == SPEC_Loop { 3 }
    pub exec const If: u8 ensures If == SPEC_If { 4 }
    pub exec const Else: u8 ensures Else == SPEC_Else { 5 }
    pub exec const End: u8 ensures End == SPEC_End { 11 }
    pub exec const Br: u8 ensures Br == SPEC_Br { 12 }
    pub exec const BrIf: u8 ensures BrIf == SPEC_BrIf { 13 }
    pub exec const BrTable: u8 ensures BrTable == SPEC_BrTable { 14 }
    pub exec const Ret: u8 ensures Ret == SPEC_Ret { 15 }
    pub exec const Call: u8 ensures Call == SPEC_Call { 16 }
    pub exec const CallIndirect: u8 ensures CallIndirect == SPEC_CallIndirect { 17 }
    pub exec const RefNull: u8 ensures RefNull == SPEC_RefNull { 208 }
    pub exec const RefIsNull: u8 ensures RefIsNull == SPEC_RefIsNull { 209 }
    pub exec const RefFunc: u8 ensures RefFunc == SPEC_RefFunc { 210 }
    pub exec const Drop: u8 ensures Drop == SPEC_Drop { 26 }
    pub exec const Select: u8 ensures Select == SPEC_Select { 27 }
    pub exec const SelectT: u8 ensures SelectT == SPEC_SelectT { 28 }
    pub exec const LocalGet: u8 ensures LocalGet == SPEC_LocalGet { 32 }
    pub exec const LocalSet: u8 ensures LocalSet == SPEC_LocalSet { 33 }
    pub exec const LocalTee: u8 ensures LocalTee == SPEC_LocalTee { 34 }
    pub exec const GlobalGet: u8 ensures GlobalGet == SPEC_GlobalGet { 35 }
    pub exec const GlobalSet: u8 ensures GlobalSet == SPEC_GlobalSet { 36 }
    pub exec const TableGet: u8 ensures TableGet == SPEC_TableGet { 37 }
    pub exec const TableSet: u8 ensures TableSet == SPEC_TableSet { 38 }
    pub exec const OpcodeFC: u8 ensures OpcodeFC == SPEC_OpcodeFC { 252 }
    pub exec const I32Load: u8 ensures I32Load == SPEC_I32Load { 40 }
    pub exec const I64Load: u8 ensures I64Load == SPEC_I64Load { 41 }
    pub exec const F32Load: u8 ensures F32Load == SPEC_F32Load { 42 }
    pub exec const F64Load: u8 ensures F64Load == SPEC_F64Load { 43 }
    pub exec const I32Load8S: u8 ensures I32Load8S == SPEC_I32Load8S { 44 }
    pub exec const I32Load8U: u8 ensures I32Load8U == SPEC_I32Load8U { 45 }
    pub exec const I32Load16S: u8 ensures I32Load16S == SPEC_I32Load16S { 46 }
    pub exec const I32Load16U: u8 ensures I32Load16U == SPEC_I32Load16U { 47 }
    pub exec const I64Load8S: u8 ensures I64Load8S == SPEC_I64Load8S { 48 }
    pub exec const I64Load8U: u8 ensures I64Load8U == SPEC_I64Load8U { 49 }
    pub exec const I64Load16S: u8 ensures I64Load16S == SPEC_I64Load16S { 50 }
    pub exec const I64Load16U: u8 ensures I64Load16U == SPEC_I64Load16U { 51 }
    pub exec const I64Load32S: u8 ensures I64Load32S == SPEC_I64Load32S { 52 }
    pub exec const I64Load32U: u8 ensures I64Load32U == SPEC_I64Load32U { 53 }
    pub exec const I32Store: u8 ensures I32Store == SPEC_I32Store { 54 }
    pub exec const I64Store: u8 ensures I64Store == SPEC_I64Store { 55 }
    pub exec const F32Store: u8 ensures F32Store == SPEC_F32Store { 56 }
    pub exec const F64Store: u8 ensures F64Store == SPEC_F64Store { 57 }
    pub exec const I32Store8: u8 ensures I32Store8 == SPEC_I32Store8 { 58 }
    pub exec const I32Store16: u8 ensures I32Store16 == SPEC_I32Store16 { 59 }
    pub exec const I64Store8: u8 ensures I64Store8 == SPEC_I64Store8 { 60 }
    pub exec const I64Store16: u8 ensures I64Store16 == SPEC_I64Store16 { 61 }
    pub exec const I64Store32: u8 ensures I64Store32 == SPEC_I64Store32 { 62 }
    pub exec const MemorySize: u8 ensures MemorySize == SPEC_MemorySize { 63 }
    pub exec const MemoryGrow: u8 ensures MemoryGrow == SPEC_MemoryGrow { 64 }
    pub exec const I32Const: u8 ensures I32Const == SPEC_I32Const { 65 }
    pub exec const I64Const: u8 ensures I64Const == SPEC_I64Const { 66 }
    pub exec const F32Const: u8 ensures F32Const == SPEC_F32Const { 67 }
    pub exec const F64Const: u8 ensures F64Const == SPEC_F64Const { 68 }
    pub exec const I32Eqz: u8 ensures I32Eqz == SPEC_I32Eqz { 69 }
    pub exec const I32Eq: u8 ensures I32Eq == SPEC_I32Eq { 70 }
    pub exec const I32Ne: u8 ensures I32Ne == SPEC_I32Ne { 71 }
    pub exec const I32LtS: u8 ensures I32LtS == SPEC_I32LtS { 72 }
    pub exec const I32LtU: u8 ensures I32LtU == SPEC_I32LtU { 73 }
    pub exec const I32GtS: u8 ensures I32GtS == SPEC_I32GtS { 74 }
    pub exec const I32GtU: u8 ensures I32GtU == SPEC_I32GtU { 75 }
    pub exec const I32LeS: u8 ensures I32LeS == SPEC_I32LeS { 76 }
    pub exec const I32LeU: u8 ensures I32LeU == SPEC_I32LeU { 77 }
    pub exec const I32GeS: u8 ensures I32GeS == SPEC_I32GeS { 78 }
    pub exec const I32GeU: u8 ensures I32GeU == SPEC_I32GeU { 79 }
    pub exec const I64Eqz: u8 ensures I64Eqz == SPEC_I64Eqz { 80 }
    pub exec const I64Eq: u8 ensures I64Eq == SPEC_I64Eq { 81 }
    pub exec const I64Ne: u8 ensures I64Ne == SPEC_I64Ne { 82 }
    pub exec const I64LtS: u8 ensures I64LtS == SPEC_I64LtS { 83 }
    pub exec const I64LtU: u8 ensures I64LtU == SPEC_I64LtU { 84 }
    pub exec const I64GtS: u8 ensures I64GtS == SPEC_I64GtS { 85 }
    pub exec const I64GtU: u8 ensures I64GtU == SPEC_I64GtU { 86 }
    pub exec const I64LeS: u8 ensures I64LeS == SPEC_I64LeS { 87 }
    pub exec const I64LeU: u8 ensures I64LeU == SPEC_I64LeU { 88 }
    pub exec const I64GeS: u8 ensures I64GeS == SPEC_I64GeS { 89 }
    pub exec const I64GeU: u8 ensures I64GeU == SPEC_I64GeU { 90 }
    pub exec const F32Eq: u8 ensures F32Eq == SPEC_F32Eq { 91 }
    pub exec const F32Ne: u8 ensures F32Ne == SPEC_F32Ne { 92 }
    pub exec const F32Lt: u8 ensures F32Lt == SPEC_F32Lt { 93 }
    pub exec const F32Gt: u8 ensures F32Gt == SPEC_F32Gt { 94 }
    pub exec const F32Le: u8 ensures F32Le == SPEC_F32Le { 95 }
    pub exec const F32Ge: u8 ensures F32Ge == SPEC_F32Ge { 96 }
    pub exec const F64Eq: u8 ensures F64Eq == SPEC_F64Eq { 97 }
    pub exec const F64Ne: u8 ensures F64Ne == SPEC_F64Ne { 98 }
    pub exec const F64Lt: u8 ensures F64Lt == SPEC_F64Lt { 99 }
    pub exec const F64Gt: u8 ensures F64Gt == SPEC_F64Gt { 100 }
    pub exec const F64Le: u8 ensures F64Le == SPEC_F64Le { 101 }
    pub exec const F64Ge: u8 ensures F64Ge == SPEC_F64Ge { 102 }
    pub exec const I32Clz: u8 ensures I32Clz == SPEC_I32Clz { 103 }
    pub exec const I32Ctz: u8 ensures I32Ctz == SPEC_I32Ctz { 104 }
    pub exec const I32Popcnt: u8 ensures I32Popcnt == SPEC_I32Popcnt { 105 }
    pub exec const I32Add: u8 ensures I32Add == SPEC_I32Add { 106 }
    pub exec const I32Sub: u8 ensures I32Sub == SPEC_I32Sub { 107 }
    pub exec const I32Mul: u8 ensures I32Mul == SPEC_I32Mul { 108 }
    pub exec const I32DivS: u8 ensures I32DivS == SPEC_I32DivS { 109 }
    pub exec const I32DivU: u8 ensures I32DivU == SPEC_I32DivU { 110 }
    pub exec const I32RemS: u8 ensures I32RemS == SPEC_I32RemS { 111 }
    pub exec const I32RemU: u8 ensures I32RemU == SPEC_I32RemU { 112 }
    pub exec const I32And: u8 ensures I32And == SPEC_I32And { 113 }
    pub exec const I32Or: u8 ensures I32Or == SPEC_I32Or { 114 }
    pub exec const I32Xor: u8 ensures I32Xor == SPEC_I32Xor { 115 }
    pub exec const I32Shl: u8 ensures I32Shl == SPEC_I32Shl { 116 }
    pub exec const I32ShrS: u8 ensures I32ShrS == SPEC_I32ShrS { 117 }
    pub exec const I32ShrU: u8 ensures I32ShrU == SPEC_I32ShrU { 118 }
    pub exec const I32Rotl: u8 ensures I32Rotl == SPEC_I32Rotl { 119 }
    pub exec const I32Rotr: u8 ensures I32Rotr == SPEC_I32Rotr { 120 }
    pub exec const I64Clz: u8 ensures I64Clz == SPEC_I64Clz { 121 }
    pub exec const I64Ctz: u8 ensures I64Ctz == SPEC_I64Ctz { 122 }
    pub exec const I64Popcnt: u8 ensures I64Popcnt == SPEC_I64Popcnt { 123 }
    pub exec const I64Add: u8 ensures I64Add == SPEC_I64Add { 124 }
    pub exec const I64Sub: u8 ensures I64Sub == SPEC_I64Sub { 125 }
    pub exec const I64Mul: u8 ensures I64Mul == SPEC_I64Mul { 126 }
    pub exec const I64DivS: u8 ensures I64DivS == SPEC_I64DivS { 127 }
    pub exec const I64DivU: u8 ensures I64DivU == SPEC_I64DivU { 128 }
    pub exec const I64RemS: u8 ensures I64RemS == SPEC_I64RemS { 129 }
    pub exec const I64RemU: u8 ensures I64RemU == SPEC_I64RemU { 130 }
    pub exec const I64And: u8 ensures I64And == SPEC_I64And { 131 }
    pub exec const I64Or: u8 ensures I64Or == SPEC_I64Or { 132 }
    pub exec const I64Xor: u8 ensures I64Xor == SPEC_I64Xor { 133 }
    pub exec const I64Shl: u8 ensures I64Shl == SPEC_I64Shl { 134 }
    pub exec const I64ShrS: u8 ensures I64ShrS == SPEC_I64ShrS { 135 }
    pub exec const I64ShrU: u8 ensures I64ShrU == SPEC_I64ShrU { 136 }
    pub exec const I64Rotl: u8 ensures I64Rotl == SPEC_I64Rotl { 137 }
    pub exec const I64Rotr: u8 ensures I64Rotr == SPEC_I64Rotr { 138 }
    pub exec const F32Abs: u8 ensures F32Abs == SPEC_F32Abs { 139 }
    pub exec const F32Neg: u8 ensures F32Neg == SPEC_F32Neg { 140 }
    pub exec const F32Ceil: u8 ensures F32Ceil == SPEC_F32Ceil { 141 }
    pub exec const F32Floor: u8 ensures F32Floor == SPEC_F32Floor { 142 }
    pub exec const F32Trunc: u8 ensures F32Trunc == SPEC_F32Trunc { 143 }
    pub exec const F32Nearest: u8 ensures F32Nearest == SPEC_F32Nearest { 144 }
    pub exec const F32Sqrt: u8 ensures F32Sqrt == SPEC_F32Sqrt { 145 }
    pub exec const F32Add: u8 ensures F32Add == SPEC_F32Add { 146 }
    pub exec const F32Sub: u8 ensures F32Sub == SPEC_F32Sub { 147 }
    pub exec const F32Mul: u8 ensures F32Mul == SPEC_F32Mul { 148 }
    pub exec const F32Div: u8 ensures F32Div == SPEC_F32Div { 149 }
    pub exec const F32Min: u8 ensures F32Min == SPEC_F32Min { 150 }
    pub exec const F32Max: u8 ensures F32Max == SPEC_F32Max { 151 }
    pub exec const F32Copysign: u8 ensures F32Copysign == SPEC_F32Copysign { 152 }
    pub exec const F64Abs: u8 ensures F64Abs == SPEC_F64Abs { 153 }
    pub exec const F64Neg: u8 ensures F64Neg == SPEC_F64Neg { 154 }
    pub exec const F64Ceil: u8 ensures F64Ceil == SPEC_F64Ceil { 155 }
    pub exec const F64Floor: u8 ensures F64Floor == SPEC_F64Floor { 156 }
    pub exec const F64Trunc: u8 ensures F64Trunc == SPEC_F64Trunc { 157 }
    pub exec const F64Nearest: u8 ensures F64Nearest == SPEC_F64Nearest { 158 }
    pub exec const F64Sqrt: u8 ensures F64Sqrt == SPEC_F64Sqrt { 159 }
    pub exec const F64Add: u8 ensures F64Add == SPEC_F64Add { 160 }
    pub exec const F64Sub: u8 ensures F64Sub == SPEC_F64Sub { 161 }
    pub exec const F64Mul: u8 ensures F64Mul == SPEC_F64Mul { 162 }
    pub exec const F64Div: u8 ensures F64Div == SPEC_F64Div { 163 }
    pub exec const F64Min: u8 ensures F64Min == SPEC_F64Min { 164 }
    pub exec const F64Max: u8 ensures F64Max == SPEC_F64Max { 165 }
    pub exec const F64Copysign: u8 ensures F64Copysign == SPEC_F64Copysign { 166 }
    pub exec const I32WrapI64: u8 ensures I32WrapI64 == SPEC_I32WrapI64 { 167 }
    pub exec const I32TruncF32S: u8 ensures I32TruncF32S == SPEC_I32TruncF32S { 168 }
    pub exec const I32TruncF32U: u8 ensures I32TruncF32U == SPEC_I32TruncF32U { 169 }
    pub exec const I32TruncF64S: u8 ensures I32TruncF64S == SPEC_I32TruncF64S { 170 }
    pub exec const I32TruncF64U: u8 ensures I32TruncF64U == SPEC_I32TruncF64U { 171 }
    pub exec const I64ExtendI32S: u8 ensures I64ExtendI32S == SPEC_I64ExtendI32S { 172 }
    pub exec const I64ExtendI32U: u8 ensures I64ExtendI32U == SPEC_I64ExtendI32U { 173 }
    pub exec const I64TruncF32S: u8 ensures I64TruncF32S == SPEC_I64TruncF32S { 174 }
    pub exec const I64TruncF32U: u8 ensures I64TruncF32U == SPEC_I64TruncF32U { 175 }
    pub exec const I64TruncF64S: u8 ensures I64TruncF64S == SPEC_I64TruncF64S { 176 }
    pub exec const I64TruncF64U: u8 ensures I64TruncF64U == SPEC_I64TruncF64U { 177 }
    pub exec const F32ConvertI32S: u8 ensures F32ConvertI32S == SPEC_F32ConvertI32S { 178 }
    pub exec const F32ConvertI32U: u8 ensures F32ConvertI32U == SPEC_F32ConvertI32U { 179 }
    pub exec const F32ConvertI64S: u8 ensures F32ConvertI64S == SPEC_F32ConvertI64S { 180 }
    pub exec const F32ConvertI64U: u8 ensures F32ConvertI64U == SPEC_F32ConvertI64U { 181 }
    pub exec const F32DemoteF64: u8 ensures F32DemoteF64 == SPEC_F32DemoteF64 { 182 }
    pub exec const F64ConvertI32S: u8 ensures F64ConvertI32S == SPEC_F64ConvertI32S { 183 }
    pub exec const F64ConvertI32U: u8 ensures F64ConvertI32U == SPEC_F64ConvertI32U { 184 }
    pub exec const F64ConvertI64S: u8 ensures F64ConvertI64S == SPEC_F64ConvertI64S { 185 }
    pub exec const F64ConvertI64U: u8 ensures F64ConvertI64U == SPEC_F64ConvertI64U { 186 }
    pub exec const F64PromoteF32: u8 ensures F64PromoteF32 == SPEC_F64PromoteF32 { 187 }
    pub exec const I32ReinterpretF32: u8 ensures I32ReinterpretF32 == SPEC_I32ReinterpretF32 { 188 }
    pub exec const I64ReinterpretF64: u8 ensures I64ReinterpretF64 == SPEC_I64ReinterpretF64 { 189 }
    pub exec const F32ReinterpretI32: u8 ensures F32ReinterpretI32 == SPEC_F32ReinterpretI32 { 190 }
    pub exec const F64ReinterpretI64: u8 ensures F64ReinterpretI64 == SPEC_F64ReinterpretI64 { 191 }
    pub exec const I32Extend8S: u8 ensures I32Extend8S == SPEC_I32Extend8S { 192 }
    pub exec const I32Extend16S: u8 ensures I32Extend16S == SPEC_I32Extend16S { 193 }
    pub exec const I64Extend8S: u8 ensures I64Extend8S == SPEC_I64Extend8S { 194 }
    pub exec const I64Extend16S: u8 ensures I64Extend16S == SPEC_I64Extend16S { 195 }
    pub exec const I64Extend32S: u8 ensures I64Extend32S == SPEC_I64Extend32S { 196 }
    pub exec const OpcodeFD: u8 ensures OpcodeFD == SPEC_OpcodeFD { 253 }
}


pub struct SpecInstrBytecodeCombinator(pub SpecInstrBytecodeCombinatorAlias);

impl SpecCombinator for SpecInstrBytecodeCombinator {
    type Type = u8;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrBytecodeCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrBytecodeCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrBytecodeCombinatorAlias = U8;

pub struct InstrBytecodeCombinator(pub InstrBytecodeCombinatorAlias);

impl View for InstrBytecodeCombinator {
    type V = SpecInstrBytecodeCombinator;
    open spec fn view(&self) -> Self::V { SpecInstrBytecodeCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrBytecodeCombinator {
    type Type = u8;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrBytecodeCombinatorAlias = U8;


pub open spec fn spec_instr_bytecode() -> SpecInstrBytecodeCombinator {
    SpecInstrBytecodeCombinator(U8)
}

                
pub fn instr_bytecode<'a>() -> (o: InstrBytecodeCombinator)
    ensures o@ == spec_instr_bytecode(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrBytecodeCombinator(U8);
    assert({
        &&& combinator@ == spec_instr_bytecode()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_bytecode<'a>(input: &'a [u8]) -> (res: PResult<<InstrBytecodeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_bytecode().spec_parse(input@) == Some((n as int, v@)),
        spec_instr_bytecode().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_bytecode().spec_parse(input@) is None,
        spec_instr_bytecode().spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_bytecode();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_bytecode<'a>(v: <InstrBytecodeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_bytecode().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_bytecode().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_bytecode().spec_serialize(v@))
        },
{
    let combinator = instr_bytecode();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn instr_bytecode_len<'a>(v: <InstrBytecodeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_instr_bytecode().wf(v@),
        spec_instr_bytecode().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_bytecode().spec_serialize(v@).len(),
{
    let combinator = instr_bytecode();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecLocalidx = u64;
pub type Localidx = u64;
pub type LocalidxRef<'a> = &'a u64;


pub struct SpecLocalidxCombinator(pub SpecLocalidxCombinatorAlias);

impl SpecCombinator for SpecLocalidxCombinator {
    type Type = SpecLocalidx;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecLocalidxCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecLocalidxCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecLocalidxCombinatorAlias = UnsignedLEB128;

pub struct LocalidxCombinator(pub LocalidxCombinatorAlias);

impl View for LocalidxCombinator {
    type V = SpecLocalidxCombinator;
    open spec fn view(&self) -> Self::V { SpecLocalidxCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for LocalidxCombinator {
    type Type = Localidx;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type LocalidxCombinatorAlias = UnsignedLEB128;


pub open spec fn spec_localidx() -> SpecLocalidxCombinator {
    SpecLocalidxCombinator(UnsignedLEB128)
}

                
pub fn localidx<'a>() -> (o: LocalidxCombinator)
    ensures o@ == spec_localidx(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = LocalidxCombinator(UnsignedLEB128);
    assert({
        &&& combinator@ == spec_localidx()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_localidx<'a>(input: &'a [u8]) -> (res: PResult<<LocalidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_localidx().spec_parse(input@) == Some((n as int, v@)),
        spec_localidx().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_localidx().spec_parse(input@) is None,
        spec_localidx().spec_parse(input@) is None ==> res is Err,
{
    let combinator = localidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_localidx<'a>(v: <LocalidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_localidx().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_localidx().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_localidx().spec_serialize(v@))
        },
{
    let combinator = localidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn localidx_len<'a>(v: <LocalidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_localidx().wf(v@),
        spec_localidx().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_localidx().spec_serialize(v@).len(),
{
    let combinator = localidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecGlobalidx = u64;
pub type Globalidx = u64;
pub type GlobalidxRef<'a> = &'a u64;


pub struct SpecGlobalidxCombinator(pub SpecGlobalidxCombinatorAlias);

impl SpecCombinator for SpecGlobalidxCombinator {
    type Type = SpecGlobalidx;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecGlobalidxCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecGlobalidxCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecGlobalidxCombinatorAlias = UnsignedLEB128;

pub struct GlobalidxCombinator(pub GlobalidxCombinatorAlias);

impl View for GlobalidxCombinator {
    type V = SpecGlobalidxCombinator;
    open spec fn view(&self) -> Self::V { SpecGlobalidxCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for GlobalidxCombinator {
    type Type = Globalidx;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type GlobalidxCombinatorAlias = UnsignedLEB128;


pub open spec fn spec_globalidx() -> SpecGlobalidxCombinator {
    SpecGlobalidxCombinator(UnsignedLEB128)
}

                
pub fn globalidx<'a>() -> (o: GlobalidxCombinator)
    ensures o@ == spec_globalidx(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = GlobalidxCombinator(UnsignedLEB128);
    assert({
        &&& combinator@ == spec_globalidx()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_globalidx<'a>(input: &'a [u8]) -> (res: PResult<<GlobalidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_globalidx().spec_parse(input@) == Some((n as int, v@)),
        spec_globalidx().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_globalidx().spec_parse(input@) is None,
        spec_globalidx().spec_parse(input@) is None ==> res is Err,
{
    let combinator = globalidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_globalidx<'a>(v: <GlobalidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_globalidx().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_globalidx().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_globalidx().spec_serialize(v@))
        },
{
    let combinator = globalidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn globalidx_len<'a>(v: <GlobalidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_globalidx().wf(v@),
        spec_globalidx().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_globalidx().spec_serialize(v@).len(),
{
    let combinator = globalidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub enum SpecInstrVariable {
    LocalGet(SpecLocalidx),
    LocalSet(SpecLocalidx),
    LocalTee(SpecLocalidx),
    GlobalGet(SpecGlobalidx),
    GlobalSet(SpecGlobalidx),
}

pub type SpecInstrVariableInner = Either<SpecLocalidx, Either<SpecLocalidx, Either<SpecLocalidx, Either<SpecGlobalidx, SpecGlobalidx>>>>;

impl SpecFrom<SpecInstrVariable> for SpecInstrVariableInner {
    open spec fn spec_from(m: SpecInstrVariable) -> SpecInstrVariableInner {
        match m {
            SpecInstrVariable::LocalGet(m) => Either::Left(m),
            SpecInstrVariable::LocalSet(m) => Either::Right(Either::Left(m)),
            SpecInstrVariable::LocalTee(m) => Either::Right(Either::Right(Either::Left(m))),
            SpecInstrVariable::GlobalGet(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            SpecInstrVariable::GlobalSet(m) => Either::Right(Either::Right(Either::Right(Either::Right(m)))),
        }
    }

}

                
impl SpecFrom<SpecInstrVariableInner> for SpecInstrVariable {
    open spec fn spec_from(m: SpecInstrVariableInner) -> SpecInstrVariable {
        match m {
            Either::Left(m) => SpecInstrVariable::LocalGet(m),
            Either::Right(Either::Left(m)) => SpecInstrVariable::LocalSet(m),
            Either::Right(Either::Right(Either::Left(m))) => SpecInstrVariable::LocalTee(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => SpecInstrVariable::GlobalGet(m),
            Either::Right(Either::Right(Either::Right(Either::Right(m)))) => SpecInstrVariable::GlobalSet(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InstrVariable {
    LocalGet(Localidx),
    LocalSet(Localidx),
    LocalTee(Localidx),
    GlobalGet(Globalidx),
    GlobalSet(Globalidx),
}

pub type InstrVariableInner = Either<Localidx, Either<Localidx, Either<Localidx, Either<Globalidx, Globalidx>>>>;

pub type InstrVariableInnerRef<'a> = Either<&'a Localidx, Either<&'a Localidx, Either<&'a Localidx, Either<&'a Globalidx, &'a Globalidx>>>>;


impl View for InstrVariable {
    type V = SpecInstrVariable;
    open spec fn view(&self) -> Self::V {
        match self {
            InstrVariable::LocalGet(m) => SpecInstrVariable::LocalGet(m@),
            InstrVariable::LocalSet(m) => SpecInstrVariable::LocalSet(m@),
            InstrVariable::LocalTee(m) => SpecInstrVariable::LocalTee(m@),
            InstrVariable::GlobalGet(m) => SpecInstrVariable::GlobalGet(m@),
            InstrVariable::GlobalSet(m) => SpecInstrVariable::GlobalSet(m@),
        }
    }
}


impl<'a> From<&'a InstrVariable> for InstrVariableInnerRef<'a> {
    fn ex_from(m: &'a InstrVariable) -> InstrVariableInnerRef<'a> {
        match m {
            InstrVariable::LocalGet(m) => Either::Left(m),
            InstrVariable::LocalSet(m) => Either::Right(Either::Left(m)),
            InstrVariable::LocalTee(m) => Either::Right(Either::Right(Either::Left(m))),
            InstrVariable::GlobalGet(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            InstrVariable::GlobalSet(m) => Either::Right(Either::Right(Either::Right(Either::Right(m)))),
        }
    }

}

impl From<InstrVariableInner> for InstrVariable {
    fn ex_from(m: InstrVariableInner) -> InstrVariable {
        match m {
            Either::Left(m) => InstrVariable::LocalGet(m),
            Either::Right(Either::Left(m)) => InstrVariable::LocalSet(m),
            Either::Right(Either::Right(Either::Left(m))) => InstrVariable::LocalTee(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => InstrVariable::GlobalGet(m),
            Either::Right(Either::Right(Either::Right(Either::Right(m)))) => InstrVariable::GlobalSet(m),
        }
    }
    
}


pub struct InstrVariableMapper;
impl View for InstrVariableMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrVariableMapper {
    type Src = SpecInstrVariableInner;
    type Dst = SpecInstrVariable;
}
impl SpecIsoProof for InstrVariableMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrVariableMapper {
    type Src = InstrVariableInner;
    type Dst = InstrVariable;
    type RefSrc = InstrVariableInnerRef<'a>;
}

type SpecInstrVariableCombinatorAlias1 = Choice<Cond<SpecGlobalidxCombinator>, Cond<SpecGlobalidxCombinator>>;
type SpecInstrVariableCombinatorAlias2 = Choice<Cond<SpecLocalidxCombinator>, SpecInstrVariableCombinatorAlias1>;
type SpecInstrVariableCombinatorAlias3 = Choice<Cond<SpecLocalidxCombinator>, SpecInstrVariableCombinatorAlias2>;
type SpecInstrVariableCombinatorAlias4 = Choice<Cond<SpecLocalidxCombinator>, SpecInstrVariableCombinatorAlias3>;
pub struct SpecInstrVariableCombinator(pub SpecInstrVariableCombinatorAlias);

impl SpecCombinator for SpecInstrVariableCombinator {
    type Type = SpecInstrVariable;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrVariableCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrVariableCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrVariableCombinatorAlias = Mapped<SpecInstrVariableCombinatorAlias4, InstrVariableMapper>;
type InstrVariableCombinatorAlias1 = Choice<Cond<GlobalidxCombinator>, Cond<GlobalidxCombinator>>;
type InstrVariableCombinatorAlias2 = Choice<Cond<LocalidxCombinator>, InstrVariableCombinator1>;
type InstrVariableCombinatorAlias3 = Choice<Cond<LocalidxCombinator>, InstrVariableCombinator2>;
type InstrVariableCombinatorAlias4 = Choice<Cond<LocalidxCombinator>, InstrVariableCombinator3>;
pub struct InstrVariableCombinator1(pub InstrVariableCombinatorAlias1);
impl View for InstrVariableCombinator1 {
    type V = SpecInstrVariableCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrVariableCombinator1, InstrVariableCombinatorAlias1);

pub struct InstrVariableCombinator2(pub InstrVariableCombinatorAlias2);
impl View for InstrVariableCombinator2 {
    type V = SpecInstrVariableCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrVariableCombinator2, InstrVariableCombinatorAlias2);

pub struct InstrVariableCombinator3(pub InstrVariableCombinatorAlias3);
impl View for InstrVariableCombinator3 {
    type V = SpecInstrVariableCombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrVariableCombinator3, InstrVariableCombinatorAlias3);

pub struct InstrVariableCombinator4(pub InstrVariableCombinatorAlias4);
impl View for InstrVariableCombinator4 {
    type V = SpecInstrVariableCombinatorAlias4;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrVariableCombinator4, InstrVariableCombinatorAlias4);

pub struct InstrVariableCombinator(pub InstrVariableCombinatorAlias);

impl View for InstrVariableCombinator {
    type V = SpecInstrVariableCombinator;
    open spec fn view(&self) -> Self::V { SpecInstrVariableCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrVariableCombinator {
    type Type = InstrVariable;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrVariableCombinatorAlias = Mapped<InstrVariableCombinator4, InstrVariableMapper>;


pub open spec fn spec_instr_variable(opcode: u8) -> SpecInstrVariableCombinator {
    SpecInstrVariableCombinator(Mapped { inner: Choice(Cond { cond: opcode == InstrBytecode::SPEC_LocalGet, inner: spec_localidx() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_LocalSet, inner: spec_localidx() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_LocalTee, inner: spec_localidx() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_GlobalGet, inner: spec_globalidx() }, Cond { cond: opcode == InstrBytecode::SPEC_GlobalSet, inner: spec_globalidx() })))), mapper: InstrVariableMapper })
}

pub fn instr_variable<'a>(opcode: u8) -> (o: InstrVariableCombinator)
    ensures o@ == spec_instr_variable(opcode@),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrVariableCombinator(Mapped { inner: InstrVariableCombinator4(Choice::new(Cond { cond: opcode == InstrBytecode::LocalGet, inner: localidx() }, InstrVariableCombinator3(Choice::new(Cond { cond: opcode == InstrBytecode::LocalSet, inner: localidx() }, InstrVariableCombinator2(Choice::new(Cond { cond: opcode == InstrBytecode::LocalTee, inner: localidx() }, InstrVariableCombinator1(Choice::new(Cond { cond: opcode == InstrBytecode::GlobalGet, inner: globalidx() }, Cond { cond: opcode == InstrBytecode::GlobalSet, inner: globalidx() })))))))), mapper: InstrVariableMapper });
    assert({
        &&& combinator@ == spec_instr_variable(opcode@)
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_variable<'a>(input: &'a [u8], opcode: u8) -> (res: PResult<<InstrVariableCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_variable(opcode@).spec_parse(input@) == Some((n as int, v@)),
        spec_instr_variable(opcode@).spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_variable(opcode@).spec_parse(input@) is None,
        spec_instr_variable(opcode@).spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_variable( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_variable<'a>(v: <InstrVariableCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize, opcode: u8) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_variable(opcode@).wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_variable(opcode@).spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_variable(opcode@).spec_serialize(v@))
        },
{
    let combinator = instr_variable( opcode );
    combinator.serialize(v, data, pos)
}

pub fn instr_variable_len<'a>(v: <InstrVariableCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, opcode: u8) -> (serialize_len: usize)
    requires
        spec_instr_variable(opcode@).wf(v@),
        spec_instr_variable(opcode@).spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_variable(opcode@).spec_serialize(v@).len(),
{
    let combinator = instr_variable( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub type SpecLabelidx = u64;
pub type Labelidx = u64;
pub type LabelidxRef<'a> = &'a u64;


pub struct SpecLabelidxCombinator(pub SpecLabelidxCombinatorAlias);

impl SpecCombinator for SpecLabelidxCombinator {
    type Type = SpecLabelidx;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecLabelidxCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecLabelidxCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecLabelidxCombinatorAlias = UnsignedLEB128;

pub struct LabelidxCombinator(pub LabelidxCombinatorAlias);

impl View for LabelidxCombinator {
    type V = SpecLabelidxCombinator;
    open spec fn view(&self) -> Self::V { SpecLabelidxCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for LabelidxCombinator {
    type Type = Labelidx;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type LabelidxCombinatorAlias = UnsignedLEB128;


pub open spec fn spec_labelidx() -> SpecLabelidxCombinator {
    SpecLabelidxCombinator(UnsignedLEB128)
}

                
pub fn labelidx<'a>() -> (o: LabelidxCombinator)
    ensures o@ == spec_labelidx(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = LabelidxCombinator(UnsignedLEB128);
    assert({
        &&& combinator@ == spec_labelidx()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_labelidx<'a>(input: &'a [u8]) -> (res: PResult<<LabelidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_labelidx().spec_parse(input@) == Some((n as int, v@)),
        spec_labelidx().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_labelidx().spec_parse(input@) is None,
        spec_labelidx().spec_parse(input@) is None ==> res is Err,
{
    let combinator = labelidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_labelidx<'a>(v: <LabelidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_labelidx().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_labelidx().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_labelidx().spec_serialize(v@))
        },
{
    let combinator = labelidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn labelidx_len<'a>(v: <LabelidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_labelidx().wf(v@),
        spec_labelidx().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_labelidx().spec_serialize(v@).len(),
{
    let combinator = labelidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecLabelidxVec {
    pub l: u64,
    pub v: Seq<SpecLabelidx>,
}

pub type SpecLabelidxVecInner = (u64, Seq<SpecLabelidx>);


impl SpecFrom<SpecLabelidxVec> for SpecLabelidxVecInner {
    open spec fn spec_from(m: SpecLabelidxVec) -> SpecLabelidxVecInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecLabelidxVecInner> for SpecLabelidxVec {
    open spec fn spec_from(m: SpecLabelidxVecInner) -> SpecLabelidxVec {
        let (l, v) = m;
        SpecLabelidxVec { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct LabelidxVec {
    pub l: u64,
    pub v: RepeatResult<Labelidx>,
}

impl View for LabelidxVec {
    type V = SpecLabelidxVec;

    open spec fn view(&self) -> Self::V {
        SpecLabelidxVec {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type LabelidxVecInner = (u64, RepeatResult<Labelidx>);

pub type LabelidxVecInnerRef<'a> = (&'a u64, &'a RepeatResult<Labelidx>);
impl<'a> From<&'a LabelidxVec> for LabelidxVecInnerRef<'a> {
    fn ex_from(m: &'a LabelidxVec) -> LabelidxVecInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl From<LabelidxVecInner> for LabelidxVec {
    fn ex_from(m: LabelidxVecInner) -> LabelidxVec {
        let (l, v) = m;
        LabelidxVec { l, v }
    }
}

pub struct LabelidxVecMapper;
impl View for LabelidxVecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for LabelidxVecMapper {
    type Src = SpecLabelidxVecInner;
    type Dst = SpecLabelidxVec;
}
impl SpecIsoProof for LabelidxVecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for LabelidxVecMapper {
    type Src = LabelidxVecInner;
    type Dst = LabelidxVec;
    type RefSrc = LabelidxVecInnerRef<'a>;
}

pub struct SpecLabelidxVecCombinator(pub SpecLabelidxVecCombinatorAlias);

impl SpecCombinator for SpecLabelidxVecCombinator {
    type Type = SpecLabelidxVec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecLabelidxVecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecLabelidxVecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecLabelidxVecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecLabelidxCombinator>>, LabelidxVecMapper>;

pub struct LabelidxVecCombinator(pub LabelidxVecCombinatorAlias);

impl View for LabelidxVecCombinator {
    type V = SpecLabelidxVecCombinator;
    open spec fn view(&self) -> Self::V { SpecLabelidxVecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for LabelidxVecCombinator {
    type Type = LabelidxVec;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type LabelidxVecCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<LabelidxCombinator>, LabelidxVecCont0>, LabelidxVecMapper>;


pub open spec fn spec_labelidx_vec() -> SpecLabelidxVecCombinator {
    SpecLabelidxVecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_labelidx_vec_cont0(deps)),
        mapper: LabelidxVecMapper,
    })
}

pub open spec fn spec_labelidx_vec_cont0(deps: u64) -> RepeatN<SpecLabelidxCombinator> {
    let l = deps;
    RepeatN(spec_labelidx(), l.spec_into())
}

impl View for LabelidxVecCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecLabelidxCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_labelidx_vec_cont0(deps)
        }
    }
}

                
pub fn labelidx_vec<'a>() -> (o: LabelidxVecCombinator)
    ensures o@ == spec_labelidx_vec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = LabelidxVecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, LabelidxVecCont0),
        mapper: LabelidxVecMapper,
    });
    assert({
        &&& combinator@ == spec_labelidx_vec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_labelidx_vec<'a>(input: &'a [u8]) -> (res: PResult<<LabelidxVecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_labelidx_vec().spec_parse(input@) == Some((n as int, v@)),
        spec_labelidx_vec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_labelidx_vec().spec_parse(input@) is None,
        spec_labelidx_vec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = labelidx_vec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_labelidx_vec<'a>(v: <LabelidxVecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_labelidx_vec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_labelidx_vec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_labelidx_vec().spec_serialize(v@))
        },
{
    let combinator = labelidx_vec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn labelidx_vec_len<'a>(v: <LabelidxVecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_labelidx_vec().wf(v@),
        spec_labelidx_vec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_labelidx_vec().spec_serialize(v@).len(),
{
    let combinator = labelidx_vec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct LabelidxVecCont0;
type LabelidxVecCont0Type<'a, 'b> = &'b u64;
type LabelidxVecCont0SType<'a, 'x> = &'x u64;
type LabelidxVecCont0Input<'a, 'b, 'x> = POrSType<LabelidxVecCont0Type<'a, 'b>, LabelidxVecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<LabelidxVecCont0Input<'a, 'b, 'x>> for LabelidxVecCont0 {
    type Output = RepeatN<LabelidxCombinator>;

    open spec fn requires(&self, deps: LabelidxVecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: LabelidxVecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_labelidx_vec_cont0(deps@)
    }

    fn apply(&self, deps: LabelidxVecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(labelidx(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(labelidx(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecBrTable {
    pub l: SpecLabelidxVec,
    pub l_n: SpecLabelidx,
}

pub type SpecBrTableInner = (SpecLabelidxVec, SpecLabelidx);


impl SpecFrom<SpecBrTable> for SpecBrTableInner {
    open spec fn spec_from(m: SpecBrTable) -> SpecBrTableInner {
        (m.l, m.l_n)
    }
}

impl SpecFrom<SpecBrTableInner> for SpecBrTable {
    open spec fn spec_from(m: SpecBrTableInner) -> SpecBrTable {
        let (l, l_n) = m;
        SpecBrTable { l, l_n }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct BrTable {
    pub l: LabelidxVec,
    pub l_n: Labelidx,
}

impl View for BrTable {
    type V = SpecBrTable;

    open spec fn view(&self) -> Self::V {
        SpecBrTable {
            l: self.l@,
            l_n: self.l_n@,
        }
    }
}
pub type BrTableInner = (LabelidxVec, Labelidx);

pub type BrTableInnerRef<'a> = (&'a LabelidxVec, &'a Labelidx);
impl<'a> From<&'a BrTable> for BrTableInnerRef<'a> {
    fn ex_from(m: &'a BrTable) -> BrTableInnerRef<'a> {
        (&m.l, &m.l_n)
    }
}

impl From<BrTableInner> for BrTable {
    fn ex_from(m: BrTableInner) -> BrTable {
        let (l, l_n) = m;
        BrTable { l, l_n }
    }
}

pub struct BrTableMapper;
impl View for BrTableMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for BrTableMapper {
    type Src = SpecBrTableInner;
    type Dst = SpecBrTable;
}
impl SpecIsoProof for BrTableMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for BrTableMapper {
    type Src = BrTableInner;
    type Dst = BrTable;
    type RefSrc = BrTableInnerRef<'a>;
}
type SpecBrTableCombinatorAlias1 = (SpecLabelidxVecCombinator, SpecLabelidxCombinator);
pub struct SpecBrTableCombinator(pub SpecBrTableCombinatorAlias);

impl SpecCombinator for SpecBrTableCombinator {
    type Type = SpecBrTable;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecBrTableCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecBrTableCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecBrTableCombinatorAlias = Mapped<SpecBrTableCombinatorAlias1, BrTableMapper>;
type BrTableCombinatorAlias1 = (LabelidxVecCombinator, LabelidxCombinator);
pub struct BrTableCombinator1(pub BrTableCombinatorAlias1);
impl View for BrTableCombinator1 {
    type V = SpecBrTableCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(BrTableCombinator1, BrTableCombinatorAlias1);

pub struct BrTableCombinator(pub BrTableCombinatorAlias);

impl View for BrTableCombinator {
    type V = SpecBrTableCombinator;
    open spec fn view(&self) -> Self::V { SpecBrTableCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for BrTableCombinator {
    type Type = BrTable;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type BrTableCombinatorAlias = Mapped<BrTableCombinator1, BrTableMapper>;


pub open spec fn spec_br_table() -> SpecBrTableCombinator {
    SpecBrTableCombinator(
    Mapped {
        inner: (spec_labelidx_vec(), spec_labelidx()),
        mapper: BrTableMapper,
    })
}

                
pub fn br_table<'a>() -> (o: BrTableCombinator)
    ensures o@ == spec_br_table(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = BrTableCombinator(
    Mapped {
        inner: BrTableCombinator1((labelidx_vec(), labelidx())),
        mapper: BrTableMapper,
    });
    assert({
        &&& combinator@ == spec_br_table()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_br_table<'a>(input: &'a [u8]) -> (res: PResult<<BrTableCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_br_table().spec_parse(input@) == Some((n as int, v@)),
        spec_br_table().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_br_table().spec_parse(input@) is None,
        spec_br_table().spec_parse(input@) is None ==> res is Err,
{
    let combinator = br_table();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_br_table<'a>(v: <BrTableCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_br_table().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_br_table().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_br_table().spec_serialize(v@))
        },
{
    let combinator = br_table();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn br_table_len<'a>(v: <BrTableCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_br_table().wf(v@),
        spec_br_table().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_br_table().spec_serialize(v@).len(),
{
    let combinator = br_table();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecTableidx = u64;
pub type Tableidx = u64;
pub type TableidxRef<'a> = &'a u64;


pub struct SpecTableidxCombinator(pub SpecTableidxCombinatorAlias);

impl SpecCombinator for SpecTableidxCombinator {
    type Type = SpecTableidx;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTableidxCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTableidxCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTableidxCombinatorAlias = UnsignedLEB128;

pub struct TableidxCombinator(pub TableidxCombinatorAlias);

impl View for TableidxCombinator {
    type V = SpecTableidxCombinator;
    open spec fn view(&self) -> Self::V { SpecTableidxCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TableidxCombinator {
    type Type = Tableidx;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TableidxCombinatorAlias = UnsignedLEB128;


pub open spec fn spec_tableidx() -> SpecTableidxCombinator {
    SpecTableidxCombinator(UnsignedLEB128)
}

                
pub fn tableidx<'a>() -> (o: TableidxCombinator)
    ensures o@ == spec_tableidx(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TableidxCombinator(UnsignedLEB128);
    assert({
        &&& combinator@ == spec_tableidx()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_tableidx<'a>(input: &'a [u8]) -> (res: PResult<<TableidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_tableidx().spec_parse(input@) == Some((n as int, v@)),
        spec_tableidx().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_tableidx().spec_parse(input@) is None,
        spec_tableidx().spec_parse(input@) is None ==> res is Err,
{
    let combinator = tableidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_tableidx<'a>(v: <TableidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_tableidx().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_tableidx().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_tableidx().spec_serialize(v@))
        },
{
    let combinator = tableidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn tableidx_len<'a>(v: <TableidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_tableidx().wf(v@),
        spec_tableidx().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_tableidx().spec_serialize(v@).len(),
{
    let combinator = tableidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecCallIndirect {
    pub y: SpecTypeidx,
    pub x: SpecTableidx,
}

pub type SpecCallIndirectInner = (SpecTypeidx, SpecTableidx);


impl SpecFrom<SpecCallIndirect> for SpecCallIndirectInner {
    open spec fn spec_from(m: SpecCallIndirect) -> SpecCallIndirectInner {
        (m.y, m.x)
    }
}

impl SpecFrom<SpecCallIndirectInner> for SpecCallIndirect {
    open spec fn spec_from(m: SpecCallIndirectInner) -> SpecCallIndirect {
        let (y, x) = m;
        SpecCallIndirect { y, x }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct CallIndirect {
    pub y: Typeidx,
    pub x: Tableidx,
}

impl View for CallIndirect {
    type V = SpecCallIndirect;

    open spec fn view(&self) -> Self::V {
        SpecCallIndirect {
            y: self.y@,
            x: self.x@,
        }
    }
}
pub type CallIndirectInner = (Typeidx, Tableidx);

pub type CallIndirectInnerRef<'a> = (&'a Typeidx, &'a Tableidx);
impl<'a> From<&'a CallIndirect> for CallIndirectInnerRef<'a> {
    fn ex_from(m: &'a CallIndirect) -> CallIndirectInnerRef<'a> {
        (&m.y, &m.x)
    }
}

impl From<CallIndirectInner> for CallIndirect {
    fn ex_from(m: CallIndirectInner) -> CallIndirect {
        let (y, x) = m;
        CallIndirect { y, x }
    }
}

pub struct CallIndirectMapper;
impl View for CallIndirectMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for CallIndirectMapper {
    type Src = SpecCallIndirectInner;
    type Dst = SpecCallIndirect;
}
impl SpecIsoProof for CallIndirectMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for CallIndirectMapper {
    type Src = CallIndirectInner;
    type Dst = CallIndirect;
    type RefSrc = CallIndirectInnerRef<'a>;
}
type SpecCallIndirectCombinatorAlias1 = (SpecTypeidxCombinator, SpecTableidxCombinator);
pub struct SpecCallIndirectCombinator(pub SpecCallIndirectCombinatorAlias);

impl SpecCombinator for SpecCallIndirectCombinator {
    type Type = SpecCallIndirect;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecCallIndirectCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecCallIndirectCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecCallIndirectCombinatorAlias = Mapped<SpecCallIndirectCombinatorAlias1, CallIndirectMapper>;
type CallIndirectCombinatorAlias1 = (TypeidxCombinator, TableidxCombinator);
pub struct CallIndirectCombinator1(pub CallIndirectCombinatorAlias1);
impl View for CallIndirectCombinator1 {
    type V = SpecCallIndirectCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(CallIndirectCombinator1, CallIndirectCombinatorAlias1);

pub struct CallIndirectCombinator(pub CallIndirectCombinatorAlias);

impl View for CallIndirectCombinator {
    type V = SpecCallIndirectCombinator;
    open spec fn view(&self) -> Self::V { SpecCallIndirectCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for CallIndirectCombinator {
    type Type = CallIndirect;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type CallIndirectCombinatorAlias = Mapped<CallIndirectCombinator1, CallIndirectMapper>;


pub open spec fn spec_call_indirect() -> SpecCallIndirectCombinator {
    SpecCallIndirectCombinator(
    Mapped {
        inner: (spec_typeidx(), spec_tableidx()),
        mapper: CallIndirectMapper,
    })
}

                
pub fn call_indirect<'a>() -> (o: CallIndirectCombinator)
    ensures o@ == spec_call_indirect(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = CallIndirectCombinator(
    Mapped {
        inner: CallIndirectCombinator1((typeidx(), tableidx())),
        mapper: CallIndirectMapper,
    });
    assert({
        &&& combinator@ == spec_call_indirect()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_call_indirect<'a>(input: &'a [u8]) -> (res: PResult<<CallIndirectCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_call_indirect().spec_parse(input@) == Some((n as int, v@)),
        spec_call_indirect().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_call_indirect().spec_parse(input@) is None,
        spec_call_indirect().spec_parse(input@) is None ==> res is Err,
{
    let combinator = call_indirect();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_call_indirect<'a>(v: <CallIndirectCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_call_indirect().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_call_indirect().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_call_indirect().spec_serialize(v@))
        },
{
    let combinator = call_indirect();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn call_indirect_len<'a>(v: <CallIndirectCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_call_indirect().wf(v@),
        spec_call_indirect().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_call_indirect().spec_serialize(v@).len(),
{
    let combinator = call_indirect();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub enum SpecInstrControl2 {
    End(SpecEmpty),
    BrIf(SpecLabelidx),
    Br(SpecLabelidx),
    Call(SpecFuncidx),
    Ret(SpecEmpty),
    BrTable(SpecBrTable),
    CallIndirect(SpecCallIndirect),
}

pub type SpecInstrControl2Inner = Either<SpecEmpty, Either<SpecLabelidx, Either<SpecLabelidx, Either<SpecFuncidx, Either<SpecEmpty, Either<SpecBrTable, SpecCallIndirect>>>>>>;

impl SpecFrom<SpecInstrControl2> for SpecInstrControl2Inner {
    open spec fn spec_from(m: SpecInstrControl2) -> SpecInstrControl2Inner {
        match m {
            SpecInstrControl2::End(m) => Either::Left(m),
            SpecInstrControl2::BrIf(m) => Either::Right(Either::Left(m)),
            SpecInstrControl2::Br(m) => Either::Right(Either::Right(Either::Left(m))),
            SpecInstrControl2::Call(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            SpecInstrControl2::Ret(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            SpecInstrControl2::BrTable(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))),
            SpecInstrControl2::CallIndirect(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))),
        }
    }

}

                
impl SpecFrom<SpecInstrControl2Inner> for SpecInstrControl2 {
    open spec fn spec_from(m: SpecInstrControl2Inner) -> SpecInstrControl2 {
        match m {
            Either::Left(m) => SpecInstrControl2::End(m),
            Either::Right(Either::Left(m)) => SpecInstrControl2::BrIf(m),
            Either::Right(Either::Right(Either::Left(m))) => SpecInstrControl2::Br(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => SpecInstrControl2::Call(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => SpecInstrControl2::Ret(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))) => SpecInstrControl2::BrTable(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))) => SpecInstrControl2::CallIndirect(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InstrControl2<'a> {
    End(Empty<'a>),
    BrIf(Labelidx),
    Br(Labelidx),
    Call(Funcidx),
    Ret(Empty<'a>),
    BrTable(BrTable),
    CallIndirect(CallIndirect),
}

pub type InstrControl2Inner<'a> = Either<Empty<'a>, Either<Labelidx, Either<Labelidx, Either<Funcidx, Either<Empty<'a>, Either<BrTable, CallIndirect>>>>>>;

pub type InstrControl2InnerRef<'a> = Either<&'a Empty<'a>, Either<&'a Labelidx, Either<&'a Labelidx, Either<&'a Funcidx, Either<&'a Empty<'a>, Either<&'a BrTable, &'a CallIndirect>>>>>>;


impl<'a> View for InstrControl2<'a> {
    type V = SpecInstrControl2;
    open spec fn view(&self) -> Self::V {
        match self {
            InstrControl2::End(m) => SpecInstrControl2::End(m@),
            InstrControl2::BrIf(m) => SpecInstrControl2::BrIf(m@),
            InstrControl2::Br(m) => SpecInstrControl2::Br(m@),
            InstrControl2::Call(m) => SpecInstrControl2::Call(m@),
            InstrControl2::Ret(m) => SpecInstrControl2::Ret(m@),
            InstrControl2::BrTable(m) => SpecInstrControl2::BrTable(m@),
            InstrControl2::CallIndirect(m) => SpecInstrControl2::CallIndirect(m@),
        }
    }
}


impl<'a> From<&'a InstrControl2<'a>> for InstrControl2InnerRef<'a> {
    fn ex_from(m: &'a InstrControl2<'a>) -> InstrControl2InnerRef<'a> {
        match m {
            InstrControl2::End(m) => Either::Left(m),
            InstrControl2::BrIf(m) => Either::Right(Either::Left(m)),
            InstrControl2::Br(m) => Either::Right(Either::Right(Either::Left(m))),
            InstrControl2::Call(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            InstrControl2::Ret(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            InstrControl2::BrTable(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))),
            InstrControl2::CallIndirect(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))),
        }
    }

}

impl<'a> From<InstrControl2Inner<'a>> for InstrControl2<'a> {
    fn ex_from(m: InstrControl2Inner<'a>) -> InstrControl2<'a> {
        match m {
            Either::Left(m) => InstrControl2::End(m),
            Either::Right(Either::Left(m)) => InstrControl2::BrIf(m),
            Either::Right(Either::Right(Either::Left(m))) => InstrControl2::Br(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => InstrControl2::Call(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => InstrControl2::Ret(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))) => InstrControl2::BrTable(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))) => InstrControl2::CallIndirect(m),
        }
    }
    
}


pub struct InstrControl2Mapper;
impl View for InstrControl2Mapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrControl2Mapper {
    type Src = SpecInstrControl2Inner;
    type Dst = SpecInstrControl2;
}
impl SpecIsoProof for InstrControl2Mapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrControl2Mapper {
    type Src = InstrControl2Inner<'a>;
    type Dst = InstrControl2<'a>;
    type RefSrc = InstrControl2InnerRef<'a>;
}

type SpecInstrControl2CombinatorAlias1 = Choice<Cond<SpecBrTableCombinator>, Cond<SpecCallIndirectCombinator>>;
type SpecInstrControl2CombinatorAlias2 = Choice<Cond<SpecEmptyCombinator>, SpecInstrControl2CombinatorAlias1>;
type SpecInstrControl2CombinatorAlias3 = Choice<Cond<SpecFuncidxCombinator>, SpecInstrControl2CombinatorAlias2>;
type SpecInstrControl2CombinatorAlias4 = Choice<Cond<SpecLabelidxCombinator>, SpecInstrControl2CombinatorAlias3>;
type SpecInstrControl2CombinatorAlias5 = Choice<Cond<SpecLabelidxCombinator>, SpecInstrControl2CombinatorAlias4>;
type SpecInstrControl2CombinatorAlias6 = Choice<Cond<SpecEmptyCombinator>, SpecInstrControl2CombinatorAlias5>;
pub struct SpecInstrControl2Combinator(pub SpecInstrControl2CombinatorAlias);

impl SpecCombinator for SpecInstrControl2Combinator {
    type Type = SpecInstrControl2;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrControl2Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrControl2CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrControl2CombinatorAlias = Mapped<SpecInstrControl2CombinatorAlias6, InstrControl2Mapper>;
type InstrControl2CombinatorAlias1 = Choice<Cond<BrTableCombinator>, Cond<CallIndirectCombinator>>;
type InstrControl2CombinatorAlias2 = Choice<Cond<EmptyCombinator>, InstrControl2Combinator1>;
type InstrControl2CombinatorAlias3 = Choice<Cond<FuncidxCombinator>, InstrControl2Combinator2>;
type InstrControl2CombinatorAlias4 = Choice<Cond<LabelidxCombinator>, InstrControl2Combinator3>;
type InstrControl2CombinatorAlias5 = Choice<Cond<LabelidxCombinator>, InstrControl2Combinator4>;
type InstrControl2CombinatorAlias6 = Choice<Cond<EmptyCombinator>, InstrControl2Combinator5>;
pub struct InstrControl2Combinator1(pub InstrControl2CombinatorAlias1);
impl View for InstrControl2Combinator1 {
    type V = SpecInstrControl2CombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrControl2Combinator1, InstrControl2CombinatorAlias1);

pub struct InstrControl2Combinator2(pub InstrControl2CombinatorAlias2);
impl View for InstrControl2Combinator2 {
    type V = SpecInstrControl2CombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrControl2Combinator2, InstrControl2CombinatorAlias2);

pub struct InstrControl2Combinator3(pub InstrControl2CombinatorAlias3);
impl View for InstrControl2Combinator3 {
    type V = SpecInstrControl2CombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrControl2Combinator3, InstrControl2CombinatorAlias3);

pub struct InstrControl2Combinator4(pub InstrControl2CombinatorAlias4);
impl View for InstrControl2Combinator4 {
    type V = SpecInstrControl2CombinatorAlias4;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrControl2Combinator4, InstrControl2CombinatorAlias4);

pub struct InstrControl2Combinator5(pub InstrControl2CombinatorAlias5);
impl View for InstrControl2Combinator5 {
    type V = SpecInstrControl2CombinatorAlias5;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrControl2Combinator5, InstrControl2CombinatorAlias5);

pub struct InstrControl2Combinator6(pub InstrControl2CombinatorAlias6);
impl View for InstrControl2Combinator6 {
    type V = SpecInstrControl2CombinatorAlias6;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrControl2Combinator6, InstrControl2CombinatorAlias6);

pub struct InstrControl2Combinator(pub InstrControl2CombinatorAlias);

impl View for InstrControl2Combinator {
    type V = SpecInstrControl2Combinator;
    open spec fn view(&self) -> Self::V { SpecInstrControl2Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrControl2Combinator {
    type Type = InstrControl2<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrControl2CombinatorAlias = Mapped<InstrControl2Combinator6, InstrControl2Mapper>;


pub open spec fn spec_instr_control2(opcode: u8) -> SpecInstrControl2Combinator {
    SpecInstrControl2Combinator(Mapped { inner: Choice(Cond { cond: opcode == InstrBytecode::SPEC_End, inner: spec_empty() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_BrIf, inner: spec_labelidx() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_Br, inner: spec_labelidx() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_Call, inner: spec_funcidx() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_Ret, inner: spec_empty() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_BrTable, inner: spec_br_table() }, Cond { cond: opcode == InstrBytecode::SPEC_CallIndirect, inner: spec_call_indirect() })))))), mapper: InstrControl2Mapper })
}

pub fn instr_control2<'a>(opcode: u8) -> (o: InstrControl2Combinator)
    ensures o@ == spec_instr_control2(opcode@),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrControl2Combinator(Mapped { inner: InstrControl2Combinator6(Choice::new(Cond { cond: opcode == InstrBytecode::End, inner: empty() }, InstrControl2Combinator5(Choice::new(Cond { cond: opcode == InstrBytecode::BrIf, inner: labelidx() }, InstrControl2Combinator4(Choice::new(Cond { cond: opcode == InstrBytecode::Br, inner: labelidx() }, InstrControl2Combinator3(Choice::new(Cond { cond: opcode == InstrBytecode::Call, inner: funcidx() }, InstrControl2Combinator2(Choice::new(Cond { cond: opcode == InstrBytecode::Ret, inner: empty() }, InstrControl2Combinator1(Choice::new(Cond { cond: opcode == InstrBytecode::BrTable, inner: br_table() }, Cond { cond: opcode == InstrBytecode::CallIndirect, inner: call_indirect() })))))))))))), mapper: InstrControl2Mapper });
    assert({
        &&& combinator@ == spec_instr_control2(opcode@)
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_control2<'a>(input: &'a [u8], opcode: u8) -> (res: PResult<<InstrControl2Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_control2(opcode@).spec_parse(input@) == Some((n as int, v@)),
        spec_instr_control2(opcode@).spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_control2(opcode@).spec_parse(input@) is None,
        spec_instr_control2(opcode@).spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_control2( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_control2<'a>(v: <InstrControl2Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize, opcode: u8) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_control2(opcode@).wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_control2(opcode@).spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_control2(opcode@).spec_serialize(v@))
        },
{
    let combinator = instr_control2( opcode );
    combinator.serialize(v, data, pos)
}

pub fn instr_control2_len<'a>(v: <InstrControl2Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, opcode: u8) -> (serialize_len: usize)
    requires
        spec_instr_control2(opcode@).wf(v@),
        spec_instr_control2(opcode@).spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_control2(opcode@).spec_serialize(v@).len(),
{
    let combinator = instr_control2( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}


pub struct SpecEmptyBlock {
    pub tag: u8,
    pub body: SpecEmpty,
}

pub type SpecEmptyBlockInner = (u8, SpecEmpty);


impl SpecFrom<SpecEmptyBlock> for SpecEmptyBlockInner {
    open spec fn spec_from(m: SpecEmptyBlock) -> SpecEmptyBlockInner {
        (m.tag, m.body)
    }
}

impl SpecFrom<SpecEmptyBlockInner> for SpecEmptyBlock {
    open spec fn spec_from(m: SpecEmptyBlockInner) -> SpecEmptyBlock {
        let (tag, body) = m;
        SpecEmptyBlock { tag, body }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct EmptyBlock<'a> {
    pub tag: u8,
    pub body: Empty<'a>,
}

impl View for EmptyBlock<'_> {
    type V = SpecEmptyBlock;

    open spec fn view(&self) -> Self::V {
        SpecEmptyBlock {
            tag: self.tag@,
            body: self.body@,
        }
    }
}
pub type EmptyBlockInner<'a> = (u8, Empty<'a>);

pub type EmptyBlockInnerRef<'a> = (&'a u8, &'a Empty<'a>);
impl<'a> From<&'a EmptyBlock<'a>> for EmptyBlockInnerRef<'a> {
    fn ex_from(m: &'a EmptyBlock) -> EmptyBlockInnerRef<'a> {
        (&m.tag, &m.body)
    }
}

impl<'a> From<EmptyBlockInner<'a>> for EmptyBlock<'a> {
    fn ex_from(m: EmptyBlockInner) -> EmptyBlock {
        let (tag, body) = m;
        EmptyBlock { tag, body }
    }
}

pub struct EmptyBlockMapper;
impl View for EmptyBlockMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for EmptyBlockMapper {
    type Src = SpecEmptyBlockInner;
    type Dst = SpecEmptyBlock;
}
impl SpecIsoProof for EmptyBlockMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for EmptyBlockMapper {
    type Src = EmptyBlockInner<'a>;
    type Dst = EmptyBlock<'a>;
    type RefSrc = EmptyBlockInnerRef<'a>;
}
type SpecEmptyBlockCombinatorAlias1 = (Refined<U8, Predicate16713707613369419146>, SpecEmptyCombinator);
pub struct SpecEmptyBlockCombinator(pub SpecEmptyBlockCombinatorAlias);

impl SpecCombinator for SpecEmptyBlockCombinator {
    type Type = SpecEmptyBlock;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecEmptyBlockCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecEmptyBlockCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecEmptyBlockCombinatorAlias = Mapped<SpecEmptyBlockCombinatorAlias1, EmptyBlockMapper>;
pub struct Predicate16713707613369419146;
impl View for Predicate16713707613369419146 {
    type V = Self;

    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl Pred<u8> for Predicate16713707613369419146 {
    fn apply(&self, i: &u8) -> bool {
        let i = (*i);
        (i == 64)
    }
}
impl SpecPred<u8> for Predicate16713707613369419146 {
    open spec fn spec_apply(&self, i: &u8) -> bool {
        let i = (*i);
        (i == 64)
    }
}
type EmptyBlockCombinatorAlias1 = (Refined<U8, Predicate16713707613369419146>, EmptyCombinator);
pub struct EmptyBlockCombinator1(pub EmptyBlockCombinatorAlias1);
impl View for EmptyBlockCombinator1 {
    type V = SpecEmptyBlockCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(EmptyBlockCombinator1, EmptyBlockCombinatorAlias1);

pub struct EmptyBlockCombinator(pub EmptyBlockCombinatorAlias);

impl View for EmptyBlockCombinator {
    type V = SpecEmptyBlockCombinator;
    open spec fn view(&self) -> Self::V { SpecEmptyBlockCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for EmptyBlockCombinator {
    type Type = EmptyBlock<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type EmptyBlockCombinatorAlias = Mapped<EmptyBlockCombinator1, EmptyBlockMapper>;


pub open spec fn spec_empty_block() -> SpecEmptyBlockCombinator {
    SpecEmptyBlockCombinator(
    Mapped {
        inner: (Refined { inner: U8, predicate: Predicate16713707613369419146 }, spec_empty()),
        mapper: EmptyBlockMapper,
    })
}

                
pub fn empty_block<'a>() -> (o: EmptyBlockCombinator)
    ensures o@ == spec_empty_block(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = EmptyBlockCombinator(
    Mapped {
        inner: EmptyBlockCombinator1((Refined { inner: U8, predicate: Predicate16713707613369419146 }, empty())),
        mapper: EmptyBlockMapper,
    });
    assert({
        &&& combinator@ == spec_empty_block()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_empty_block<'a>(input: &'a [u8]) -> (res: PResult<<EmptyBlockCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_empty_block().spec_parse(input@) == Some((n as int, v@)),
        spec_empty_block().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_empty_block().spec_parse(input@) is None,
        spec_empty_block().spec_parse(input@) is None ==> res is Err,
{
    let combinator = empty_block();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_empty_block<'a>(v: <EmptyBlockCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_empty_block().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_empty_block().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_empty_block().spec_serialize(v@))
        },
{
    let combinator = empty_block();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn empty_block_len<'a>(v: <EmptyBlockCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_empty_block().wf(v@),
        spec_empty_block().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_empty_block().spec_serialize(v@).len(),
{
    let combinator = empty_block();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecValtypeBlock {
    pub tag: u8,
    pub body: SpecEmpty,
}

pub type SpecValtypeBlockInner = (u8, SpecEmpty);


impl SpecFrom<SpecValtypeBlock> for SpecValtypeBlockInner {
    open spec fn spec_from(m: SpecValtypeBlock) -> SpecValtypeBlockInner {
        (m.tag, m.body)
    }
}

impl SpecFrom<SpecValtypeBlockInner> for SpecValtypeBlock {
    open spec fn spec_from(m: SpecValtypeBlockInner) -> SpecValtypeBlock {
        let (tag, body) = m;
        SpecValtypeBlock { tag, body }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ValtypeBlock<'a> {
    pub tag: u8,
    pub body: Empty<'a>,
}

impl View for ValtypeBlock<'_> {
    type V = SpecValtypeBlock;

    open spec fn view(&self) -> Self::V {
        SpecValtypeBlock {
            tag: self.tag@,
            body: self.body@,
        }
    }
}
pub type ValtypeBlockInner<'a> = (u8, Empty<'a>);

pub type ValtypeBlockInnerRef<'a> = (&'a u8, &'a Empty<'a>);
impl<'a> From<&'a ValtypeBlock<'a>> for ValtypeBlockInnerRef<'a> {
    fn ex_from(m: &'a ValtypeBlock) -> ValtypeBlockInnerRef<'a> {
        (&m.tag, &m.body)
    }
}

impl<'a> From<ValtypeBlockInner<'a>> for ValtypeBlock<'a> {
    fn ex_from(m: ValtypeBlockInner) -> ValtypeBlock {
        let (tag, body) = m;
        ValtypeBlock { tag, body }
    }
}

pub struct ValtypeBlockMapper;
impl View for ValtypeBlockMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ValtypeBlockMapper {
    type Src = SpecValtypeBlockInner;
    type Dst = SpecValtypeBlock;
}
impl SpecIsoProof for ValtypeBlockMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ValtypeBlockMapper {
    type Src = ValtypeBlockInner<'a>;
    type Dst = ValtypeBlock<'a>;
    type RefSrc = ValtypeBlockInnerRef<'a>;
}
type SpecValtypeBlockCombinatorAlias1 = (Refined<U8, Predicate17051755724411564727>, SpecEmptyCombinator);
pub struct SpecValtypeBlockCombinator(pub SpecValtypeBlockCombinatorAlias);

impl SpecCombinator for SpecValtypeBlockCombinator {
    type Type = SpecValtypeBlock;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecValtypeBlockCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecValtypeBlockCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecValtypeBlockCombinatorAlias = Mapped<SpecValtypeBlockCombinatorAlias1, ValtypeBlockMapper>;
pub struct Predicate17051755724411564727;
impl View for Predicate17051755724411564727 {
    type V = Self;

    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl Pred<u8> for Predicate17051755724411564727 {
    fn apply(&self, i: &u8) -> bool {
        let i = (*i);
        (i == 123) || (i == 124) || (i == 125) || (i == 126) || (i == 127) || (i == 111) || (i == 112)
    }
}
impl SpecPred<u8> for Predicate17051755724411564727 {
    open spec fn spec_apply(&self, i: &u8) -> bool {
        let i = (*i);
        (i == 123) || (i == 124) || (i == 125) || (i == 126) || (i == 127) || (i == 111) || (i == 112)
    }
}
type ValtypeBlockCombinatorAlias1 = (Refined<U8, Predicate17051755724411564727>, EmptyCombinator);
pub struct ValtypeBlockCombinator1(pub ValtypeBlockCombinatorAlias1);
impl View for ValtypeBlockCombinator1 {
    type V = SpecValtypeBlockCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ValtypeBlockCombinator1, ValtypeBlockCombinatorAlias1);

pub struct ValtypeBlockCombinator(pub ValtypeBlockCombinatorAlias);

impl View for ValtypeBlockCombinator {
    type V = SpecValtypeBlockCombinator;
    open spec fn view(&self) -> Self::V { SpecValtypeBlockCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ValtypeBlockCombinator {
    type Type = ValtypeBlock<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ValtypeBlockCombinatorAlias = Mapped<ValtypeBlockCombinator1, ValtypeBlockMapper>;


pub open spec fn spec_valtype_block() -> SpecValtypeBlockCombinator {
    SpecValtypeBlockCombinator(
    Mapped {
        inner: (Refined { inner: U8, predicate: Predicate17051755724411564727 }, spec_empty()),
        mapper: ValtypeBlockMapper,
    })
}

                
pub fn valtype_block<'a>() -> (o: ValtypeBlockCombinator)
    ensures o@ == spec_valtype_block(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ValtypeBlockCombinator(
    Mapped {
        inner: ValtypeBlockCombinator1((Refined { inner: U8, predicate: Predicate17051755724411564727 }, empty())),
        mapper: ValtypeBlockMapper,
    });
    assert({
        &&& combinator@ == spec_valtype_block()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_valtype_block<'a>(input: &'a [u8]) -> (res: PResult<<ValtypeBlockCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_valtype_block().spec_parse(input@) == Some((n as int, v@)),
        spec_valtype_block().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_valtype_block().spec_parse(input@) is None,
        spec_valtype_block().spec_parse(input@) is None ==> res is Err,
{
    let combinator = valtype_block();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_valtype_block<'a>(v: <ValtypeBlockCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_valtype_block().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_valtype_block().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_valtype_block().spec_serialize(v@))
        },
{
    let combinator = valtype_block();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn valtype_block_len<'a>(v: <ValtypeBlockCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_valtype_block().wf(v@),
        spec_valtype_block().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_valtype_block().spec_serialize(v@).len(),
{
    let combinator = valtype_block();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecTypeidxBlock {
    pub tag: u8,
    pub body: u64,
}

pub type SpecTypeidxBlockInner = (u8, u64);


impl SpecFrom<SpecTypeidxBlock> for SpecTypeidxBlockInner {
    open spec fn spec_from(m: SpecTypeidxBlock) -> SpecTypeidxBlockInner {
        (m.tag, m.body)
    }
}

impl SpecFrom<SpecTypeidxBlockInner> for SpecTypeidxBlock {
    open spec fn spec_from(m: SpecTypeidxBlockInner) -> SpecTypeidxBlock {
        let (tag, body) = m;
        SpecTypeidxBlock { tag, body }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct TypeidxBlock {
    pub tag: u8,
    pub body: u64,
}

impl View for TypeidxBlock {
    type V = SpecTypeidxBlock;

    open spec fn view(&self) -> Self::V {
        SpecTypeidxBlock {
            tag: self.tag@,
            body: self.body@,
        }
    }
}
pub type TypeidxBlockInner = (u8, u64);

pub type TypeidxBlockInnerRef<'a> = (&'a u8, &'a u64);
impl<'a> From<&'a TypeidxBlock> for TypeidxBlockInnerRef<'a> {
    fn ex_from(m: &'a TypeidxBlock) -> TypeidxBlockInnerRef<'a> {
        (&m.tag, &m.body)
    }
}

impl From<TypeidxBlockInner> for TypeidxBlock {
    fn ex_from(m: TypeidxBlockInner) -> TypeidxBlock {
        let (tag, body) = m;
        TypeidxBlock { tag, body }
    }
}

pub struct TypeidxBlockMapper;
impl View for TypeidxBlockMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for TypeidxBlockMapper {
    type Src = SpecTypeidxBlockInner;
    type Dst = SpecTypeidxBlock;
}
impl SpecIsoProof for TypeidxBlockMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for TypeidxBlockMapper {
    type Src = TypeidxBlockInner;
    type Dst = TypeidxBlock;
    type RefSrc = TypeidxBlockInnerRef<'a>;
}
type SpecTypeidxBlockCombinatorAlias1 = (Refined<U8, Predicate2396169508742552609>, UnsignedLEB128);
pub struct SpecTypeidxBlockCombinator(pub SpecTypeidxBlockCombinatorAlias);

impl SpecCombinator for SpecTypeidxBlockCombinator {
    type Type = SpecTypeidxBlock;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTypeidxBlockCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTypeidxBlockCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTypeidxBlockCombinatorAlias = Mapped<SpecTypeidxBlockCombinatorAlias1, TypeidxBlockMapper>;
pub struct Predicate2396169508742552609;
impl View for Predicate2396169508742552609 {
    type V = Self;

    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl Pred<u8> for Predicate2396169508742552609 {
    fn apply(&self, i: &u8) -> bool {
        let i = (*i);
        !((i == 64) || (i == 123) || (i == 124) || (i == 125) || (i == 126) || (i == 127) || (i == 111) || (i == 112))
    }
}
impl SpecPred<u8> for Predicate2396169508742552609 {
    open spec fn spec_apply(&self, i: &u8) -> bool {
        let i = (*i);
        !((i == 64) || (i == 123) || (i == 124) || (i == 125) || (i == 126) || (i == 127) || (i == 111) || (i == 112))
    }
}
type TypeidxBlockCombinatorAlias1 = (Refined<U8, Predicate2396169508742552609>, UnsignedLEB128);
pub struct TypeidxBlockCombinator1(pub TypeidxBlockCombinatorAlias1);
impl View for TypeidxBlockCombinator1 {
    type V = SpecTypeidxBlockCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(TypeidxBlockCombinator1, TypeidxBlockCombinatorAlias1);

pub struct TypeidxBlockCombinator(pub TypeidxBlockCombinatorAlias);

impl View for TypeidxBlockCombinator {
    type V = SpecTypeidxBlockCombinator;
    open spec fn view(&self) -> Self::V { SpecTypeidxBlockCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TypeidxBlockCombinator {
    type Type = TypeidxBlock;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TypeidxBlockCombinatorAlias = Mapped<TypeidxBlockCombinator1, TypeidxBlockMapper>;


pub open spec fn spec_typeidx_block() -> SpecTypeidxBlockCombinator {
    SpecTypeidxBlockCombinator(
    Mapped {
        inner: (Refined { inner: U8, predicate: Predicate2396169508742552609 }, UnsignedLEB128),
        mapper: TypeidxBlockMapper,
    })
}

                
pub fn typeidx_block<'a>() -> (o: TypeidxBlockCombinator)
    ensures o@ == spec_typeidx_block(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TypeidxBlockCombinator(
    Mapped {
        inner: TypeidxBlockCombinator1((Refined { inner: U8, predicate: Predicate2396169508742552609 }, UnsignedLEB128)),
        mapper: TypeidxBlockMapper,
    });
    assert({
        &&& combinator@ == spec_typeidx_block()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_typeidx_block<'a>(input: &'a [u8]) -> (res: PResult<<TypeidxBlockCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_typeidx_block().spec_parse(input@) == Some((n as int, v@)),
        spec_typeidx_block().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_typeidx_block().spec_parse(input@) is None,
        spec_typeidx_block().spec_parse(input@) is None ==> res is Err,
{
    let combinator = typeidx_block();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_typeidx_block<'a>(v: <TypeidxBlockCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_typeidx_block().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_typeidx_block().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_typeidx_block().spec_serialize(v@))
        },
{
    let combinator = typeidx_block();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn typeidx_block_len<'a>(v: <TypeidxBlockCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_typeidx_block().wf(v@),
        spec_typeidx_block().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_typeidx_block().spec_serialize(v@).len(),
{
    let combinator = typeidx_block();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub enum SpecBlocktype {
    Empty(SpecEmptyBlock),
    ValType(SpecValtypeBlock),
    TypeIdx(SpecTypeidxBlock),
}

pub type SpecBlocktypeInner = Either<SpecEmptyBlock, Either<SpecValtypeBlock, SpecTypeidxBlock>>;

impl SpecFrom<SpecBlocktype> for SpecBlocktypeInner {
    open spec fn spec_from(m: SpecBlocktype) -> SpecBlocktypeInner {
        match m {
            SpecBlocktype::Empty(m) => Either::Left(m),
            SpecBlocktype::ValType(m) => Either::Right(Either::Left(m)),
            SpecBlocktype::TypeIdx(m) => Either::Right(Either::Right(m)),
        }
    }

}

                
impl SpecFrom<SpecBlocktypeInner> for SpecBlocktype {
    open spec fn spec_from(m: SpecBlocktypeInner) -> SpecBlocktype {
        match m {
            Either::Left(m) => SpecBlocktype::Empty(m),
            Either::Right(Either::Left(m)) => SpecBlocktype::ValType(m),
            Either::Right(Either::Right(m)) => SpecBlocktype::TypeIdx(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Blocktype<'a> {
    Empty(EmptyBlock<'a>),
    ValType(ValtypeBlock<'a>),
    TypeIdx(TypeidxBlock),
}

pub type BlocktypeInner<'a> = Either<EmptyBlock<'a>, Either<ValtypeBlock<'a>, TypeidxBlock>>;

pub type BlocktypeInnerRef<'a> = Either<&'a EmptyBlock<'a>, Either<&'a ValtypeBlock<'a>, &'a TypeidxBlock>>;


impl<'a> View for Blocktype<'a> {
    type V = SpecBlocktype;
    open spec fn view(&self) -> Self::V {
        match self {
            Blocktype::Empty(m) => SpecBlocktype::Empty(m@),
            Blocktype::ValType(m) => SpecBlocktype::ValType(m@),
            Blocktype::TypeIdx(m) => SpecBlocktype::TypeIdx(m@),
        }
    }
}


impl<'a> From<&'a Blocktype<'a>> for BlocktypeInnerRef<'a> {
    fn ex_from(m: &'a Blocktype<'a>) -> BlocktypeInnerRef<'a> {
        match m {
            Blocktype::Empty(m) => Either::Left(m),
            Blocktype::ValType(m) => Either::Right(Either::Left(m)),
            Blocktype::TypeIdx(m) => Either::Right(Either::Right(m)),
        }
    }

}

impl<'a> From<BlocktypeInner<'a>> for Blocktype<'a> {
    fn ex_from(m: BlocktypeInner<'a>) -> Blocktype<'a> {
        match m {
            Either::Left(m) => Blocktype::Empty(m),
            Either::Right(Either::Left(m)) => Blocktype::ValType(m),
            Either::Right(Either::Right(m)) => Blocktype::TypeIdx(m),
        }
    }
    
}


pub struct BlocktypeMapper;
impl View for BlocktypeMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for BlocktypeMapper {
    type Src = SpecBlocktypeInner;
    type Dst = SpecBlocktype;
}
impl SpecIsoProof for BlocktypeMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for BlocktypeMapper {
    type Src = BlocktypeInner<'a>;
    type Dst = Blocktype<'a>;
    type RefSrc = BlocktypeInnerRef<'a>;
}

type SpecBlocktypeCombinatorAlias1 = Choice<SpecValtypeBlockCombinator, SpecTypeidxBlockCombinator>;
type SpecBlocktypeCombinatorAlias2 = Choice<SpecEmptyBlockCombinator, SpecBlocktypeCombinatorAlias1>;
impl DisjointFrom<SpecEmptyBlockCombinator> for SpecValtypeBlockCombinator {
    closed spec fn disjoint_from(&self, other: &SpecEmptyBlockCombinator) -> bool
    { self.0.disjoint_from(&other.0) }
    proof fn parse_disjoint_on(&self, other: &SpecEmptyBlockCombinator, buf: Seq<u8>) 
    { self.0.parse_disjoint_on(&other.0, buf); }
}

impl DisjointFrom<SpecEmptyBlockCombinator> for SpecTypeidxBlockCombinator {
    closed spec fn disjoint_from(&self, other: &SpecEmptyBlockCombinator) -> bool
    { self.0.disjoint_from(&other.0) }
    proof fn parse_disjoint_on(&self, other: &SpecEmptyBlockCombinator, buf: Seq<u8>) 
    { self.0.parse_disjoint_on(&other.0, buf); }
}

impl DisjointFrom<SpecValtypeBlockCombinator> for SpecTypeidxBlockCombinator {
    closed spec fn disjoint_from(&self, other: &SpecValtypeBlockCombinator) -> bool
    { self.0.disjoint_from(&other.0) }
    proof fn parse_disjoint_on(&self, other: &SpecValtypeBlockCombinator, buf: Seq<u8>) 
    { self.0.parse_disjoint_on(&other.0, buf); }
}
pub struct SpecBlocktypeCombinator(pub SpecBlocktypeCombinatorAlias);

impl SpecCombinator for SpecBlocktypeCombinator {
    type Type = SpecBlocktype;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecBlocktypeCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecBlocktypeCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecBlocktypeCombinatorAlias = Mapped<SpecBlocktypeCombinatorAlias2, BlocktypeMapper>;
type BlocktypeCombinatorAlias1 = Choice<ValtypeBlockCombinator, TypeidxBlockCombinator>;
type BlocktypeCombinatorAlias2 = Choice<EmptyBlockCombinator, BlocktypeCombinator1>;
pub struct BlocktypeCombinator1(pub BlocktypeCombinatorAlias1);
impl View for BlocktypeCombinator1 {
    type V = SpecBlocktypeCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(BlocktypeCombinator1, BlocktypeCombinatorAlias1);

pub struct BlocktypeCombinator2(pub BlocktypeCombinatorAlias2);
impl View for BlocktypeCombinator2 {
    type V = SpecBlocktypeCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(BlocktypeCombinator2, BlocktypeCombinatorAlias2);

pub struct BlocktypeCombinator(pub BlocktypeCombinatorAlias);

impl View for BlocktypeCombinator {
    type V = SpecBlocktypeCombinator;
    open spec fn view(&self) -> Self::V { SpecBlocktypeCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for BlocktypeCombinator {
    type Type = Blocktype<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type BlocktypeCombinatorAlias = Mapped<BlocktypeCombinator2, BlocktypeMapper>;


pub open spec fn spec_blocktype() -> SpecBlocktypeCombinator {
    SpecBlocktypeCombinator(Mapped { inner: Choice(spec_empty_block(), Choice(spec_valtype_block(), spec_typeidx_block())), mapper: BlocktypeMapper })
}

                
pub fn blocktype<'a>() -> (o: BlocktypeCombinator)
    ensures o@ == spec_blocktype(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = BlocktypeCombinator(Mapped { inner: BlocktypeCombinator2(Choice::new(empty_block(), BlocktypeCombinator1(Choice::new(valtype_block(), typeidx_block())))), mapper: BlocktypeMapper });
    assert({
        &&& combinator@ == spec_blocktype()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_blocktype<'a>(input: &'a [u8]) -> (res: PResult<<BlocktypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_blocktype().spec_parse(input@) == Some((n as int, v@)),
        spec_blocktype().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_blocktype().spec_parse(input@) is None,
        spec_blocktype().spec_parse(input@) is None ==> res is Err,
{
    let combinator = blocktype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_blocktype<'a>(v: <BlocktypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_blocktype().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_blocktype().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_blocktype().spec_serialize(v@))
        },
{
    let combinator = blocktype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn blocktype_len<'a>(v: <BlocktypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_blocktype().wf(v@),
        spec_blocktype().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_blocktype().spec_serialize(v@).len(),
{
    let combinator = blocktype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub enum SpecInstrControl1 {
    If(SpecBlocktype),
    Block(SpecBlocktype),
    Loop(SpecBlocktype),
    Else(SpecEmpty),
    Unreachable(SpecEmpty),
    Nop(SpecEmpty),
}

pub type SpecInstrControl1Inner = Either<SpecBlocktype, Either<SpecBlocktype, Either<SpecBlocktype, Either<SpecEmpty, Either<SpecEmpty, SpecEmpty>>>>>;

impl SpecFrom<SpecInstrControl1> for SpecInstrControl1Inner {
    open spec fn spec_from(m: SpecInstrControl1) -> SpecInstrControl1Inner {
        match m {
            SpecInstrControl1::If(m) => Either::Left(m),
            SpecInstrControl1::Block(m) => Either::Right(Either::Left(m)),
            SpecInstrControl1::Loop(m) => Either::Right(Either::Right(Either::Left(m))),
            SpecInstrControl1::Else(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            SpecInstrControl1::Unreachable(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            SpecInstrControl1::Nop(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m))))),
        }
    }

}

                
impl SpecFrom<SpecInstrControl1Inner> for SpecInstrControl1 {
    open spec fn spec_from(m: SpecInstrControl1Inner) -> SpecInstrControl1 {
        match m {
            Either::Left(m) => SpecInstrControl1::If(m),
            Either::Right(Either::Left(m)) => SpecInstrControl1::Block(m),
            Either::Right(Either::Right(Either::Left(m))) => SpecInstrControl1::Loop(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => SpecInstrControl1::Else(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => SpecInstrControl1::Unreachable(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m))))) => SpecInstrControl1::Nop(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InstrControl1<'a> {
    If(Blocktype<'a>),
    Block(Blocktype<'a>),
    Loop(Blocktype<'a>),
    Else(Empty<'a>),
    Unreachable(Empty<'a>),
    Nop(Empty<'a>),
}

pub type InstrControl1Inner<'a> = Either<Blocktype<'a>, Either<Blocktype<'a>, Either<Blocktype<'a>, Either<Empty<'a>, Either<Empty<'a>, Empty<'a>>>>>>;

pub type InstrControl1InnerRef<'a> = Either<&'a Blocktype<'a>, Either<&'a Blocktype<'a>, Either<&'a Blocktype<'a>, Either<&'a Empty<'a>, Either<&'a Empty<'a>, &'a Empty<'a>>>>>>;


impl<'a> View for InstrControl1<'a> {
    type V = SpecInstrControl1;
    open spec fn view(&self) -> Self::V {
        match self {
            InstrControl1::If(m) => SpecInstrControl1::If(m@),
            InstrControl1::Block(m) => SpecInstrControl1::Block(m@),
            InstrControl1::Loop(m) => SpecInstrControl1::Loop(m@),
            InstrControl1::Else(m) => SpecInstrControl1::Else(m@),
            InstrControl1::Unreachable(m) => SpecInstrControl1::Unreachable(m@),
            InstrControl1::Nop(m) => SpecInstrControl1::Nop(m@),
        }
    }
}


impl<'a> From<&'a InstrControl1<'a>> for InstrControl1InnerRef<'a> {
    fn ex_from(m: &'a InstrControl1<'a>) -> InstrControl1InnerRef<'a> {
        match m {
            InstrControl1::If(m) => Either::Left(m),
            InstrControl1::Block(m) => Either::Right(Either::Left(m)),
            InstrControl1::Loop(m) => Either::Right(Either::Right(Either::Left(m))),
            InstrControl1::Else(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            InstrControl1::Unreachable(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            InstrControl1::Nop(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m))))),
        }
    }

}

impl<'a> From<InstrControl1Inner<'a>> for InstrControl1<'a> {
    fn ex_from(m: InstrControl1Inner<'a>) -> InstrControl1<'a> {
        match m {
            Either::Left(m) => InstrControl1::If(m),
            Either::Right(Either::Left(m)) => InstrControl1::Block(m),
            Either::Right(Either::Right(Either::Left(m))) => InstrControl1::Loop(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => InstrControl1::Else(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => InstrControl1::Unreachable(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m))))) => InstrControl1::Nop(m),
        }
    }
    
}


pub struct InstrControl1Mapper;
impl View for InstrControl1Mapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrControl1Mapper {
    type Src = SpecInstrControl1Inner;
    type Dst = SpecInstrControl1;
}
impl SpecIsoProof for InstrControl1Mapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrControl1Mapper {
    type Src = InstrControl1Inner<'a>;
    type Dst = InstrControl1<'a>;
    type RefSrc = InstrControl1InnerRef<'a>;
}

type SpecInstrControl1CombinatorAlias1 = Choice<Cond<SpecEmptyCombinator>, Cond<SpecEmptyCombinator>>;
type SpecInstrControl1CombinatorAlias2 = Choice<Cond<SpecEmptyCombinator>, SpecInstrControl1CombinatorAlias1>;
type SpecInstrControl1CombinatorAlias3 = Choice<Cond<SpecBlocktypeCombinator>, SpecInstrControl1CombinatorAlias2>;
type SpecInstrControl1CombinatorAlias4 = Choice<Cond<SpecBlocktypeCombinator>, SpecInstrControl1CombinatorAlias3>;
type SpecInstrControl1CombinatorAlias5 = Choice<Cond<SpecBlocktypeCombinator>, SpecInstrControl1CombinatorAlias4>;
pub struct SpecInstrControl1Combinator(pub SpecInstrControl1CombinatorAlias);

impl SpecCombinator for SpecInstrControl1Combinator {
    type Type = SpecInstrControl1;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrControl1Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrControl1CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrControl1CombinatorAlias = Mapped<SpecInstrControl1CombinatorAlias5, InstrControl1Mapper>;
type InstrControl1CombinatorAlias1 = Choice<Cond<EmptyCombinator>, Cond<EmptyCombinator>>;
type InstrControl1CombinatorAlias2 = Choice<Cond<EmptyCombinator>, InstrControl1Combinator1>;
type InstrControl1CombinatorAlias3 = Choice<Cond<BlocktypeCombinator>, InstrControl1Combinator2>;
type InstrControl1CombinatorAlias4 = Choice<Cond<BlocktypeCombinator>, InstrControl1Combinator3>;
type InstrControl1CombinatorAlias5 = Choice<Cond<BlocktypeCombinator>, InstrControl1Combinator4>;
pub struct InstrControl1Combinator1(pub InstrControl1CombinatorAlias1);
impl View for InstrControl1Combinator1 {
    type V = SpecInstrControl1CombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrControl1Combinator1, InstrControl1CombinatorAlias1);

pub struct InstrControl1Combinator2(pub InstrControl1CombinatorAlias2);
impl View for InstrControl1Combinator2 {
    type V = SpecInstrControl1CombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrControl1Combinator2, InstrControl1CombinatorAlias2);

pub struct InstrControl1Combinator3(pub InstrControl1CombinatorAlias3);
impl View for InstrControl1Combinator3 {
    type V = SpecInstrControl1CombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrControl1Combinator3, InstrControl1CombinatorAlias3);

pub struct InstrControl1Combinator4(pub InstrControl1CombinatorAlias4);
impl View for InstrControl1Combinator4 {
    type V = SpecInstrControl1CombinatorAlias4;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrControl1Combinator4, InstrControl1CombinatorAlias4);

pub struct InstrControl1Combinator5(pub InstrControl1CombinatorAlias5);
impl View for InstrControl1Combinator5 {
    type V = SpecInstrControl1CombinatorAlias5;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrControl1Combinator5, InstrControl1CombinatorAlias5);

pub struct InstrControl1Combinator(pub InstrControl1CombinatorAlias);

impl View for InstrControl1Combinator {
    type V = SpecInstrControl1Combinator;
    open spec fn view(&self) -> Self::V { SpecInstrControl1Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrControl1Combinator {
    type Type = InstrControl1<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrControl1CombinatorAlias = Mapped<InstrControl1Combinator5, InstrControl1Mapper>;


pub open spec fn spec_instr_control1(opcode: u8) -> SpecInstrControl1Combinator {
    SpecInstrControl1Combinator(Mapped { inner: Choice(Cond { cond: opcode == InstrBytecode::SPEC_If, inner: spec_blocktype() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_Block, inner: spec_blocktype() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_Loop, inner: spec_blocktype() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_Else, inner: spec_empty() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_Unreachable, inner: spec_empty() }, Cond { cond: opcode == InstrBytecode::SPEC_Nop, inner: spec_empty() }))))), mapper: InstrControl1Mapper })
}

pub fn instr_control1<'a>(opcode: u8) -> (o: InstrControl1Combinator)
    ensures o@ == spec_instr_control1(opcode@),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrControl1Combinator(Mapped { inner: InstrControl1Combinator5(Choice::new(Cond { cond: opcode == InstrBytecode::If, inner: blocktype() }, InstrControl1Combinator4(Choice::new(Cond { cond: opcode == InstrBytecode::Block, inner: blocktype() }, InstrControl1Combinator3(Choice::new(Cond { cond: opcode == InstrBytecode::Loop, inner: blocktype() }, InstrControl1Combinator2(Choice::new(Cond { cond: opcode == InstrBytecode::Else, inner: empty() }, InstrControl1Combinator1(Choice::new(Cond { cond: opcode == InstrBytecode::Unreachable, inner: empty() }, Cond { cond: opcode == InstrBytecode::Nop, inner: empty() })))))))))), mapper: InstrControl1Mapper });
    assert({
        &&& combinator@ == spec_instr_control1(opcode@)
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_control1<'a>(input: &'a [u8], opcode: u8) -> (res: PResult<<InstrControl1Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_control1(opcode@).spec_parse(input@) == Some((n as int, v@)),
        spec_instr_control1(opcode@).spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_control1(opcode@).spec_parse(input@) is None,
        spec_instr_control1(opcode@).spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_control1( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_control1<'a>(v: <InstrControl1Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize, opcode: u8) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_control1(opcode@).wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_control1(opcode@).spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_control1(opcode@).spec_serialize(v@))
        },
{
    let combinator = instr_control1( opcode );
    combinator.serialize(v, data, pos)
}

pub fn instr_control1_len<'a>(v: <InstrControl1Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, opcode: u8) -> (serialize_len: usize)
    requires
        spec_instr_control1(opcode@).wf(v@),
        spec_instr_control1(opcode@).spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_control1(opcode@).spec_serialize(v@).len(),
{
    let combinator = instr_control1( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}


pub struct SpecMemarg {
    pub align: u64,
    pub offset: u64,
}

pub type SpecMemargInner = (u64, u64);


impl SpecFrom<SpecMemarg> for SpecMemargInner {
    open spec fn spec_from(m: SpecMemarg) -> SpecMemargInner {
        (m.align, m.offset)
    }
}

impl SpecFrom<SpecMemargInner> for SpecMemarg {
    open spec fn spec_from(m: SpecMemargInner) -> SpecMemarg {
        let (align, offset) = m;
        SpecMemarg { align, offset }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Memarg {
    pub align: u64,
    pub offset: u64,
}

impl View for Memarg {
    type V = SpecMemarg;

    open spec fn view(&self) -> Self::V {
        SpecMemarg {
            align: self.align@,
            offset: self.offset@,
        }
    }
}
pub type MemargInner = (u64, u64);

pub type MemargInnerRef<'a> = (&'a u64, &'a u64);
impl<'a> From<&'a Memarg> for MemargInnerRef<'a> {
    fn ex_from(m: &'a Memarg) -> MemargInnerRef<'a> {
        (&m.align, &m.offset)
    }
}

impl From<MemargInner> for Memarg {
    fn ex_from(m: MemargInner) -> Memarg {
        let (align, offset) = m;
        Memarg { align, offset }
    }
}

pub struct MemargMapper;
impl View for MemargMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for MemargMapper {
    type Src = SpecMemargInner;
    type Dst = SpecMemarg;
}
impl SpecIsoProof for MemargMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for MemargMapper {
    type Src = MemargInner;
    type Dst = Memarg;
    type RefSrc = MemargInnerRef<'a>;
}
type SpecMemargCombinatorAlias1 = (UnsignedLEB128, UnsignedLEB128);
pub struct SpecMemargCombinator(pub SpecMemargCombinatorAlias);

impl SpecCombinator for SpecMemargCombinator {
    type Type = SpecMemarg;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecMemargCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecMemargCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecMemargCombinatorAlias = Mapped<SpecMemargCombinatorAlias1, MemargMapper>;
type MemargCombinatorAlias1 = (UnsignedLEB128, UnsignedLEB128);
pub struct MemargCombinator1(pub MemargCombinatorAlias1);
impl View for MemargCombinator1 {
    type V = SpecMemargCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(MemargCombinator1, MemargCombinatorAlias1);

pub struct MemargCombinator(pub MemargCombinatorAlias);

impl View for MemargCombinator {
    type V = SpecMemargCombinator;
    open spec fn view(&self) -> Self::V { SpecMemargCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for MemargCombinator {
    type Type = Memarg;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type MemargCombinatorAlias = Mapped<MemargCombinator1, MemargMapper>;


pub open spec fn spec_memarg() -> SpecMemargCombinator {
    SpecMemargCombinator(
    Mapped {
        inner: (UnsignedLEB128, UnsignedLEB128),
        mapper: MemargMapper,
    })
}

                
pub fn memarg<'a>() -> (o: MemargCombinator)
    ensures o@ == spec_memarg(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = MemargCombinator(
    Mapped {
        inner: MemargCombinator1((UnsignedLEB128, UnsignedLEB128)),
        mapper: MemargMapper,
    });
    assert({
        &&& combinator@ == spec_memarg()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_memarg<'a>(input: &'a [u8]) -> (res: PResult<<MemargCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_memarg().spec_parse(input@) == Some((n as int, v@)),
        spec_memarg().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_memarg().spec_parse(input@) is None,
        spec_memarg().spec_parse(input@) is None ==> res is Err,
{
    let combinator = memarg();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_memarg<'a>(v: <MemargCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_memarg().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_memarg().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_memarg().spec_serialize(v@))
        },
{
    let combinator = memarg();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn memarg_len<'a>(v: <MemargCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_memarg().wf(v@),
        spec_memarg().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_memarg().spec_serialize(v@).len(),
{
    let combinator = memarg();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub enum SpecInstrMemory {
    I32Store(SpecMemarg),
    I32Load(SpecMemarg),
    I64Store(SpecMemarg),
    I64Load(SpecMemarg),
    MemorySize(SpecByteZero),
    MemoryGrow(SpecByteZero),
    Unrecognized(SpecMemarg),
}

pub type SpecInstrMemoryInner = Either<SpecMemarg, Either<SpecMemarg, Either<SpecMemarg, Either<SpecMemarg, Either<SpecByteZero, Either<SpecByteZero, SpecMemarg>>>>>>;

impl SpecFrom<SpecInstrMemory> for SpecInstrMemoryInner {
    open spec fn spec_from(m: SpecInstrMemory) -> SpecInstrMemoryInner {
        match m {
            SpecInstrMemory::I32Store(m) => Either::Left(m),
            SpecInstrMemory::I32Load(m) => Either::Right(Either::Left(m)),
            SpecInstrMemory::I64Store(m) => Either::Right(Either::Right(Either::Left(m))),
            SpecInstrMemory::I64Load(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            SpecInstrMemory::MemorySize(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            SpecInstrMemory::MemoryGrow(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))),
            SpecInstrMemory::Unrecognized(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))),
        }
    }

}

                
impl SpecFrom<SpecInstrMemoryInner> for SpecInstrMemory {
    open spec fn spec_from(m: SpecInstrMemoryInner) -> SpecInstrMemory {
        match m {
            Either::Left(m) => SpecInstrMemory::I32Store(m),
            Either::Right(Either::Left(m)) => SpecInstrMemory::I32Load(m),
            Either::Right(Either::Right(Either::Left(m))) => SpecInstrMemory::I64Store(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => SpecInstrMemory::I64Load(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => SpecInstrMemory::MemorySize(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))) => SpecInstrMemory::MemoryGrow(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))) => SpecInstrMemory::Unrecognized(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InstrMemory {
    I32Store(Memarg),
    I32Load(Memarg),
    I64Store(Memarg),
    I64Load(Memarg),
    MemorySize(ByteZero),
    MemoryGrow(ByteZero),
    Unrecognized(Memarg),
}

pub type InstrMemoryInner = Either<Memarg, Either<Memarg, Either<Memarg, Either<Memarg, Either<ByteZero, Either<ByteZero, Memarg>>>>>>;

pub type InstrMemoryInnerRef<'a> = Either<&'a Memarg, Either<&'a Memarg, Either<&'a Memarg, Either<&'a Memarg, Either<&'a ByteZero, Either<&'a ByteZero, &'a Memarg>>>>>>;


impl View for InstrMemory {
    type V = SpecInstrMemory;
    open spec fn view(&self) -> Self::V {
        match self {
            InstrMemory::I32Store(m) => SpecInstrMemory::I32Store(m@),
            InstrMemory::I32Load(m) => SpecInstrMemory::I32Load(m@),
            InstrMemory::I64Store(m) => SpecInstrMemory::I64Store(m@),
            InstrMemory::I64Load(m) => SpecInstrMemory::I64Load(m@),
            InstrMemory::MemorySize(m) => SpecInstrMemory::MemorySize(m@),
            InstrMemory::MemoryGrow(m) => SpecInstrMemory::MemoryGrow(m@),
            InstrMemory::Unrecognized(m) => SpecInstrMemory::Unrecognized(m@),
        }
    }
}


impl<'a> From<&'a InstrMemory> for InstrMemoryInnerRef<'a> {
    fn ex_from(m: &'a InstrMemory) -> InstrMemoryInnerRef<'a> {
        match m {
            InstrMemory::I32Store(m) => Either::Left(m),
            InstrMemory::I32Load(m) => Either::Right(Either::Left(m)),
            InstrMemory::I64Store(m) => Either::Right(Either::Right(Either::Left(m))),
            InstrMemory::I64Load(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            InstrMemory::MemorySize(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            InstrMemory::MemoryGrow(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))),
            InstrMemory::Unrecognized(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))),
        }
    }

}

impl From<InstrMemoryInner> for InstrMemory {
    fn ex_from(m: InstrMemoryInner) -> InstrMemory {
        match m {
            Either::Left(m) => InstrMemory::I32Store(m),
            Either::Right(Either::Left(m)) => InstrMemory::I32Load(m),
            Either::Right(Either::Right(Either::Left(m))) => InstrMemory::I64Store(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => InstrMemory::I64Load(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => InstrMemory::MemorySize(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))) => InstrMemory::MemoryGrow(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))) => InstrMemory::Unrecognized(m),
        }
    }
    
}


pub struct InstrMemoryMapper;
impl View for InstrMemoryMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrMemoryMapper {
    type Src = SpecInstrMemoryInner;
    type Dst = SpecInstrMemory;
}
impl SpecIsoProof for InstrMemoryMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrMemoryMapper {
    type Src = InstrMemoryInner;
    type Dst = InstrMemory;
    type RefSrc = InstrMemoryInnerRef<'a>;
}

type SpecInstrMemoryCombinatorAlias1 = Choice<Cond<SpecByteZeroCombinator>, Cond<SpecMemargCombinator>>;
type SpecInstrMemoryCombinatorAlias2 = Choice<Cond<SpecByteZeroCombinator>, SpecInstrMemoryCombinatorAlias1>;
type SpecInstrMemoryCombinatorAlias3 = Choice<Cond<SpecMemargCombinator>, SpecInstrMemoryCombinatorAlias2>;
type SpecInstrMemoryCombinatorAlias4 = Choice<Cond<SpecMemargCombinator>, SpecInstrMemoryCombinatorAlias3>;
type SpecInstrMemoryCombinatorAlias5 = Choice<Cond<SpecMemargCombinator>, SpecInstrMemoryCombinatorAlias4>;
type SpecInstrMemoryCombinatorAlias6 = Choice<Cond<SpecMemargCombinator>, SpecInstrMemoryCombinatorAlias5>;
pub struct SpecInstrMemoryCombinator(pub SpecInstrMemoryCombinatorAlias);

impl SpecCombinator for SpecInstrMemoryCombinator {
    type Type = SpecInstrMemory;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrMemoryCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrMemoryCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrMemoryCombinatorAlias = Mapped<SpecInstrMemoryCombinatorAlias6, InstrMemoryMapper>;
type InstrMemoryCombinatorAlias1 = Choice<Cond<ByteZeroCombinator>, Cond<MemargCombinator>>;
type InstrMemoryCombinatorAlias2 = Choice<Cond<ByteZeroCombinator>, InstrMemoryCombinator1>;
type InstrMemoryCombinatorAlias3 = Choice<Cond<MemargCombinator>, InstrMemoryCombinator2>;
type InstrMemoryCombinatorAlias4 = Choice<Cond<MemargCombinator>, InstrMemoryCombinator3>;
type InstrMemoryCombinatorAlias5 = Choice<Cond<MemargCombinator>, InstrMemoryCombinator4>;
type InstrMemoryCombinatorAlias6 = Choice<Cond<MemargCombinator>, InstrMemoryCombinator5>;
pub struct InstrMemoryCombinator1(pub InstrMemoryCombinatorAlias1);
impl View for InstrMemoryCombinator1 {
    type V = SpecInstrMemoryCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrMemoryCombinator1, InstrMemoryCombinatorAlias1);

pub struct InstrMemoryCombinator2(pub InstrMemoryCombinatorAlias2);
impl View for InstrMemoryCombinator2 {
    type V = SpecInstrMemoryCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrMemoryCombinator2, InstrMemoryCombinatorAlias2);

pub struct InstrMemoryCombinator3(pub InstrMemoryCombinatorAlias3);
impl View for InstrMemoryCombinator3 {
    type V = SpecInstrMemoryCombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrMemoryCombinator3, InstrMemoryCombinatorAlias3);

pub struct InstrMemoryCombinator4(pub InstrMemoryCombinatorAlias4);
impl View for InstrMemoryCombinator4 {
    type V = SpecInstrMemoryCombinatorAlias4;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrMemoryCombinator4, InstrMemoryCombinatorAlias4);

pub struct InstrMemoryCombinator5(pub InstrMemoryCombinatorAlias5);
impl View for InstrMemoryCombinator5 {
    type V = SpecInstrMemoryCombinatorAlias5;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrMemoryCombinator5, InstrMemoryCombinatorAlias5);

pub struct InstrMemoryCombinator6(pub InstrMemoryCombinatorAlias6);
impl View for InstrMemoryCombinator6 {
    type V = SpecInstrMemoryCombinatorAlias6;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrMemoryCombinator6, InstrMemoryCombinatorAlias6);

pub struct InstrMemoryCombinator(pub InstrMemoryCombinatorAlias);

impl View for InstrMemoryCombinator {
    type V = SpecInstrMemoryCombinator;
    open spec fn view(&self) -> Self::V { SpecInstrMemoryCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrMemoryCombinator {
    type Type = InstrMemory;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrMemoryCombinatorAlias = Mapped<InstrMemoryCombinator6, InstrMemoryMapper>;


pub open spec fn spec_instr_memory(opcode: u8) -> SpecInstrMemoryCombinator {
    SpecInstrMemoryCombinator(Mapped { inner: Choice(Cond { cond: opcode == InstrBytecode::SPEC_I32Store, inner: spec_memarg() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_I32Load, inner: spec_memarg() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_I64Store, inner: spec_memarg() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_I64Load, inner: spec_memarg() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_MemorySize, inner: spec_byte_zero() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_MemoryGrow, inner: spec_byte_zero() }, Cond { cond: !(opcode == InstrBytecode::SPEC_I32Store || opcode == InstrBytecode::SPEC_I32Load || opcode == InstrBytecode::SPEC_I64Store || opcode == InstrBytecode::SPEC_I64Load || opcode == InstrBytecode::SPEC_MemorySize || opcode == InstrBytecode::SPEC_MemoryGrow), inner: spec_memarg() })))))), mapper: InstrMemoryMapper })
}

pub fn instr_memory<'a>(opcode: u8) -> (o: InstrMemoryCombinator)
    ensures o@ == spec_instr_memory(opcode@),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrMemoryCombinator(Mapped { inner: InstrMemoryCombinator6(Choice::new(Cond { cond: opcode == InstrBytecode::I32Store, inner: memarg() }, InstrMemoryCombinator5(Choice::new(Cond { cond: opcode == InstrBytecode::I32Load, inner: memarg() }, InstrMemoryCombinator4(Choice::new(Cond { cond: opcode == InstrBytecode::I64Store, inner: memarg() }, InstrMemoryCombinator3(Choice::new(Cond { cond: opcode == InstrBytecode::I64Load, inner: memarg() }, InstrMemoryCombinator2(Choice::new(Cond { cond: opcode == InstrBytecode::MemorySize, inner: byte_zero() }, InstrMemoryCombinator1(Choice::new(Cond { cond: opcode == InstrBytecode::MemoryGrow, inner: byte_zero() }, Cond { cond: !(opcode == InstrBytecode::I32Store || opcode == InstrBytecode::I32Load || opcode == InstrBytecode::I64Store || opcode == InstrBytecode::I64Load || opcode == InstrBytecode::MemorySize || opcode == InstrBytecode::MemoryGrow), inner: memarg() })))))))))))), mapper: InstrMemoryMapper });
    assert({
        &&& combinator@ == spec_instr_memory(opcode@)
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_memory<'a>(input: &'a [u8], opcode: u8) -> (res: PResult<<InstrMemoryCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_memory(opcode@).spec_parse(input@) == Some((n as int, v@)),
        spec_instr_memory(opcode@).spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_memory(opcode@).spec_parse(input@) is None,
        spec_instr_memory(opcode@).spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_memory( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_memory<'a>(v: <InstrMemoryCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize, opcode: u8) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_memory(opcode@).wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_memory(opcode@).spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_memory(opcode@).spec_serialize(v@))
        },
{
    let combinator = instr_memory( opcode );
    combinator.serialize(v, data, pos)
}

pub fn instr_memory_len<'a>(v: <InstrMemoryCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, opcode: u8) -> (serialize_len: usize)
    requires
        spec_instr_memory(opcode@).wf(v@),
        spec_instr_memory(opcode@).spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_memory(opcode@).spec_serialize(v@).len(),
{
    let combinator = instr_memory( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}


pub enum SpecInstrReference {
    RefNull(SpecReftype),
    RefIsNull(SpecEmpty),
    RefFunc(SpecFuncidx),
}

pub type SpecInstrReferenceInner = Either<SpecReftype, Either<SpecEmpty, SpecFuncidx>>;

impl SpecFrom<SpecInstrReference> for SpecInstrReferenceInner {
    open spec fn spec_from(m: SpecInstrReference) -> SpecInstrReferenceInner {
        match m {
            SpecInstrReference::RefNull(m) => Either::Left(m),
            SpecInstrReference::RefIsNull(m) => Either::Right(Either::Left(m)),
            SpecInstrReference::RefFunc(m) => Either::Right(Either::Right(m)),
        }
    }

}

                
impl SpecFrom<SpecInstrReferenceInner> for SpecInstrReference {
    open spec fn spec_from(m: SpecInstrReferenceInner) -> SpecInstrReference {
        match m {
            Either::Left(m) => SpecInstrReference::RefNull(m),
            Either::Right(Either::Left(m)) => SpecInstrReference::RefIsNull(m),
            Either::Right(Either::Right(m)) => SpecInstrReference::RefFunc(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InstrReference<'a> {
    RefNull(Reftype),
    RefIsNull(Empty<'a>),
    RefFunc(Funcidx),
}

pub type InstrReferenceInner<'a> = Either<Reftype, Either<Empty<'a>, Funcidx>>;

pub type InstrReferenceInnerRef<'a> = Either<&'a Reftype, Either<&'a Empty<'a>, &'a Funcidx>>;


impl<'a> View for InstrReference<'a> {
    type V = SpecInstrReference;
    open spec fn view(&self) -> Self::V {
        match self {
            InstrReference::RefNull(m) => SpecInstrReference::RefNull(m@),
            InstrReference::RefIsNull(m) => SpecInstrReference::RefIsNull(m@),
            InstrReference::RefFunc(m) => SpecInstrReference::RefFunc(m@),
        }
    }
}


impl<'a> From<&'a InstrReference<'a>> for InstrReferenceInnerRef<'a> {
    fn ex_from(m: &'a InstrReference<'a>) -> InstrReferenceInnerRef<'a> {
        match m {
            InstrReference::RefNull(m) => Either::Left(m),
            InstrReference::RefIsNull(m) => Either::Right(Either::Left(m)),
            InstrReference::RefFunc(m) => Either::Right(Either::Right(m)),
        }
    }

}

impl<'a> From<InstrReferenceInner<'a>> for InstrReference<'a> {
    fn ex_from(m: InstrReferenceInner<'a>) -> InstrReference<'a> {
        match m {
            Either::Left(m) => InstrReference::RefNull(m),
            Either::Right(Either::Left(m)) => InstrReference::RefIsNull(m),
            Either::Right(Either::Right(m)) => InstrReference::RefFunc(m),
        }
    }
    
}


pub struct InstrReferenceMapper;
impl View for InstrReferenceMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrReferenceMapper {
    type Src = SpecInstrReferenceInner;
    type Dst = SpecInstrReference;
}
impl SpecIsoProof for InstrReferenceMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrReferenceMapper {
    type Src = InstrReferenceInner<'a>;
    type Dst = InstrReference<'a>;
    type RefSrc = InstrReferenceInnerRef<'a>;
}

type SpecInstrReferenceCombinatorAlias1 = Choice<Cond<SpecEmptyCombinator>, Cond<SpecFuncidxCombinator>>;
type SpecInstrReferenceCombinatorAlias2 = Choice<Cond<SpecReftypeCombinator>, SpecInstrReferenceCombinatorAlias1>;
pub struct SpecInstrReferenceCombinator(pub SpecInstrReferenceCombinatorAlias);

impl SpecCombinator for SpecInstrReferenceCombinator {
    type Type = SpecInstrReference;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrReferenceCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrReferenceCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrReferenceCombinatorAlias = Mapped<SpecInstrReferenceCombinatorAlias2, InstrReferenceMapper>;
type InstrReferenceCombinatorAlias1 = Choice<Cond<EmptyCombinator>, Cond<FuncidxCombinator>>;
type InstrReferenceCombinatorAlias2 = Choice<Cond<ReftypeCombinator>, InstrReferenceCombinator1>;
pub struct InstrReferenceCombinator1(pub InstrReferenceCombinatorAlias1);
impl View for InstrReferenceCombinator1 {
    type V = SpecInstrReferenceCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrReferenceCombinator1, InstrReferenceCombinatorAlias1);

pub struct InstrReferenceCombinator2(pub InstrReferenceCombinatorAlias2);
impl View for InstrReferenceCombinator2 {
    type V = SpecInstrReferenceCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrReferenceCombinator2, InstrReferenceCombinatorAlias2);

pub struct InstrReferenceCombinator(pub InstrReferenceCombinatorAlias);

impl View for InstrReferenceCombinator {
    type V = SpecInstrReferenceCombinator;
    open spec fn view(&self) -> Self::V { SpecInstrReferenceCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrReferenceCombinator {
    type Type = InstrReference<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrReferenceCombinatorAlias = Mapped<InstrReferenceCombinator2, InstrReferenceMapper>;


pub open spec fn spec_instr_reference(opcode: u8) -> SpecInstrReferenceCombinator {
    SpecInstrReferenceCombinator(Mapped { inner: Choice(Cond { cond: opcode == InstrBytecode::SPEC_RefNull, inner: spec_reftype() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_RefIsNull, inner: spec_empty() }, Cond { cond: opcode == InstrBytecode::SPEC_RefFunc, inner: spec_funcidx() })), mapper: InstrReferenceMapper })
}

pub fn instr_reference<'a>(opcode: u8) -> (o: InstrReferenceCombinator)
    ensures o@ == spec_instr_reference(opcode@),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrReferenceCombinator(Mapped { inner: InstrReferenceCombinator2(Choice::new(Cond { cond: opcode == InstrBytecode::RefNull, inner: reftype() }, InstrReferenceCombinator1(Choice::new(Cond { cond: opcode == InstrBytecode::RefIsNull, inner: empty() }, Cond { cond: opcode == InstrBytecode::RefFunc, inner: funcidx() })))), mapper: InstrReferenceMapper });
    assert({
        &&& combinator@ == spec_instr_reference(opcode@)
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_reference<'a>(input: &'a [u8], opcode: u8) -> (res: PResult<<InstrReferenceCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_reference(opcode@).spec_parse(input@) == Some((n as int, v@)),
        spec_instr_reference(opcode@).spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_reference(opcode@).spec_parse(input@) is None,
        spec_instr_reference(opcode@).spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_reference( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_reference<'a>(v: <InstrReferenceCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize, opcode: u8) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_reference(opcode@).wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_reference(opcode@).spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_reference(opcode@).spec_serialize(v@))
        },
{
    let combinator = instr_reference( opcode );
    combinator.serialize(v, data, pos)
}

pub fn instr_reference_len<'a>(v: <InstrReferenceCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, opcode: u8) -> (serialize_len: usize)
    requires
        spec_instr_reference(opcode@).wf(v@),
        spec_instr_reference(opcode@).spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_reference(opcode@).spec_serialize(v@).len(),
{
    let combinator = instr_reference( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}


pub enum SpecInstrTable {
    TableGet(SpecTableidx),
    TableSet(SpecTableidx),
}

pub type SpecInstrTableInner = Either<SpecTableidx, SpecTableidx>;

impl SpecFrom<SpecInstrTable> for SpecInstrTableInner {
    open spec fn spec_from(m: SpecInstrTable) -> SpecInstrTableInner {
        match m {
            SpecInstrTable::TableGet(m) => Either::Left(m),
            SpecInstrTable::TableSet(m) => Either::Right(m),
        }
    }

}

                
impl SpecFrom<SpecInstrTableInner> for SpecInstrTable {
    open spec fn spec_from(m: SpecInstrTableInner) -> SpecInstrTable {
        match m {
            Either::Left(m) => SpecInstrTable::TableGet(m),
            Either::Right(m) => SpecInstrTable::TableSet(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InstrTable {
    TableGet(Tableidx),
    TableSet(Tableidx),
}

pub type InstrTableInner = Either<Tableidx, Tableidx>;

pub type InstrTableInnerRef<'a> = Either<&'a Tableidx, &'a Tableidx>;


impl View for InstrTable {
    type V = SpecInstrTable;
    open spec fn view(&self) -> Self::V {
        match self {
            InstrTable::TableGet(m) => SpecInstrTable::TableGet(m@),
            InstrTable::TableSet(m) => SpecInstrTable::TableSet(m@),
        }
    }
}


impl<'a> From<&'a InstrTable> for InstrTableInnerRef<'a> {
    fn ex_from(m: &'a InstrTable) -> InstrTableInnerRef<'a> {
        match m {
            InstrTable::TableGet(m) => Either::Left(m),
            InstrTable::TableSet(m) => Either::Right(m),
        }
    }

}

impl From<InstrTableInner> for InstrTable {
    fn ex_from(m: InstrTableInner) -> InstrTable {
        match m {
            Either::Left(m) => InstrTable::TableGet(m),
            Either::Right(m) => InstrTable::TableSet(m),
        }
    }
    
}


pub struct InstrTableMapper;
impl View for InstrTableMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrTableMapper {
    type Src = SpecInstrTableInner;
    type Dst = SpecInstrTable;
}
impl SpecIsoProof for InstrTableMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrTableMapper {
    type Src = InstrTableInner;
    type Dst = InstrTable;
    type RefSrc = InstrTableInnerRef<'a>;
}

type SpecInstrTableCombinatorAlias1 = Choice<Cond<SpecTableidxCombinator>, Cond<SpecTableidxCombinator>>;
pub struct SpecInstrTableCombinator(pub SpecInstrTableCombinatorAlias);

impl SpecCombinator for SpecInstrTableCombinator {
    type Type = SpecInstrTable;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrTableCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrTableCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrTableCombinatorAlias = Mapped<SpecInstrTableCombinatorAlias1, InstrTableMapper>;
type InstrTableCombinatorAlias1 = Choice<Cond<TableidxCombinator>, Cond<TableidxCombinator>>;
pub struct InstrTableCombinator1(pub InstrTableCombinatorAlias1);
impl View for InstrTableCombinator1 {
    type V = SpecInstrTableCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrTableCombinator1, InstrTableCombinatorAlias1);

pub struct InstrTableCombinator(pub InstrTableCombinatorAlias);

impl View for InstrTableCombinator {
    type V = SpecInstrTableCombinator;
    open spec fn view(&self) -> Self::V { SpecInstrTableCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrTableCombinator {
    type Type = InstrTable;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrTableCombinatorAlias = Mapped<InstrTableCombinator1, InstrTableMapper>;


pub open spec fn spec_instr_table(opcode: u8) -> SpecInstrTableCombinator {
    SpecInstrTableCombinator(Mapped { inner: Choice(Cond { cond: opcode == InstrBytecode::SPEC_TableGet, inner: spec_tableidx() }, Cond { cond: opcode == InstrBytecode::SPEC_TableSet, inner: spec_tableidx() }), mapper: InstrTableMapper })
}

pub fn instr_table<'a>(opcode: u8) -> (o: InstrTableCombinator)
    ensures o@ == spec_instr_table(opcode@),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrTableCombinator(Mapped { inner: InstrTableCombinator1(Choice::new(Cond { cond: opcode == InstrBytecode::TableGet, inner: tableidx() }, Cond { cond: opcode == InstrBytecode::TableSet, inner: tableidx() })), mapper: InstrTableMapper });
    assert({
        &&& combinator@ == spec_instr_table(opcode@)
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_table<'a>(input: &'a [u8], opcode: u8) -> (res: PResult<<InstrTableCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_table(opcode@).spec_parse(input@) == Some((n as int, v@)),
        spec_instr_table(opcode@).spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_table(opcode@).spec_parse(input@) is None,
        spec_instr_table(opcode@).spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_table( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_table<'a>(v: <InstrTableCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize, opcode: u8) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_table(opcode@).wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_table(opcode@).spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_table(opcode@).spec_serialize(v@))
        },
{
    let combinator = instr_table( opcode );
    combinator.serialize(v, data, pos)
}

pub fn instr_table_len<'a>(v: <InstrTableCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, opcode: u8) -> (serialize_len: usize)
    requires
        spec_instr_table(opcode@).wf(v@),
        spec_instr_table(opcode@).spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_table(opcode@).spec_serialize(v@).len(),
{
    let combinator = instr_table( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub type SpecF64 = Seq<u8>;
pub type F64<'a> = &'a [u8];
pub type F64Ref<'a> = &'a &'a [u8];


pub struct SpecF64Combinator(pub SpecF64CombinatorAlias);

impl SpecCombinator for SpecF64Combinator {
    type Type = SpecF64;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecF64Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecF64CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecF64CombinatorAlias = bytes::Fixed<8>;

pub struct F64Combinator(pub F64CombinatorAlias);

impl View for F64Combinator {
    type V = SpecF64Combinator;
    open spec fn view(&self) -> Self::V { SpecF64Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for F64Combinator {
    type Type = F64<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type F64CombinatorAlias = bytes::Fixed<8>;


pub open spec fn spec_f64() -> SpecF64Combinator {
    SpecF64Combinator(bytes::Fixed::<8>)
}

                
pub fn f64<'a>() -> (o: F64Combinator)
    ensures o@ == spec_f64(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = F64Combinator(bytes::Fixed::<8>);
    assert({
        &&& combinator@ == spec_f64()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_f64<'a>(input: &'a [u8]) -> (res: PResult<<F64Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_f64().spec_parse(input@) == Some((n as int, v@)),
        spec_f64().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_f64().spec_parse(input@) is None,
        spec_f64().spec_parse(input@) is None ==> res is Err,
{
    let combinator = f64();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_f64<'a>(v: <F64Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_f64().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_f64().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_f64().spec_serialize(v@))
        },
{
    let combinator = f64();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn f64_len<'a>(v: <F64Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_f64().wf(v@),
        spec_f64().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_f64().spec_serialize(v@).len(),
{
    let combinator = f64();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub enum SpecInstrNumeric {
    I32Const(u64),
    I64Const(u64),
    F32Const(SpecF32),
    F64Const(SpecF64),
    Unrecognized(SpecEmpty),
}

pub type SpecInstrNumericInner = Either<u64, Either<u64, Either<SpecF32, Either<SpecF64, SpecEmpty>>>>;

impl SpecFrom<SpecInstrNumeric> for SpecInstrNumericInner {
    open spec fn spec_from(m: SpecInstrNumeric) -> SpecInstrNumericInner {
        match m {
            SpecInstrNumeric::I32Const(m) => Either::Left(m),
            SpecInstrNumeric::I64Const(m) => Either::Right(Either::Left(m)),
            SpecInstrNumeric::F32Const(m) => Either::Right(Either::Right(Either::Left(m))),
            SpecInstrNumeric::F64Const(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            SpecInstrNumeric::Unrecognized(m) => Either::Right(Either::Right(Either::Right(Either::Right(m)))),
        }
    }

}

                
impl SpecFrom<SpecInstrNumericInner> for SpecInstrNumeric {
    open spec fn spec_from(m: SpecInstrNumericInner) -> SpecInstrNumeric {
        match m {
            Either::Left(m) => SpecInstrNumeric::I32Const(m),
            Either::Right(Either::Left(m)) => SpecInstrNumeric::I64Const(m),
            Either::Right(Either::Right(Either::Left(m))) => SpecInstrNumeric::F32Const(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => SpecInstrNumeric::F64Const(m),
            Either::Right(Either::Right(Either::Right(Either::Right(m)))) => SpecInstrNumeric::Unrecognized(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InstrNumeric<'a> {
    I32Const(u64),
    I64Const(u64),
    F32Const(F32<'a>),
    F64Const(F64<'a>),
    Unrecognized(Empty<'a>),
}

pub type InstrNumericInner<'a> = Either<u64, Either<u64, Either<F32<'a>, Either<F64<'a>, Empty<'a>>>>>;

pub type InstrNumericInnerRef<'a> = Either<&'a u64, Either<&'a u64, Either<&'a F32<'a>, Either<&'a F64<'a>, &'a Empty<'a>>>>>;


impl<'a> View for InstrNumeric<'a> {
    type V = SpecInstrNumeric;
    open spec fn view(&self) -> Self::V {
        match self {
            InstrNumeric::I32Const(m) => SpecInstrNumeric::I32Const(m@),
            InstrNumeric::I64Const(m) => SpecInstrNumeric::I64Const(m@),
            InstrNumeric::F32Const(m) => SpecInstrNumeric::F32Const(m@),
            InstrNumeric::F64Const(m) => SpecInstrNumeric::F64Const(m@),
            InstrNumeric::Unrecognized(m) => SpecInstrNumeric::Unrecognized(m@),
        }
    }
}


impl<'a> From<&'a InstrNumeric<'a>> for InstrNumericInnerRef<'a> {
    fn ex_from(m: &'a InstrNumeric<'a>) -> InstrNumericInnerRef<'a> {
        match m {
            InstrNumeric::I32Const(m) => Either::Left(m),
            InstrNumeric::I64Const(m) => Either::Right(Either::Left(m)),
            InstrNumeric::F32Const(m) => Either::Right(Either::Right(Either::Left(m))),
            InstrNumeric::F64Const(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            InstrNumeric::Unrecognized(m) => Either::Right(Either::Right(Either::Right(Either::Right(m)))),
        }
    }

}

impl<'a> From<InstrNumericInner<'a>> for InstrNumeric<'a> {
    fn ex_from(m: InstrNumericInner<'a>) -> InstrNumeric<'a> {
        match m {
            Either::Left(m) => InstrNumeric::I32Const(m),
            Either::Right(Either::Left(m)) => InstrNumeric::I64Const(m),
            Either::Right(Either::Right(Either::Left(m))) => InstrNumeric::F32Const(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => InstrNumeric::F64Const(m),
            Either::Right(Either::Right(Either::Right(Either::Right(m)))) => InstrNumeric::Unrecognized(m),
        }
    }
    
}


pub struct InstrNumericMapper;
impl View for InstrNumericMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrNumericMapper {
    type Src = SpecInstrNumericInner;
    type Dst = SpecInstrNumeric;
}
impl SpecIsoProof for InstrNumericMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrNumericMapper {
    type Src = InstrNumericInner<'a>;
    type Dst = InstrNumeric<'a>;
    type RefSrc = InstrNumericInnerRef<'a>;
}

type SpecInstrNumericCombinatorAlias1 = Choice<Cond<SpecF64Combinator>, Cond<SpecEmptyCombinator>>;
type SpecInstrNumericCombinatorAlias2 = Choice<Cond<SpecF32Combinator>, SpecInstrNumericCombinatorAlias1>;
type SpecInstrNumericCombinatorAlias3 = Choice<Cond<UnsignedLEB128>, SpecInstrNumericCombinatorAlias2>;
type SpecInstrNumericCombinatorAlias4 = Choice<Cond<UnsignedLEB128>, SpecInstrNumericCombinatorAlias3>;
pub struct SpecInstrNumericCombinator(pub SpecInstrNumericCombinatorAlias);

impl SpecCombinator for SpecInstrNumericCombinator {
    type Type = SpecInstrNumeric;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrNumericCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrNumericCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrNumericCombinatorAlias = Mapped<SpecInstrNumericCombinatorAlias4, InstrNumericMapper>;
type InstrNumericCombinatorAlias1 = Choice<Cond<F64Combinator>, Cond<EmptyCombinator>>;
type InstrNumericCombinatorAlias2 = Choice<Cond<F32Combinator>, InstrNumericCombinator1>;
type InstrNumericCombinatorAlias3 = Choice<Cond<UnsignedLEB128>, InstrNumericCombinator2>;
type InstrNumericCombinatorAlias4 = Choice<Cond<UnsignedLEB128>, InstrNumericCombinator3>;
pub struct InstrNumericCombinator1(pub InstrNumericCombinatorAlias1);
impl View for InstrNumericCombinator1 {
    type V = SpecInstrNumericCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrNumericCombinator1, InstrNumericCombinatorAlias1);

pub struct InstrNumericCombinator2(pub InstrNumericCombinatorAlias2);
impl View for InstrNumericCombinator2 {
    type V = SpecInstrNumericCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrNumericCombinator2, InstrNumericCombinatorAlias2);

pub struct InstrNumericCombinator3(pub InstrNumericCombinatorAlias3);
impl View for InstrNumericCombinator3 {
    type V = SpecInstrNumericCombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrNumericCombinator3, InstrNumericCombinatorAlias3);

pub struct InstrNumericCombinator4(pub InstrNumericCombinatorAlias4);
impl View for InstrNumericCombinator4 {
    type V = SpecInstrNumericCombinatorAlias4;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrNumericCombinator4, InstrNumericCombinatorAlias4);

pub struct InstrNumericCombinator(pub InstrNumericCombinatorAlias);

impl View for InstrNumericCombinator {
    type V = SpecInstrNumericCombinator;
    open spec fn view(&self) -> Self::V { SpecInstrNumericCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrNumericCombinator {
    type Type = InstrNumeric<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrNumericCombinatorAlias = Mapped<InstrNumericCombinator4, InstrNumericMapper>;


pub open spec fn spec_instr_numeric(opcode: u8) -> SpecInstrNumericCombinator {
    SpecInstrNumericCombinator(Mapped { inner: Choice(Cond { cond: opcode == InstrBytecode::SPEC_I32Const, inner: UnsignedLEB128 }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_I64Const, inner: UnsignedLEB128 }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_F32Const, inner: spec_f32() }, Choice(Cond { cond: opcode == InstrBytecode::SPEC_F64Const, inner: spec_f64() }, Cond { cond: !(opcode == InstrBytecode::SPEC_I32Const || opcode == InstrBytecode::SPEC_I64Const || opcode == InstrBytecode::SPEC_F32Const || opcode == InstrBytecode::SPEC_F64Const), inner: spec_empty() })))), mapper: InstrNumericMapper })
}

pub fn instr_numeric<'a>(opcode: u8) -> (o: InstrNumericCombinator)
    ensures o@ == spec_instr_numeric(opcode@),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrNumericCombinator(Mapped { inner: InstrNumericCombinator4(Choice::new(Cond { cond: opcode == InstrBytecode::I32Const, inner: UnsignedLEB128 }, InstrNumericCombinator3(Choice::new(Cond { cond: opcode == InstrBytecode::I64Const, inner: UnsignedLEB128 }, InstrNumericCombinator2(Choice::new(Cond { cond: opcode == InstrBytecode::F32Const, inner: f32() }, InstrNumericCombinator1(Choice::new(Cond { cond: opcode == InstrBytecode::F64Const, inner: f64() }, Cond { cond: !(opcode == InstrBytecode::I32Const || opcode == InstrBytecode::I64Const || opcode == InstrBytecode::F32Const || opcode == InstrBytecode::F64Const), inner: empty() })))))))), mapper: InstrNumericMapper });
    assert({
        &&& combinator@ == spec_instr_numeric(opcode@)
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_numeric<'a>(input: &'a [u8], opcode: u8) -> (res: PResult<<InstrNumericCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_numeric(opcode@).spec_parse(input@) == Some((n as int, v@)),
        spec_instr_numeric(opcode@).spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_numeric(opcode@).spec_parse(input@) is None,
        spec_instr_numeric(opcode@).spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_numeric( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_numeric<'a>(v: <InstrNumericCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize, opcode: u8) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_numeric(opcode@).wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_numeric(opcode@).spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_numeric(opcode@).spec_serialize(v@))
        },
{
    let combinator = instr_numeric( opcode );
    combinator.serialize(v, data, pos)
}

pub fn instr_numeric_len<'a>(v: <InstrNumericCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, opcode: u8) -> (serialize_len: usize)
    requires
        spec_instr_numeric(opcode@).wf(v@),
        spec_instr_numeric(opcode@).spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_numeric(opcode@).spec_serialize(v@).len(),
{
    let combinator = instr_numeric( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}


pub struct SpecTableInit {
    pub y: SpecElemidx,
    pub x: SpecTableidx,
}

pub type SpecTableInitInner = (SpecElemidx, SpecTableidx);


impl SpecFrom<SpecTableInit> for SpecTableInitInner {
    open spec fn spec_from(m: SpecTableInit) -> SpecTableInitInner {
        (m.y, m.x)
    }
}

impl SpecFrom<SpecTableInitInner> for SpecTableInit {
    open spec fn spec_from(m: SpecTableInitInner) -> SpecTableInit {
        let (y, x) = m;
        SpecTableInit { y, x }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct TableInit {
    pub y: Elemidx,
    pub x: Tableidx,
}

impl View for TableInit {
    type V = SpecTableInit;

    open spec fn view(&self) -> Self::V {
        SpecTableInit {
            y: self.y@,
            x: self.x@,
        }
    }
}
pub type TableInitInner = (Elemidx, Tableidx);

pub type TableInitInnerRef<'a> = (&'a Elemidx, &'a Tableidx);
impl<'a> From<&'a TableInit> for TableInitInnerRef<'a> {
    fn ex_from(m: &'a TableInit) -> TableInitInnerRef<'a> {
        (&m.y, &m.x)
    }
}

impl From<TableInitInner> for TableInit {
    fn ex_from(m: TableInitInner) -> TableInit {
        let (y, x) = m;
        TableInit { y, x }
    }
}

pub struct TableInitMapper;
impl View for TableInitMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for TableInitMapper {
    type Src = SpecTableInitInner;
    type Dst = SpecTableInit;
}
impl SpecIsoProof for TableInitMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for TableInitMapper {
    type Src = TableInitInner;
    type Dst = TableInit;
    type RefSrc = TableInitInnerRef<'a>;
}
type SpecTableInitCombinatorAlias1 = (SpecElemidxCombinator, SpecTableidxCombinator);
pub struct SpecTableInitCombinator(pub SpecTableInitCombinatorAlias);

impl SpecCombinator for SpecTableInitCombinator {
    type Type = SpecTableInit;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTableInitCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTableInitCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTableInitCombinatorAlias = Mapped<SpecTableInitCombinatorAlias1, TableInitMapper>;
type TableInitCombinatorAlias1 = (ElemidxCombinator, TableidxCombinator);
pub struct TableInitCombinator1(pub TableInitCombinatorAlias1);
impl View for TableInitCombinator1 {
    type V = SpecTableInitCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(TableInitCombinator1, TableInitCombinatorAlias1);

pub struct TableInitCombinator(pub TableInitCombinatorAlias);

impl View for TableInitCombinator {
    type V = SpecTableInitCombinator;
    open spec fn view(&self) -> Self::V { SpecTableInitCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TableInitCombinator {
    type Type = TableInit;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TableInitCombinatorAlias = Mapped<TableInitCombinator1, TableInitMapper>;


pub open spec fn spec_table_init() -> SpecTableInitCombinator {
    SpecTableInitCombinator(
    Mapped {
        inner: (spec_elemidx(), spec_tableidx()),
        mapper: TableInitMapper,
    })
}

                
pub fn table_init<'a>() -> (o: TableInitCombinator)
    ensures o@ == spec_table_init(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TableInitCombinator(
    Mapped {
        inner: TableInitCombinator1((elemidx(), tableidx())),
        mapper: TableInitMapper,
    });
    assert({
        &&& combinator@ == spec_table_init()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_table_init<'a>(input: &'a [u8]) -> (res: PResult<<TableInitCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_table_init().spec_parse(input@) == Some((n as int, v@)),
        spec_table_init().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_table_init().spec_parse(input@) is None,
        spec_table_init().spec_parse(input@) is None ==> res is Err,
{
    let combinator = table_init();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_table_init<'a>(v: <TableInitCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_table_init().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_table_init().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_table_init().spec_serialize(v@))
        },
{
    let combinator = table_init();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn table_init_len<'a>(v: <TableInitCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_table_init().wf(v@),
        spec_table_init().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_table_init().spec_serialize(v@).len(),
{
    let combinator = table_init();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecElemDrop = SpecElemidx;
pub type ElemDrop = Elemidx;
pub type ElemDropRef<'a> = &'a Elemidx;


pub struct SpecElemDropCombinator(pub SpecElemDropCombinatorAlias);

impl SpecCombinator for SpecElemDropCombinator {
    type Type = SpecElemDrop;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecElemDropCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecElemDropCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecElemDropCombinatorAlias = SpecElemidxCombinator;

pub struct ElemDropCombinator(pub ElemDropCombinatorAlias);

impl View for ElemDropCombinator {
    type V = SpecElemDropCombinator;
    open spec fn view(&self) -> Self::V { SpecElemDropCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ElemDropCombinator {
    type Type = ElemDrop;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ElemDropCombinatorAlias = ElemidxCombinator;


pub open spec fn spec_elem_drop() -> SpecElemDropCombinator {
    SpecElemDropCombinator(spec_elemidx())
}

                
pub fn elem_drop<'a>() -> (o: ElemDropCombinator)
    ensures o@ == spec_elem_drop(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ElemDropCombinator(elemidx());
    assert({
        &&& combinator@ == spec_elem_drop()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_elem_drop<'a>(input: &'a [u8]) -> (res: PResult<<ElemDropCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_elem_drop().spec_parse(input@) == Some((n as int, v@)),
        spec_elem_drop().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_elem_drop().spec_parse(input@) is None,
        spec_elem_drop().spec_parse(input@) is None ==> res is Err,
{
    let combinator = elem_drop();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_elem_drop<'a>(v: <ElemDropCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_elem_drop().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_elem_drop().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_elem_drop().spec_serialize(v@))
        },
{
    let combinator = elem_drop();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn elem_drop_len<'a>(v: <ElemDropCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_elem_drop().wf(v@),
        spec_elem_drop().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_elem_drop().spec_serialize(v@).len(),
{
    let combinator = elem_drop();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecTableCopy {
    pub x: SpecTableidx,
    pub y: SpecTableidx,
}

pub type SpecTableCopyInner = (SpecTableidx, SpecTableidx);


impl SpecFrom<SpecTableCopy> for SpecTableCopyInner {
    open spec fn spec_from(m: SpecTableCopy) -> SpecTableCopyInner {
        (m.x, m.y)
    }
}

impl SpecFrom<SpecTableCopyInner> for SpecTableCopy {
    open spec fn spec_from(m: SpecTableCopyInner) -> SpecTableCopy {
        let (x, y) = m;
        SpecTableCopy { x, y }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct TableCopy {
    pub x: Tableidx,
    pub y: Tableidx,
}

impl View for TableCopy {
    type V = SpecTableCopy;

    open spec fn view(&self) -> Self::V {
        SpecTableCopy {
            x: self.x@,
            y: self.y@,
        }
    }
}
pub type TableCopyInner = (Tableidx, Tableidx);

pub type TableCopyInnerRef<'a> = (&'a Tableidx, &'a Tableidx);
impl<'a> From<&'a TableCopy> for TableCopyInnerRef<'a> {
    fn ex_from(m: &'a TableCopy) -> TableCopyInnerRef<'a> {
        (&m.x, &m.y)
    }
}

impl From<TableCopyInner> for TableCopy {
    fn ex_from(m: TableCopyInner) -> TableCopy {
        let (x, y) = m;
        TableCopy { x, y }
    }
}

pub struct TableCopyMapper;
impl View for TableCopyMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for TableCopyMapper {
    type Src = SpecTableCopyInner;
    type Dst = SpecTableCopy;
}
impl SpecIsoProof for TableCopyMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for TableCopyMapper {
    type Src = TableCopyInner;
    type Dst = TableCopy;
    type RefSrc = TableCopyInnerRef<'a>;
}
type SpecTableCopyCombinatorAlias1 = (SpecTableidxCombinator, SpecTableidxCombinator);
pub struct SpecTableCopyCombinator(pub SpecTableCopyCombinatorAlias);

impl SpecCombinator for SpecTableCopyCombinator {
    type Type = SpecTableCopy;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTableCopyCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTableCopyCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTableCopyCombinatorAlias = Mapped<SpecTableCopyCombinatorAlias1, TableCopyMapper>;
type TableCopyCombinatorAlias1 = (TableidxCombinator, TableidxCombinator);
pub struct TableCopyCombinator1(pub TableCopyCombinatorAlias1);
impl View for TableCopyCombinator1 {
    type V = SpecTableCopyCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(TableCopyCombinator1, TableCopyCombinatorAlias1);

pub struct TableCopyCombinator(pub TableCopyCombinatorAlias);

impl View for TableCopyCombinator {
    type V = SpecTableCopyCombinator;
    open spec fn view(&self) -> Self::V { SpecTableCopyCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TableCopyCombinator {
    type Type = TableCopy;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TableCopyCombinatorAlias = Mapped<TableCopyCombinator1, TableCopyMapper>;


pub open spec fn spec_table_copy() -> SpecTableCopyCombinator {
    SpecTableCopyCombinator(
    Mapped {
        inner: (spec_tableidx(), spec_tableidx()),
        mapper: TableCopyMapper,
    })
}

                
pub fn table_copy<'a>() -> (o: TableCopyCombinator)
    ensures o@ == spec_table_copy(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TableCopyCombinator(
    Mapped {
        inner: TableCopyCombinator1((tableidx(), tableidx())),
        mapper: TableCopyMapper,
    });
    assert({
        &&& combinator@ == spec_table_copy()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_table_copy<'a>(input: &'a [u8]) -> (res: PResult<<TableCopyCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_table_copy().spec_parse(input@) == Some((n as int, v@)),
        spec_table_copy().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_table_copy().spec_parse(input@) is None,
        spec_table_copy().spec_parse(input@) is None ==> res is Err,
{
    let combinator = table_copy();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_table_copy<'a>(v: <TableCopyCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_table_copy().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_table_copy().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_table_copy().spec_serialize(v@))
        },
{
    let combinator = table_copy();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn table_copy_len<'a>(v: <TableCopyCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_table_copy().wf(v@),
        spec_table_copy().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_table_copy().spec_serialize(v@).len(),
{
    let combinator = table_copy();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecTableGrow = SpecTableidx;
pub type TableGrow = Tableidx;
pub type TableGrowRef<'a> = &'a Tableidx;


pub struct SpecTableGrowCombinator(pub SpecTableGrowCombinatorAlias);

impl SpecCombinator for SpecTableGrowCombinator {
    type Type = SpecTableGrow;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTableGrowCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTableGrowCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTableGrowCombinatorAlias = SpecTableidxCombinator;

pub struct TableGrowCombinator(pub TableGrowCombinatorAlias);

impl View for TableGrowCombinator {
    type V = SpecTableGrowCombinator;
    open spec fn view(&self) -> Self::V { SpecTableGrowCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TableGrowCombinator {
    type Type = TableGrow;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TableGrowCombinatorAlias = TableidxCombinator;


pub open spec fn spec_table_grow() -> SpecTableGrowCombinator {
    SpecTableGrowCombinator(spec_tableidx())
}

                
pub fn table_grow<'a>() -> (o: TableGrowCombinator)
    ensures o@ == spec_table_grow(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TableGrowCombinator(tableidx());
    assert({
        &&& combinator@ == spec_table_grow()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_table_grow<'a>(input: &'a [u8]) -> (res: PResult<<TableGrowCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_table_grow().spec_parse(input@) == Some((n as int, v@)),
        spec_table_grow().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_table_grow().spec_parse(input@) is None,
        spec_table_grow().spec_parse(input@) is None ==> res is Err,
{
    let combinator = table_grow();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_table_grow<'a>(v: <TableGrowCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_table_grow().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_table_grow().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_table_grow().spec_serialize(v@))
        },
{
    let combinator = table_grow();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn table_grow_len<'a>(v: <TableGrowCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_table_grow().wf(v@),
        spec_table_grow().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_table_grow().spec_serialize(v@).len(),
{
    let combinator = table_grow();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecTableSize = SpecTableidx;
pub type TableSize = Tableidx;
pub type TableSizeRef<'a> = &'a Tableidx;


pub struct SpecTableSizeCombinator(pub SpecTableSizeCombinatorAlias);

impl SpecCombinator for SpecTableSizeCombinator {
    type Type = SpecTableSize;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTableSizeCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTableSizeCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTableSizeCombinatorAlias = SpecTableidxCombinator;

pub struct TableSizeCombinator(pub TableSizeCombinatorAlias);

impl View for TableSizeCombinator {
    type V = SpecTableSizeCombinator;
    open spec fn view(&self) -> Self::V { SpecTableSizeCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TableSizeCombinator {
    type Type = TableSize;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TableSizeCombinatorAlias = TableidxCombinator;


pub open spec fn spec_table_size() -> SpecTableSizeCombinator {
    SpecTableSizeCombinator(spec_tableidx())
}

                
pub fn table_size<'a>() -> (o: TableSizeCombinator)
    ensures o@ == spec_table_size(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TableSizeCombinator(tableidx());
    assert({
        &&& combinator@ == spec_table_size()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_table_size<'a>(input: &'a [u8]) -> (res: PResult<<TableSizeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_table_size().spec_parse(input@) == Some((n as int, v@)),
        spec_table_size().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_table_size().spec_parse(input@) is None,
        spec_table_size().spec_parse(input@) is None ==> res is Err,
{
    let combinator = table_size();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_table_size<'a>(v: <TableSizeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_table_size().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_table_size().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_table_size().spec_serialize(v@))
        },
{
    let combinator = table_size();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn table_size_len<'a>(v: <TableSizeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_table_size().wf(v@),
        spec_table_size().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_table_size().spec_serialize(v@).len(),
{
    let combinator = table_size();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecTableFill = SpecTableidx;
pub type TableFill = Tableidx;
pub type TableFillRef<'a> = &'a Tableidx;


pub struct SpecTableFillCombinator(pub SpecTableFillCombinatorAlias);

impl SpecCombinator for SpecTableFillCombinator {
    type Type = SpecTableFill;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTableFillCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTableFillCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTableFillCombinatorAlias = SpecTableidxCombinator;

pub struct TableFillCombinator(pub TableFillCombinatorAlias);

impl View for TableFillCombinator {
    type V = SpecTableFillCombinator;
    open spec fn view(&self) -> Self::V { SpecTableFillCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TableFillCombinator {
    type Type = TableFill;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TableFillCombinatorAlias = TableidxCombinator;


pub open spec fn spec_table_fill() -> SpecTableFillCombinator {
    SpecTableFillCombinator(spec_tableidx())
}

                
pub fn table_fill<'a>() -> (o: TableFillCombinator)
    ensures o@ == spec_table_fill(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TableFillCombinator(tableidx());
    assert({
        &&& combinator@ == spec_table_fill()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_table_fill<'a>(input: &'a [u8]) -> (res: PResult<<TableFillCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_table_fill().spec_parse(input@) == Some((n as int, v@)),
        spec_table_fill().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_table_fill().spec_parse(input@) is None,
        spec_table_fill().spec_parse(input@) is None ==> res is Err,
{
    let combinator = table_fill();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_table_fill<'a>(v: <TableFillCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_table_fill().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_table_fill().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_table_fill().spec_serialize(v@))
        },
{
    let combinator = table_fill();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn table_fill_len<'a>(v: <TableFillCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_table_fill().wf(v@),
        spec_table_fill().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_table_fill().spec_serialize(v@).len(),
{
    let combinator = table_fill();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecMemoryInit = SpecDataidx;
pub type MemoryInit = Dataidx;
pub type MemoryInitRef<'a> = &'a Dataidx;


pub const MemoryInit_0_BACK_CONST: u8 = 0;

pub struct SpecMemoryInitCombinator(pub SpecMemoryInitCombinatorAlias);

impl SpecCombinator for SpecMemoryInitCombinator {
    type Type = SpecMemoryInit;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecMemoryInitCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecMemoryInitCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecMemoryInitCombinatorAlias = Terminated<SpecDataidxCombinator, Tag<U8, u8>>;


pub struct MemoryInitCombinator(pub MemoryInitCombinatorAlias);

impl View for MemoryInitCombinator {
    type V = SpecMemoryInitCombinator;
    open spec fn view(&self) -> Self::V { SpecMemoryInitCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for MemoryInitCombinator {
    type Type = MemoryInit;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type MemoryInitCombinatorAlias = Terminated<DataidxCombinator, Tag<U8, u8>>;


pub open spec fn spec_memory_init() -> SpecMemoryInitCombinator {
    SpecMemoryInitCombinator(Terminated(spec_dataidx(), Tag::spec_new(U8, MemoryInit_0_BACK_CONST)))
}

                
pub fn memory_init<'a>() -> (o: MemoryInitCombinator)
    ensures o@ == spec_memory_init(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = MemoryInitCombinator(Terminated(dataidx(), Tag::new(U8, MemoryInit_0_BACK_CONST)));
    assert({
        &&& combinator@ == spec_memory_init()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_memory_init<'a>(input: &'a [u8]) -> (res: PResult<<MemoryInitCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_memory_init().spec_parse(input@) == Some((n as int, v@)),
        spec_memory_init().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_memory_init().spec_parse(input@) is None,
        spec_memory_init().spec_parse(input@) is None ==> res is Err,
{
    let combinator = memory_init();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_memory_init<'a>(v: <MemoryInitCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_memory_init().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_memory_init().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_memory_init().spec_serialize(v@))
        },
{
    let combinator = memory_init();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn memory_init_len<'a>(v: <MemoryInitCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_memory_init().wf(v@),
        spec_memory_init().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_memory_init().spec_serialize(v@).len(),
{
    let combinator = memory_init();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecMemoryCopy {
    pub reserved: Seq<u8>,
}

pub type SpecMemoryCopyInner = Seq<u8>;


impl SpecFrom<SpecMemoryCopy> for SpecMemoryCopyInner {
    open spec fn spec_from(m: SpecMemoryCopy) -> SpecMemoryCopyInner {
        m.reserved
    }
}

impl SpecFrom<SpecMemoryCopyInner> for SpecMemoryCopy {
    open spec fn spec_from(m: SpecMemoryCopyInner) -> SpecMemoryCopy {
        let reserved = m;
        SpecMemoryCopy { reserved }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct MemoryCopy<'a> {
    pub reserved: &'a [u8],
}

impl View for MemoryCopy<'_> {
    type V = SpecMemoryCopy;

    open spec fn view(&self) -> Self::V {
        SpecMemoryCopy {
            reserved: self.reserved@,
        }
    }
}
pub type MemoryCopyInner<'a> = &'a [u8];

pub type MemoryCopyInnerRef<'a> = &'a &'a [u8];
impl<'a> From<&'a MemoryCopy<'a>> for MemoryCopyInnerRef<'a> {
    fn ex_from(m: &'a MemoryCopy) -> MemoryCopyInnerRef<'a> {
        &m.reserved
    }
}

impl<'a> From<MemoryCopyInner<'a>> for MemoryCopy<'a> {
    fn ex_from(m: MemoryCopyInner) -> MemoryCopy {
        let reserved = m;
        MemoryCopy { reserved }
    }
}

pub struct MemoryCopyMapper;
impl View for MemoryCopyMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for MemoryCopyMapper {
    type Src = SpecMemoryCopyInner;
    type Dst = SpecMemoryCopy;
}
impl SpecIsoProof for MemoryCopyMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for MemoryCopyMapper {
    type Src = MemoryCopyInner<'a>;
    type Dst = MemoryCopy<'a>;
    type RefSrc = MemoryCopyInnerRef<'a>;
}
pub spec const SPEC_MEMORYCOPYRESERVED_CONST: Seq<u8> = seq![0, 0];
pub struct SpecMemoryCopyCombinator(pub SpecMemoryCopyCombinatorAlias);

impl SpecCombinator for SpecMemoryCopyCombinator {
    type Type = SpecMemoryCopy;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecMemoryCopyCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecMemoryCopyCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecMemoryCopyCombinatorAlias = Mapped<Refined<bytes::Fixed<2>, TagPred<Seq<u8>>>, MemoryCopyMapper>;
pub exec static MEMORYCOPYRESERVED_CONST: [u8; 2]
    ensures MEMORYCOPYRESERVED_CONST@ == SPEC_MEMORYCOPYRESERVED_CONST,
{
    let arr: [u8; 2] = [0, 0];
    assert(arr@ == SPEC_MEMORYCOPYRESERVED_CONST);
    arr
}

pub struct MemoryCopyCombinator(pub MemoryCopyCombinatorAlias);

impl View for MemoryCopyCombinator {
    type V = SpecMemoryCopyCombinator;
    open spec fn view(&self) -> Self::V { SpecMemoryCopyCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for MemoryCopyCombinator {
    type Type = MemoryCopy<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type MemoryCopyCombinatorAlias = Mapped<Refined<bytes::Fixed<2>, TagPred<[u8; 2]>>, MemoryCopyMapper>;


pub open spec fn spec_memory_copy() -> SpecMemoryCopyCombinator {
    SpecMemoryCopyCombinator(
    Mapped {
        inner: Refined { inner: bytes::Fixed::<2>, predicate: TagPred(SPEC_MEMORYCOPYRESERVED_CONST) },
        mapper: MemoryCopyMapper,
    })
}

                
pub fn memory_copy<'a>() -> (o: MemoryCopyCombinator)
    ensures o@ == spec_memory_copy(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = MemoryCopyCombinator(
    Mapped {
        inner: Refined { inner: bytes::Fixed::<2>, predicate: TagPred(MEMORYCOPYRESERVED_CONST) },
        mapper: MemoryCopyMapper,
    });
    assert({
        &&& combinator@ == spec_memory_copy()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_memory_copy<'a>(input: &'a [u8]) -> (res: PResult<<MemoryCopyCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_memory_copy().spec_parse(input@) == Some((n as int, v@)),
        spec_memory_copy().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_memory_copy().spec_parse(input@) is None,
        spec_memory_copy().spec_parse(input@) is None ==> res is Err,
{
    let combinator = memory_copy();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_memory_copy<'a>(v: <MemoryCopyCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_memory_copy().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_memory_copy().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_memory_copy().spec_serialize(v@))
        },
{
    let combinator = memory_copy();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn memory_copy_len<'a>(v: <MemoryCopyCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_memory_copy().wf(v@),
        spec_memory_copy().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_memory_copy().spec_serialize(v@).len(),
{
    let combinator = memory_copy();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecMemoryFill {
    pub reserved: u8,
}

pub type SpecMemoryFillInner = u8;


impl SpecFrom<SpecMemoryFill> for SpecMemoryFillInner {
    open spec fn spec_from(m: SpecMemoryFill) -> SpecMemoryFillInner {
        m.reserved
    }
}

impl SpecFrom<SpecMemoryFillInner> for SpecMemoryFill {
    open spec fn spec_from(m: SpecMemoryFillInner) -> SpecMemoryFill {
        let reserved = m;
        SpecMemoryFill { reserved }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct MemoryFill {
    pub reserved: u8,
}

impl View for MemoryFill {
    type V = SpecMemoryFill;

    open spec fn view(&self) -> Self::V {
        SpecMemoryFill {
            reserved: self.reserved@,
        }
    }
}
pub type MemoryFillInner = u8;

pub type MemoryFillInnerRef<'a> = &'a u8;
impl<'a> From<&'a MemoryFill> for MemoryFillInnerRef<'a> {
    fn ex_from(m: &'a MemoryFill) -> MemoryFillInnerRef<'a> {
        &m.reserved
    }
}

impl From<MemoryFillInner> for MemoryFill {
    fn ex_from(m: MemoryFillInner) -> MemoryFill {
        let reserved = m;
        MemoryFill { reserved }
    }
}

pub struct MemoryFillMapper;
impl View for MemoryFillMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for MemoryFillMapper {
    type Src = SpecMemoryFillInner;
    type Dst = SpecMemoryFill;
}
impl SpecIsoProof for MemoryFillMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for MemoryFillMapper {
    type Src = MemoryFillInner;
    type Dst = MemoryFill;
    type RefSrc = MemoryFillInnerRef<'a>;
}
pub const MEMORYFILLRESERVED_CONST: u8 = 0;

pub struct SpecMemoryFillCombinator(pub SpecMemoryFillCombinatorAlias);

impl SpecCombinator for SpecMemoryFillCombinator {
    type Type = SpecMemoryFill;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecMemoryFillCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecMemoryFillCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecMemoryFillCombinatorAlias = Mapped<Refined<U8, TagPred<u8>>, MemoryFillMapper>;

pub struct MemoryFillCombinator(pub MemoryFillCombinatorAlias);

impl View for MemoryFillCombinator {
    type V = SpecMemoryFillCombinator;
    open spec fn view(&self) -> Self::V { SpecMemoryFillCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for MemoryFillCombinator {
    type Type = MemoryFill;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type MemoryFillCombinatorAlias = Mapped<Refined<U8, TagPred<u8>>, MemoryFillMapper>;


pub open spec fn spec_memory_fill() -> SpecMemoryFillCombinator {
    SpecMemoryFillCombinator(
    Mapped {
        inner: Refined { inner: U8, predicate: TagPred(MEMORYFILLRESERVED_CONST) },
        mapper: MemoryFillMapper,
    })
}

                
pub fn memory_fill<'a>() -> (o: MemoryFillCombinator)
    ensures o@ == spec_memory_fill(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = MemoryFillCombinator(
    Mapped {
        inner: Refined { inner: U8, predicate: TagPred(MEMORYFILLRESERVED_CONST) },
        mapper: MemoryFillMapper,
    });
    assert({
        &&& combinator@ == spec_memory_fill()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_memory_fill<'a>(input: &'a [u8]) -> (res: PResult<<MemoryFillCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_memory_fill().spec_parse(input@) == Some((n as int, v@)),
        spec_memory_fill().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_memory_fill().spec_parse(input@) is None,
        spec_memory_fill().spec_parse(input@) is None ==> res is Err,
{
    let combinator = memory_fill();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_memory_fill<'a>(v: <MemoryFillCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_memory_fill().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_memory_fill().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_memory_fill().spec_serialize(v@))
        },
{
    let combinator = memory_fill();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn memory_fill_len<'a>(v: <MemoryFillCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_memory_fill().wf(v@),
        spec_memory_fill().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_memory_fill().spec_serialize(v@).len(),
{
    let combinator = memory_fill();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub enum SpecInstrWithFcRest {
    Variant0(SpecTableInit),
    Variant1(SpecElemDrop),
    Variant2(SpecTableCopy),
    Variant3(SpecTableGrow),
    Variant4(SpecTableSize),
    Variant5(SpecTableFill),
    Variant6(SpecMemoryInit),
    Variant7(SpecDataDrop),
    Variant8(SpecMemoryCopy),
    Variant9(SpecMemoryFill),
    Variant10(SpecEmpty),
}

pub type SpecInstrWithFcRestInner = Either<SpecTableInit, Either<SpecElemDrop, Either<SpecTableCopy, Either<SpecTableGrow, Either<SpecTableSize, Either<SpecTableFill, Either<SpecMemoryInit, Either<SpecDataDrop, Either<SpecMemoryCopy, Either<SpecMemoryFill, SpecEmpty>>>>>>>>>>;

impl SpecFrom<SpecInstrWithFcRest> for SpecInstrWithFcRestInner {
    open spec fn spec_from(m: SpecInstrWithFcRest) -> SpecInstrWithFcRestInner {
        match m {
            SpecInstrWithFcRest::Variant0(m) => Either::Left(m),
            SpecInstrWithFcRest::Variant1(m) => Either::Right(Either::Left(m)),
            SpecInstrWithFcRest::Variant2(m) => Either::Right(Either::Right(Either::Left(m))),
            SpecInstrWithFcRest::Variant3(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            SpecInstrWithFcRest::Variant4(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            SpecInstrWithFcRest::Variant5(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))),
            SpecInstrWithFcRest::Variant6(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))),
            SpecInstrWithFcRest::Variant7(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))),
            SpecInstrWithFcRest::Variant8(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))))),
            SpecInstrWithFcRest::Variant9(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))))),
            SpecInstrWithFcRest::Variant10(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))))))),
        }
    }

}

                
impl SpecFrom<SpecInstrWithFcRestInner> for SpecInstrWithFcRest {
    open spec fn spec_from(m: SpecInstrWithFcRestInner) -> SpecInstrWithFcRest {
        match m {
            Either::Left(m) => SpecInstrWithFcRest::Variant0(m),
            Either::Right(Either::Left(m)) => SpecInstrWithFcRest::Variant1(m),
            Either::Right(Either::Right(Either::Left(m))) => SpecInstrWithFcRest::Variant2(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => SpecInstrWithFcRest::Variant3(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => SpecInstrWithFcRest::Variant4(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))) => SpecInstrWithFcRest::Variant5(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))) => SpecInstrWithFcRest::Variant6(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))) => SpecInstrWithFcRest::Variant7(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))))) => SpecInstrWithFcRest::Variant8(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))))) => SpecInstrWithFcRest::Variant9(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))))))) => SpecInstrWithFcRest::Variant10(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InstrWithFcRest<'a> {
    Variant0(TableInit),
    Variant1(ElemDrop),
    Variant2(TableCopy),
    Variant3(TableGrow),
    Variant4(TableSize),
    Variant5(TableFill),
    Variant6(MemoryInit),
    Variant7(DataDrop),
    Variant8(MemoryCopy<'a>),
    Variant9(MemoryFill),
    Variant10(Empty<'a>),
}

pub type InstrWithFcRestInner<'a> = Either<TableInit, Either<ElemDrop, Either<TableCopy, Either<TableGrow, Either<TableSize, Either<TableFill, Either<MemoryInit, Either<DataDrop, Either<MemoryCopy<'a>, Either<MemoryFill, Empty<'a>>>>>>>>>>>;

pub type InstrWithFcRestInnerRef<'a> = Either<&'a TableInit, Either<&'a ElemDrop, Either<&'a TableCopy, Either<&'a TableGrow, Either<&'a TableSize, Either<&'a TableFill, Either<&'a MemoryInit, Either<&'a DataDrop, Either<&'a MemoryCopy<'a>, Either<&'a MemoryFill, &'a Empty<'a>>>>>>>>>>>;


impl<'a> View for InstrWithFcRest<'a> {
    type V = SpecInstrWithFcRest;
    open spec fn view(&self) -> Self::V {
        match self {
            InstrWithFcRest::Variant0(m) => SpecInstrWithFcRest::Variant0(m@),
            InstrWithFcRest::Variant1(m) => SpecInstrWithFcRest::Variant1(m@),
            InstrWithFcRest::Variant2(m) => SpecInstrWithFcRest::Variant2(m@),
            InstrWithFcRest::Variant3(m) => SpecInstrWithFcRest::Variant3(m@),
            InstrWithFcRest::Variant4(m) => SpecInstrWithFcRest::Variant4(m@),
            InstrWithFcRest::Variant5(m) => SpecInstrWithFcRest::Variant5(m@),
            InstrWithFcRest::Variant6(m) => SpecInstrWithFcRest::Variant6(m@),
            InstrWithFcRest::Variant7(m) => SpecInstrWithFcRest::Variant7(m@),
            InstrWithFcRest::Variant8(m) => SpecInstrWithFcRest::Variant8(m@),
            InstrWithFcRest::Variant9(m) => SpecInstrWithFcRest::Variant9(m@),
            InstrWithFcRest::Variant10(m) => SpecInstrWithFcRest::Variant10(m@),
        }
    }
}


impl<'a> From<&'a InstrWithFcRest<'a>> for InstrWithFcRestInnerRef<'a> {
    fn ex_from(m: &'a InstrWithFcRest<'a>) -> InstrWithFcRestInnerRef<'a> {
        match m {
            InstrWithFcRest::Variant0(m) => Either::Left(m),
            InstrWithFcRest::Variant1(m) => Either::Right(Either::Left(m)),
            InstrWithFcRest::Variant2(m) => Either::Right(Either::Right(Either::Left(m))),
            InstrWithFcRest::Variant3(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            InstrWithFcRest::Variant4(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            InstrWithFcRest::Variant5(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))),
            InstrWithFcRest::Variant6(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))),
            InstrWithFcRest::Variant7(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))),
            InstrWithFcRest::Variant8(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))))),
            InstrWithFcRest::Variant9(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))))),
            InstrWithFcRest::Variant10(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))))))),
        }
    }

}

impl<'a> From<InstrWithFcRestInner<'a>> for InstrWithFcRest<'a> {
    fn ex_from(m: InstrWithFcRestInner<'a>) -> InstrWithFcRest<'a> {
        match m {
            Either::Left(m) => InstrWithFcRest::Variant0(m),
            Either::Right(Either::Left(m)) => InstrWithFcRest::Variant1(m),
            Either::Right(Either::Right(Either::Left(m))) => InstrWithFcRest::Variant2(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => InstrWithFcRest::Variant3(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => InstrWithFcRest::Variant4(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))) => InstrWithFcRest::Variant5(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))) => InstrWithFcRest::Variant6(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))) => InstrWithFcRest::Variant7(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))))) => InstrWithFcRest::Variant8(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))))) => InstrWithFcRest::Variant9(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))))))) => InstrWithFcRest::Variant10(m),
        }
    }
    
}


pub struct InstrWithFcRestMapper;
impl View for InstrWithFcRestMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrWithFcRestMapper {
    type Src = SpecInstrWithFcRestInner;
    type Dst = SpecInstrWithFcRest;
}
impl SpecIsoProof for InstrWithFcRestMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrWithFcRestMapper {
    type Src = InstrWithFcRestInner<'a>;
    type Dst = InstrWithFcRest<'a>;
    type RefSrc = InstrWithFcRestInnerRef<'a>;
}

type SpecInstrWithFcRestCombinatorAlias1 = Choice<Cond<SpecMemoryFillCombinator>, Cond<SpecEmptyCombinator>>;
type SpecInstrWithFcRestCombinatorAlias2 = Choice<Cond<SpecMemoryCopyCombinator>, SpecInstrWithFcRestCombinatorAlias1>;
type SpecInstrWithFcRestCombinatorAlias3 = Choice<Cond<SpecDataDropCombinator>, SpecInstrWithFcRestCombinatorAlias2>;
type SpecInstrWithFcRestCombinatorAlias4 = Choice<Cond<SpecMemoryInitCombinator>, SpecInstrWithFcRestCombinatorAlias3>;
type SpecInstrWithFcRestCombinatorAlias5 = Choice<Cond<SpecTableFillCombinator>, SpecInstrWithFcRestCombinatorAlias4>;
type SpecInstrWithFcRestCombinatorAlias6 = Choice<Cond<SpecTableSizeCombinator>, SpecInstrWithFcRestCombinatorAlias5>;
type SpecInstrWithFcRestCombinatorAlias7 = Choice<Cond<SpecTableGrowCombinator>, SpecInstrWithFcRestCombinatorAlias6>;
type SpecInstrWithFcRestCombinatorAlias8 = Choice<Cond<SpecTableCopyCombinator>, SpecInstrWithFcRestCombinatorAlias7>;
type SpecInstrWithFcRestCombinatorAlias9 = Choice<Cond<SpecElemDropCombinator>, SpecInstrWithFcRestCombinatorAlias8>;
type SpecInstrWithFcRestCombinatorAlias10 = Choice<Cond<SpecTableInitCombinator>, SpecInstrWithFcRestCombinatorAlias9>;
pub struct SpecInstrWithFcRestCombinator(pub SpecInstrWithFcRestCombinatorAlias);

impl SpecCombinator for SpecInstrWithFcRestCombinator {
    type Type = SpecInstrWithFcRest;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrWithFcRestCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrWithFcRestCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrWithFcRestCombinatorAlias = Mapped<SpecInstrWithFcRestCombinatorAlias10, InstrWithFcRestMapper>;
type InstrWithFcRestCombinatorAlias1 = Choice<Cond<MemoryFillCombinator>, Cond<EmptyCombinator>>;
type InstrWithFcRestCombinatorAlias2 = Choice<Cond<MemoryCopyCombinator>, InstrWithFcRestCombinator1>;
type InstrWithFcRestCombinatorAlias3 = Choice<Cond<DataDropCombinator>, InstrWithFcRestCombinator2>;
type InstrWithFcRestCombinatorAlias4 = Choice<Cond<MemoryInitCombinator>, InstrWithFcRestCombinator3>;
type InstrWithFcRestCombinatorAlias5 = Choice<Cond<TableFillCombinator>, InstrWithFcRestCombinator4>;
type InstrWithFcRestCombinatorAlias6 = Choice<Cond<TableSizeCombinator>, InstrWithFcRestCombinator5>;
type InstrWithFcRestCombinatorAlias7 = Choice<Cond<TableGrowCombinator>, InstrWithFcRestCombinator6>;
type InstrWithFcRestCombinatorAlias8 = Choice<Cond<TableCopyCombinator>, InstrWithFcRestCombinator7>;
type InstrWithFcRestCombinatorAlias9 = Choice<Cond<ElemDropCombinator>, InstrWithFcRestCombinator8>;
type InstrWithFcRestCombinatorAlias10 = Choice<Cond<TableInitCombinator>, InstrWithFcRestCombinator9>;
pub struct InstrWithFcRestCombinator1(pub InstrWithFcRestCombinatorAlias1);
impl View for InstrWithFcRestCombinator1 {
    type V = SpecInstrWithFcRestCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFcRestCombinator1, InstrWithFcRestCombinatorAlias1);

pub struct InstrWithFcRestCombinator2(pub InstrWithFcRestCombinatorAlias2);
impl View for InstrWithFcRestCombinator2 {
    type V = SpecInstrWithFcRestCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFcRestCombinator2, InstrWithFcRestCombinatorAlias2);

pub struct InstrWithFcRestCombinator3(pub InstrWithFcRestCombinatorAlias3);
impl View for InstrWithFcRestCombinator3 {
    type V = SpecInstrWithFcRestCombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFcRestCombinator3, InstrWithFcRestCombinatorAlias3);

pub struct InstrWithFcRestCombinator4(pub InstrWithFcRestCombinatorAlias4);
impl View for InstrWithFcRestCombinator4 {
    type V = SpecInstrWithFcRestCombinatorAlias4;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFcRestCombinator4, InstrWithFcRestCombinatorAlias4);

pub struct InstrWithFcRestCombinator5(pub InstrWithFcRestCombinatorAlias5);
impl View for InstrWithFcRestCombinator5 {
    type V = SpecInstrWithFcRestCombinatorAlias5;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFcRestCombinator5, InstrWithFcRestCombinatorAlias5);

pub struct InstrWithFcRestCombinator6(pub InstrWithFcRestCombinatorAlias6);
impl View for InstrWithFcRestCombinator6 {
    type V = SpecInstrWithFcRestCombinatorAlias6;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFcRestCombinator6, InstrWithFcRestCombinatorAlias6);

pub struct InstrWithFcRestCombinator7(pub InstrWithFcRestCombinatorAlias7);
impl View for InstrWithFcRestCombinator7 {
    type V = SpecInstrWithFcRestCombinatorAlias7;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFcRestCombinator7, InstrWithFcRestCombinatorAlias7);

pub struct InstrWithFcRestCombinator8(pub InstrWithFcRestCombinatorAlias8);
impl View for InstrWithFcRestCombinator8 {
    type V = SpecInstrWithFcRestCombinatorAlias8;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFcRestCombinator8, InstrWithFcRestCombinatorAlias8);

pub struct InstrWithFcRestCombinator9(pub InstrWithFcRestCombinatorAlias9);
impl View for InstrWithFcRestCombinator9 {
    type V = SpecInstrWithFcRestCombinatorAlias9;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFcRestCombinator9, InstrWithFcRestCombinatorAlias9);

pub struct InstrWithFcRestCombinator10(pub InstrWithFcRestCombinatorAlias10);
impl View for InstrWithFcRestCombinator10 {
    type V = SpecInstrWithFcRestCombinatorAlias10;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFcRestCombinator10, InstrWithFcRestCombinatorAlias10);

pub struct InstrWithFcRestCombinator(pub InstrWithFcRestCombinatorAlias);

impl View for InstrWithFcRestCombinator {
    type V = SpecInstrWithFcRestCombinator;
    open spec fn view(&self) -> Self::V { SpecInstrWithFcRestCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrWithFcRestCombinator {
    type Type = InstrWithFcRest<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrWithFcRestCombinatorAlias = Mapped<InstrWithFcRestCombinator10, InstrWithFcRestMapper>;


pub open spec fn spec_instr_with_fc_rest(tag: u64) -> SpecInstrWithFcRestCombinator {
    SpecInstrWithFcRestCombinator(Mapped { inner: Choice(Cond { cond: tag == 12, inner: spec_table_init() }, Choice(Cond { cond: tag == 13, inner: spec_elem_drop() }, Choice(Cond { cond: tag == 14, inner: spec_table_copy() }, Choice(Cond { cond: tag == 15, inner: spec_table_grow() }, Choice(Cond { cond: tag == 16, inner: spec_table_size() }, Choice(Cond { cond: tag == 17, inner: spec_table_fill() }, Choice(Cond { cond: tag == 8, inner: spec_memory_init() }, Choice(Cond { cond: tag == 9, inner: spec_data_drop() }, Choice(Cond { cond: tag == 10, inner: spec_memory_copy() }, Choice(Cond { cond: tag == 11, inner: spec_memory_fill() }, Cond { cond: !(tag == 12 || tag == 13 || tag == 14 || tag == 15 || tag == 16 || tag == 17 || tag == 8 || tag == 9 || tag == 10 || tag == 11), inner: spec_empty() })))))))))), mapper: InstrWithFcRestMapper })
}

pub fn instr_with_fc_rest<'a>(tag: u64) -> (o: InstrWithFcRestCombinator)
    ensures o@ == spec_instr_with_fc_rest(tag@),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrWithFcRestCombinator(Mapped { inner: InstrWithFcRestCombinator10(Choice::new(Cond { cond: tag == 12, inner: table_init() }, InstrWithFcRestCombinator9(Choice::new(Cond { cond: tag == 13, inner: elem_drop() }, InstrWithFcRestCombinator8(Choice::new(Cond { cond: tag == 14, inner: table_copy() }, InstrWithFcRestCombinator7(Choice::new(Cond { cond: tag == 15, inner: table_grow() }, InstrWithFcRestCombinator6(Choice::new(Cond { cond: tag == 16, inner: table_size() }, InstrWithFcRestCombinator5(Choice::new(Cond { cond: tag == 17, inner: table_fill() }, InstrWithFcRestCombinator4(Choice::new(Cond { cond: tag == 8, inner: memory_init() }, InstrWithFcRestCombinator3(Choice::new(Cond { cond: tag == 9, inner: data_drop() }, InstrWithFcRestCombinator2(Choice::new(Cond { cond: tag == 10, inner: memory_copy() }, InstrWithFcRestCombinator1(Choice::new(Cond { cond: tag == 11, inner: memory_fill() }, Cond { cond: !(tag == 12 || tag == 13 || tag == 14 || tag == 15 || tag == 16 || tag == 17 || tag == 8 || tag == 9 || tag == 10 || tag == 11), inner: empty() })))))))))))))))))))), mapper: InstrWithFcRestMapper });
    assert({
        &&& combinator@ == spec_instr_with_fc_rest(tag@)
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_with_fc_rest<'a>(input: &'a [u8], tag: u64) -> (res: PResult<<InstrWithFcRestCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_with_fc_rest(tag@).spec_parse(input@) == Some((n as int, v@)),
        spec_instr_with_fc_rest(tag@).spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_with_fc_rest(tag@).spec_parse(input@) is None,
        spec_instr_with_fc_rest(tag@).spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_with_fc_rest( tag );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_with_fc_rest<'a>(v: <InstrWithFcRestCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize, tag: u64) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_with_fc_rest(tag@).wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_with_fc_rest(tag@).spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_with_fc_rest(tag@).spec_serialize(v@))
        },
{
    let combinator = instr_with_fc_rest( tag );
    combinator.serialize(v, data, pos)
}

pub fn instr_with_fc_rest_len<'a>(v: <InstrWithFcRestCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, tag: u64) -> (serialize_len: usize)
    requires
        spec_instr_with_fc_rest(tag@).wf(v@),
        spec_instr_with_fc_rest(tag@).spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_with_fc_rest(tag@).spec_serialize(v@).len(),
{
    let combinator = instr_with_fc_rest( tag );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}


pub struct SpecInstrWithFc {
    pub tag: u64,
    pub rest: SpecInstrWithFcRest,
}

pub type SpecInstrWithFcInner = (u64, SpecInstrWithFcRest);


impl SpecFrom<SpecInstrWithFc> for SpecInstrWithFcInner {
    open spec fn spec_from(m: SpecInstrWithFc) -> SpecInstrWithFcInner {
        (m.tag, m.rest)
    }
}

impl SpecFrom<SpecInstrWithFcInner> for SpecInstrWithFc {
    open spec fn spec_from(m: SpecInstrWithFcInner) -> SpecInstrWithFc {
        let (tag, rest) = m;
        SpecInstrWithFc { tag, rest }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct InstrWithFc<'a> {
    pub tag: u64,
    pub rest: InstrWithFcRest<'a>,
}

impl View for InstrWithFc<'_> {
    type V = SpecInstrWithFc;

    open spec fn view(&self) -> Self::V {
        SpecInstrWithFc {
            tag: self.tag@,
            rest: self.rest@,
        }
    }
}
pub type InstrWithFcInner<'a> = (u64, InstrWithFcRest<'a>);

pub type InstrWithFcInnerRef<'a> = (&'a u64, &'a InstrWithFcRest<'a>);
impl<'a> From<&'a InstrWithFc<'a>> for InstrWithFcInnerRef<'a> {
    fn ex_from(m: &'a InstrWithFc) -> InstrWithFcInnerRef<'a> {
        (&m.tag, &m.rest)
    }
}

impl<'a> From<InstrWithFcInner<'a>> for InstrWithFc<'a> {
    fn ex_from(m: InstrWithFcInner) -> InstrWithFc {
        let (tag, rest) = m;
        InstrWithFc { tag, rest }
    }
}

pub struct InstrWithFcMapper;
impl View for InstrWithFcMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrWithFcMapper {
    type Src = SpecInstrWithFcInner;
    type Dst = SpecInstrWithFc;
}
impl SpecIsoProof for InstrWithFcMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrWithFcMapper {
    type Src = InstrWithFcInner<'a>;
    type Dst = InstrWithFc<'a>;
    type RefSrc = InstrWithFcInnerRef<'a>;
}

pub struct SpecInstrWithFcCombinator(pub SpecInstrWithFcCombinatorAlias);

impl SpecCombinator for SpecInstrWithFcCombinator {
    type Type = SpecInstrWithFc;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrWithFcCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrWithFcCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrWithFcCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, SpecInstrWithFcRestCombinator>, InstrWithFcMapper>;

pub struct InstrWithFcCombinator(pub InstrWithFcCombinatorAlias);

impl View for InstrWithFcCombinator {
    type V = SpecInstrWithFcCombinator;
    open spec fn view(&self) -> Self::V { SpecInstrWithFcCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrWithFcCombinator {
    type Type = InstrWithFc<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrWithFcCombinatorAlias = Mapped<Pair<UnsignedLEB128, InstrWithFcRestCombinator, InstrWithFcCont0>, InstrWithFcMapper>;


pub open spec fn spec_instr_with_fc() -> SpecInstrWithFcCombinator {
    SpecInstrWithFcCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_instr_with_fc_cont0(deps)),
        mapper: InstrWithFcMapper,
    })
}

pub open spec fn spec_instr_with_fc_cont0(deps: u64) -> SpecInstrWithFcRestCombinator {
    let tag = deps;
    spec_instr_with_fc_rest(tag)
}

impl View for InstrWithFcCont0 {
    type V = spec_fn(u64) -> SpecInstrWithFcRestCombinator;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_instr_with_fc_cont0(deps)
        }
    }
}

                
pub fn instr_with_fc<'a>() -> (o: InstrWithFcCombinator)
    ensures o@ == spec_instr_with_fc(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrWithFcCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, InstrWithFcCont0),
        mapper: InstrWithFcMapper,
    });
    assert({
        &&& combinator@ == spec_instr_with_fc()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_with_fc<'a>(input: &'a [u8]) -> (res: PResult<<InstrWithFcCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_with_fc().spec_parse(input@) == Some((n as int, v@)),
        spec_instr_with_fc().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_with_fc().spec_parse(input@) is None,
        spec_instr_with_fc().spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_with_fc();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_with_fc<'a>(v: <InstrWithFcCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_with_fc().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_with_fc().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_with_fc().spec_serialize(v@))
        },
{
    let combinator = instr_with_fc();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn instr_with_fc_len<'a>(v: <InstrWithFcCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_instr_with_fc().wf(v@),
        spec_instr_with_fc().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_with_fc().spec_serialize(v@).len(),
{
    let combinator = instr_with_fc();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct InstrWithFcCont0;
type InstrWithFcCont0Type<'a, 'b> = &'b u64;
type InstrWithFcCont0SType<'a, 'x> = &'x u64;
type InstrWithFcCont0Input<'a, 'b, 'x> = POrSType<InstrWithFcCont0Type<'a, 'b>, InstrWithFcCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<InstrWithFcCont0Input<'a, 'b, 'x>> for InstrWithFcCont0 {
    type Output = InstrWithFcRestCombinator;

    open spec fn requires(&self, deps: InstrWithFcCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: InstrWithFcCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_instr_with_fc_cont0(deps@)
    }

    fn apply(&self, deps: InstrWithFcCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let tag = *deps;
                instr_with_fc_rest(tag)
            }
            POrSType::S(deps) => {
                let tag = deps;
                let tag = *tag;
                instr_with_fc_rest(tag)
            }
        }
    }
}
                
pub type SpecLaneidx = u8;
pub type Laneidx = u8;
pub type LaneidxRef<'a> = &'a u8;


pub struct SpecLaneidxCombinator(pub SpecLaneidxCombinatorAlias);

impl SpecCombinator for SpecLaneidxCombinator {
    type Type = SpecLaneidx;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecLaneidxCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecLaneidxCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecLaneidxCombinatorAlias = U8;

pub struct LaneidxCombinator(pub LaneidxCombinatorAlias);

impl View for LaneidxCombinator {
    type V = SpecLaneidxCombinator;
    open spec fn view(&self) -> Self::V { SpecLaneidxCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for LaneidxCombinator {
    type Type = Laneidx;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type LaneidxCombinatorAlias = U8;


pub open spec fn spec_laneidx() -> SpecLaneidxCombinator {
    SpecLaneidxCombinator(U8)
}

                
pub fn laneidx<'a>() -> (o: LaneidxCombinator)
    ensures o@ == spec_laneidx(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = LaneidxCombinator(U8);
    assert({
        &&& combinator@ == spec_laneidx()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_laneidx<'a>(input: &'a [u8]) -> (res: PResult<<LaneidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_laneidx().spec_parse(input@) == Some((n as int, v@)),
        spec_laneidx().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_laneidx().spec_parse(input@) is None,
        spec_laneidx().spec_parse(input@) is None ==> res is Err,
{
    let combinator = laneidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_laneidx<'a>(v: <LaneidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_laneidx().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_laneidx().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_laneidx().spec_serialize(v@))
        },
{
    let combinator = laneidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn laneidx_len<'a>(v: <LaneidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_laneidx().wf(v@),
        spec_laneidx().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_laneidx().spec_serialize(v@).len(),
{
    let combinator = laneidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecV128Lane {
    pub m: SpecMemarg,
    pub l: SpecLaneidx,
}

pub type SpecV128LaneInner = (SpecMemarg, SpecLaneidx);


impl SpecFrom<SpecV128Lane> for SpecV128LaneInner {
    open spec fn spec_from(m: SpecV128Lane) -> SpecV128LaneInner {
        (m.m, m.l)
    }
}

impl SpecFrom<SpecV128LaneInner> for SpecV128Lane {
    open spec fn spec_from(m: SpecV128LaneInner) -> SpecV128Lane {
        let (m, l) = m;
        SpecV128Lane { m, l }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct V128Lane {
    pub m: Memarg,
    pub l: Laneidx,
}

impl View for V128Lane {
    type V = SpecV128Lane;

    open spec fn view(&self) -> Self::V {
        SpecV128Lane {
            m: self.m@,
            l: self.l@,
        }
    }
}
pub type V128LaneInner = (Memarg, Laneidx);

pub type V128LaneInnerRef<'a> = (&'a Memarg, &'a Laneidx);
impl<'a> From<&'a V128Lane> for V128LaneInnerRef<'a> {
    fn ex_from(m: &'a V128Lane) -> V128LaneInnerRef<'a> {
        (&m.m, &m.l)
    }
}

impl From<V128LaneInner> for V128Lane {
    fn ex_from(m: V128LaneInner) -> V128Lane {
        let (m, l) = m;
        V128Lane { m, l }
    }
}

pub struct V128LaneMapper;
impl View for V128LaneMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for V128LaneMapper {
    type Src = SpecV128LaneInner;
    type Dst = SpecV128Lane;
}
impl SpecIsoProof for V128LaneMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for V128LaneMapper {
    type Src = V128LaneInner;
    type Dst = V128Lane;
    type RefSrc = V128LaneInnerRef<'a>;
}
type SpecV128LaneCombinatorAlias1 = (SpecMemargCombinator, SpecLaneidxCombinator);
pub struct SpecV128LaneCombinator(pub SpecV128LaneCombinatorAlias);

impl SpecCombinator for SpecV128LaneCombinator {
    type Type = SpecV128Lane;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecV128LaneCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecV128LaneCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecV128LaneCombinatorAlias = Mapped<SpecV128LaneCombinatorAlias1, V128LaneMapper>;
type V128LaneCombinatorAlias1 = (MemargCombinator, LaneidxCombinator);
pub struct V128LaneCombinator1(pub V128LaneCombinatorAlias1);
impl View for V128LaneCombinator1 {
    type V = SpecV128LaneCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(V128LaneCombinator1, V128LaneCombinatorAlias1);

pub struct V128LaneCombinator(pub V128LaneCombinatorAlias);

impl View for V128LaneCombinator {
    type V = SpecV128LaneCombinator;
    open spec fn view(&self) -> Self::V { SpecV128LaneCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for V128LaneCombinator {
    type Type = V128Lane;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type V128LaneCombinatorAlias = Mapped<V128LaneCombinator1, V128LaneMapper>;


pub open spec fn spec_v128_lane() -> SpecV128LaneCombinator {
    SpecV128LaneCombinator(
    Mapped {
        inner: (spec_memarg(), spec_laneidx()),
        mapper: V128LaneMapper,
    })
}

                
pub fn v128_lane<'a>() -> (o: V128LaneCombinator)
    ensures o@ == spec_v128_lane(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = V128LaneCombinator(
    Mapped {
        inner: V128LaneCombinator1((memarg(), laneidx())),
        mapper: V128LaneMapper,
    });
    assert({
        &&& combinator@ == spec_v128_lane()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_v128_lane<'a>(input: &'a [u8]) -> (res: PResult<<V128LaneCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_v128_lane().spec_parse(input@) == Some((n as int, v@)),
        spec_v128_lane().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_v128_lane().spec_parse(input@) is None,
        spec_v128_lane().spec_parse(input@) is None ==> res is Err,
{
    let combinator = v128_lane();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_v128_lane<'a>(v: <V128LaneCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_v128_lane().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_v128_lane().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_v128_lane().spec_serialize(v@))
        },
{
    let combinator = v128_lane();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn v128_lane_len<'a>(v: <V128LaneCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_v128_lane().wf(v@),
        spec_v128_lane().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_v128_lane().spec_serialize(v@).len(),
{
    let combinator = v128_lane();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecV128Const = Seq<u8>;
pub type V128Const<'a> = &'a [u8];
pub type V128ConstRef<'a> = &'a &'a [u8];


pub struct SpecV128ConstCombinator(pub SpecV128ConstCombinatorAlias);

impl SpecCombinator for SpecV128ConstCombinator {
    type Type = SpecV128Const;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecV128ConstCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecV128ConstCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecV128ConstCombinatorAlias = bytes::Fixed<16>;

pub struct V128ConstCombinator(pub V128ConstCombinatorAlias);

impl View for V128ConstCombinator {
    type V = SpecV128ConstCombinator;
    open spec fn view(&self) -> Self::V { SpecV128ConstCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for V128ConstCombinator {
    type Type = V128Const<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type V128ConstCombinatorAlias = bytes::Fixed<16>;


pub open spec fn spec_v128_const() -> SpecV128ConstCombinator {
    SpecV128ConstCombinator(bytes::Fixed::<16>)
}

                
pub fn v128_const<'a>() -> (o: V128ConstCombinator)
    ensures o@ == spec_v128_const(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = V128ConstCombinator(bytes::Fixed::<16>);
    assert({
        &&& combinator@ == spec_v128_const()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_v128_const<'a>(input: &'a [u8]) -> (res: PResult<<V128ConstCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_v128_const().spec_parse(input@) == Some((n as int, v@)),
        spec_v128_const().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_v128_const().spec_parse(input@) is None,
        spec_v128_const().spec_parse(input@) is None ==> res is Err,
{
    let combinator = v128_const();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_v128_const<'a>(v: <V128ConstCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_v128_const().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_v128_const().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_v128_const().spec_serialize(v@))
        },
{
    let combinator = v128_const();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn v128_const_len<'a>(v: <V128ConstCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_v128_const().wf(v@),
        spec_v128_const().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_v128_const().spec_serialize(v@).len(),
{
    let combinator = v128_const();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecShuffle = Seq<SpecLaneidx>;
pub type Shuffle = RepeatResult<Laneidx>;
pub type ShuffleRef<'a> = &'a RepeatResult<Laneidx>;


pub struct SpecShuffleCombinator(pub SpecShuffleCombinatorAlias);

impl SpecCombinator for SpecShuffleCombinator {
    type Type = SpecShuffle;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecShuffleCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecShuffleCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecShuffleCombinatorAlias = RepeatN<SpecLaneidxCombinator>;

pub struct ShuffleCombinator(pub ShuffleCombinatorAlias);

impl View for ShuffleCombinator {
    type V = SpecShuffleCombinator;
    open spec fn view(&self) -> Self::V { SpecShuffleCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ShuffleCombinator {
    type Type = Shuffle;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ShuffleCombinatorAlias = RepeatN<LaneidxCombinator>;


pub open spec fn spec_shuffle() -> SpecShuffleCombinator {
    SpecShuffleCombinator(RepeatN(spec_laneidx(), 16))
}

                
pub fn shuffle<'a>() -> (o: ShuffleCombinator)
    ensures o@ == spec_shuffle(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ShuffleCombinator(RepeatN(laneidx(), 16));
    assert({
        &&& combinator@ == spec_shuffle()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_shuffle<'a>(input: &'a [u8]) -> (res: PResult<<ShuffleCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_shuffle().spec_parse(input@) == Some((n as int, v@)),
        spec_shuffle().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_shuffle().spec_parse(input@) is None,
        spec_shuffle().spec_parse(input@) is None ==> res is Err,
{
    let combinator = shuffle();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_shuffle<'a>(v: <ShuffleCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_shuffle().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_shuffle().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_shuffle().spec_serialize(v@))
        },
{
    let combinator = shuffle();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn shuffle_len<'a>(v: <ShuffleCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_shuffle().wf(v@),
        spec_shuffle().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_shuffle().spec_serialize(v@).len(),
{
    let combinator = shuffle();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub enum SpecInstrWithFdRest {
    Variant0(SpecMemarg),
    Variant1(SpecMemarg),
    Variant2(SpecMemarg),
    Variant3(SpecV128Lane),
    Variant4(SpecV128Const),
    Variant5(SpecShuffle),
    Variant6(SpecLaneidx),
    Variant7(SpecEmpty),
}

pub type SpecInstrWithFdRestInner = Either<SpecMemarg, Either<SpecMemarg, Either<SpecMemarg, Either<SpecV128Lane, Either<SpecV128Const, Either<SpecShuffle, Either<SpecLaneidx, SpecEmpty>>>>>>>;

impl SpecFrom<SpecInstrWithFdRest> for SpecInstrWithFdRestInner {
    open spec fn spec_from(m: SpecInstrWithFdRest) -> SpecInstrWithFdRestInner {
        match m {
            SpecInstrWithFdRest::Variant0(m) => Either::Left(m),
            SpecInstrWithFdRest::Variant1(m) => Either::Right(Either::Left(m)),
            SpecInstrWithFdRest::Variant2(m) => Either::Right(Either::Right(Either::Left(m))),
            SpecInstrWithFdRest::Variant3(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            SpecInstrWithFdRest::Variant4(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            SpecInstrWithFdRest::Variant5(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))),
            SpecInstrWithFdRest::Variant6(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))),
            SpecInstrWithFdRest::Variant7(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m))))))),
        }
    }

}

                
impl SpecFrom<SpecInstrWithFdRestInner> for SpecInstrWithFdRest {
    open spec fn spec_from(m: SpecInstrWithFdRestInner) -> SpecInstrWithFdRest {
        match m {
            Either::Left(m) => SpecInstrWithFdRest::Variant0(m),
            Either::Right(Either::Left(m)) => SpecInstrWithFdRest::Variant1(m),
            Either::Right(Either::Right(Either::Left(m))) => SpecInstrWithFdRest::Variant2(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => SpecInstrWithFdRest::Variant3(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => SpecInstrWithFdRest::Variant4(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))) => SpecInstrWithFdRest::Variant5(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))) => SpecInstrWithFdRest::Variant6(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m))))))) => SpecInstrWithFdRest::Variant7(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InstrWithFdRest<'a> {
    Variant0(Memarg),
    Variant1(Memarg),
    Variant2(Memarg),
    Variant3(V128Lane),
    Variant4(V128Const<'a>),
    Variant5(Shuffle),
    Variant6(Laneidx),
    Variant7(Empty<'a>),
}

pub type InstrWithFdRestInner<'a> = Either<Memarg, Either<Memarg, Either<Memarg, Either<V128Lane, Either<V128Const<'a>, Either<Shuffle, Either<Laneidx, Empty<'a>>>>>>>>;

pub type InstrWithFdRestInnerRef<'a> = Either<&'a Memarg, Either<&'a Memarg, Either<&'a Memarg, Either<&'a V128Lane, Either<&'a V128Const<'a>, Either<&'a Shuffle, Either<&'a Laneidx, &'a Empty<'a>>>>>>>>;


impl<'a> View for InstrWithFdRest<'a> {
    type V = SpecInstrWithFdRest;
    open spec fn view(&self) -> Self::V {
        match self {
            InstrWithFdRest::Variant0(m) => SpecInstrWithFdRest::Variant0(m@),
            InstrWithFdRest::Variant1(m) => SpecInstrWithFdRest::Variant1(m@),
            InstrWithFdRest::Variant2(m) => SpecInstrWithFdRest::Variant2(m@),
            InstrWithFdRest::Variant3(m) => SpecInstrWithFdRest::Variant3(m@),
            InstrWithFdRest::Variant4(m) => SpecInstrWithFdRest::Variant4(m@),
            InstrWithFdRest::Variant5(m) => SpecInstrWithFdRest::Variant5(m@),
            InstrWithFdRest::Variant6(m) => SpecInstrWithFdRest::Variant6(m@),
            InstrWithFdRest::Variant7(m) => SpecInstrWithFdRest::Variant7(m@),
        }
    }
}


impl<'a> From<&'a InstrWithFdRest<'a>> for InstrWithFdRestInnerRef<'a> {
    fn ex_from(m: &'a InstrWithFdRest<'a>) -> InstrWithFdRestInnerRef<'a> {
        match m {
            InstrWithFdRest::Variant0(m) => Either::Left(m),
            InstrWithFdRest::Variant1(m) => Either::Right(Either::Left(m)),
            InstrWithFdRest::Variant2(m) => Either::Right(Either::Right(Either::Left(m))),
            InstrWithFdRest::Variant3(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            InstrWithFdRest::Variant4(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            InstrWithFdRest::Variant5(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))),
            InstrWithFdRest::Variant6(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))),
            InstrWithFdRest::Variant7(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m))))))),
        }
    }

}

impl<'a> From<InstrWithFdRestInner<'a>> for InstrWithFdRest<'a> {
    fn ex_from(m: InstrWithFdRestInner<'a>) -> InstrWithFdRest<'a> {
        match m {
            Either::Left(m) => InstrWithFdRest::Variant0(m),
            Either::Right(Either::Left(m)) => InstrWithFdRest::Variant1(m),
            Either::Right(Either::Right(Either::Left(m))) => InstrWithFdRest::Variant2(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => InstrWithFdRest::Variant3(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => InstrWithFdRest::Variant4(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))) => InstrWithFdRest::Variant5(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))) => InstrWithFdRest::Variant6(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m))))))) => InstrWithFdRest::Variant7(m),
        }
    }
    
}


pub struct InstrWithFdRestMapper;
impl View for InstrWithFdRestMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrWithFdRestMapper {
    type Src = SpecInstrWithFdRestInner;
    type Dst = SpecInstrWithFdRest;
}
impl SpecIsoProof for InstrWithFdRestMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrWithFdRestMapper {
    type Src = InstrWithFdRestInner<'a>;
    type Dst = InstrWithFdRest<'a>;
    type RefSrc = InstrWithFdRestInnerRef<'a>;
}

type SpecInstrWithFdRestCombinatorAlias1 = Choice<Cond<SpecLaneidxCombinator>, Cond<SpecEmptyCombinator>>;
type SpecInstrWithFdRestCombinatorAlias2 = Choice<Cond<SpecShuffleCombinator>, SpecInstrWithFdRestCombinatorAlias1>;
type SpecInstrWithFdRestCombinatorAlias3 = Choice<Cond<SpecV128ConstCombinator>, SpecInstrWithFdRestCombinatorAlias2>;
type SpecInstrWithFdRestCombinatorAlias4 = Choice<Cond<SpecV128LaneCombinator>, SpecInstrWithFdRestCombinatorAlias3>;
type SpecInstrWithFdRestCombinatorAlias5 = Choice<Cond<SpecMemargCombinator>, SpecInstrWithFdRestCombinatorAlias4>;
type SpecInstrWithFdRestCombinatorAlias6 = Choice<Cond<SpecMemargCombinator>, SpecInstrWithFdRestCombinatorAlias5>;
type SpecInstrWithFdRestCombinatorAlias7 = Choice<Cond<SpecMemargCombinator>, SpecInstrWithFdRestCombinatorAlias6>;
pub struct SpecInstrWithFdRestCombinator(pub SpecInstrWithFdRestCombinatorAlias);

impl SpecCombinator for SpecInstrWithFdRestCombinator {
    type Type = SpecInstrWithFdRest;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrWithFdRestCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrWithFdRestCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrWithFdRestCombinatorAlias = Mapped<SpecInstrWithFdRestCombinatorAlias7, InstrWithFdRestMapper>;
type InstrWithFdRestCombinatorAlias1 = Choice<Cond<LaneidxCombinator>, Cond<EmptyCombinator>>;
type InstrWithFdRestCombinatorAlias2 = Choice<Cond<ShuffleCombinator>, InstrWithFdRestCombinator1>;
type InstrWithFdRestCombinatorAlias3 = Choice<Cond<V128ConstCombinator>, InstrWithFdRestCombinator2>;
type InstrWithFdRestCombinatorAlias4 = Choice<Cond<V128LaneCombinator>, InstrWithFdRestCombinator3>;
type InstrWithFdRestCombinatorAlias5 = Choice<Cond<MemargCombinator>, InstrWithFdRestCombinator4>;
type InstrWithFdRestCombinatorAlias6 = Choice<Cond<MemargCombinator>, InstrWithFdRestCombinator5>;
type InstrWithFdRestCombinatorAlias7 = Choice<Cond<MemargCombinator>, InstrWithFdRestCombinator6>;
pub struct InstrWithFdRestCombinator1(pub InstrWithFdRestCombinatorAlias1);
impl View for InstrWithFdRestCombinator1 {
    type V = SpecInstrWithFdRestCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFdRestCombinator1, InstrWithFdRestCombinatorAlias1);

pub struct InstrWithFdRestCombinator2(pub InstrWithFdRestCombinatorAlias2);
impl View for InstrWithFdRestCombinator2 {
    type V = SpecInstrWithFdRestCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFdRestCombinator2, InstrWithFdRestCombinatorAlias2);

pub struct InstrWithFdRestCombinator3(pub InstrWithFdRestCombinatorAlias3);
impl View for InstrWithFdRestCombinator3 {
    type V = SpecInstrWithFdRestCombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFdRestCombinator3, InstrWithFdRestCombinatorAlias3);

pub struct InstrWithFdRestCombinator4(pub InstrWithFdRestCombinatorAlias4);
impl View for InstrWithFdRestCombinator4 {
    type V = SpecInstrWithFdRestCombinatorAlias4;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFdRestCombinator4, InstrWithFdRestCombinatorAlias4);

pub struct InstrWithFdRestCombinator5(pub InstrWithFdRestCombinatorAlias5);
impl View for InstrWithFdRestCombinator5 {
    type V = SpecInstrWithFdRestCombinatorAlias5;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFdRestCombinator5, InstrWithFdRestCombinatorAlias5);

pub struct InstrWithFdRestCombinator6(pub InstrWithFdRestCombinatorAlias6);
impl View for InstrWithFdRestCombinator6 {
    type V = SpecInstrWithFdRestCombinatorAlias6;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFdRestCombinator6, InstrWithFdRestCombinatorAlias6);

pub struct InstrWithFdRestCombinator7(pub InstrWithFdRestCombinatorAlias7);
impl View for InstrWithFdRestCombinator7 {
    type V = SpecInstrWithFdRestCombinatorAlias7;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrWithFdRestCombinator7, InstrWithFdRestCombinatorAlias7);

pub struct InstrWithFdRestCombinator(pub InstrWithFdRestCombinatorAlias);

impl View for InstrWithFdRestCombinator {
    type V = SpecInstrWithFdRestCombinator;
    open spec fn view(&self) -> Self::V { SpecInstrWithFdRestCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrWithFdRestCombinator {
    type Type = InstrWithFdRest<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrWithFdRestCombinatorAlias = Mapped<InstrWithFdRestCombinator7, InstrWithFdRestMapper>;


pub open spec fn spec_instr_with_fd_rest(tag: u64) -> SpecInstrWithFdRestCombinator {
    SpecInstrWithFdRestCombinator(Mapped { inner: Choice(Cond { cond: tag >= 0 && tag <= 11, inner: spec_memarg() }, Choice(Cond { cond: tag == 92, inner: spec_memarg() }, Choice(Cond { cond: tag == 93, inner: spec_memarg() }, Choice(Cond { cond: tag >= 84 && tag <= 91, inner: spec_v128_lane() }, Choice(Cond { cond: tag == 12, inner: spec_v128_const() }, Choice(Cond { cond: tag == 13, inner: spec_shuffle() }, Choice(Cond { cond: tag >= 21 && tag <= 34, inner: spec_laneidx() }, Cond { cond: !(tag >= 0 && tag <= 11 || tag == 92 || tag == 93 || tag >= 84 && tag <= 91 || tag == 12 || tag == 13 || tag >= 21 && tag <= 34), inner: spec_empty() }))))))), mapper: InstrWithFdRestMapper })
}

pub fn instr_with_fd_rest<'a>(tag: u64) -> (o: InstrWithFdRestCombinator)
    ensures o@ == spec_instr_with_fd_rest(tag@),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrWithFdRestCombinator(Mapped { inner: InstrWithFdRestCombinator7(Choice::new(Cond { cond: tag >= 0 && tag <= 11, inner: memarg() }, InstrWithFdRestCombinator6(Choice::new(Cond { cond: tag == 92, inner: memarg() }, InstrWithFdRestCombinator5(Choice::new(Cond { cond: tag == 93, inner: memarg() }, InstrWithFdRestCombinator4(Choice::new(Cond { cond: tag >= 84 && tag <= 91, inner: v128_lane() }, InstrWithFdRestCombinator3(Choice::new(Cond { cond: tag == 12, inner: v128_const() }, InstrWithFdRestCombinator2(Choice::new(Cond { cond: tag == 13, inner: shuffle() }, InstrWithFdRestCombinator1(Choice::new(Cond { cond: tag >= 21 && tag <= 34, inner: laneidx() }, Cond { cond: !(tag >= 0 && tag <= 11 || tag == 92 || tag == 93 || tag >= 84 && tag <= 91 || tag == 12 || tag == 13 || tag >= 21 && tag <= 34), inner: empty() })))))))))))))), mapper: InstrWithFdRestMapper });
    assert({
        &&& combinator@ == spec_instr_with_fd_rest(tag@)
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_with_fd_rest<'a>(input: &'a [u8], tag: u64) -> (res: PResult<<InstrWithFdRestCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_with_fd_rest(tag@).spec_parse(input@) == Some((n as int, v@)),
        spec_instr_with_fd_rest(tag@).spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_with_fd_rest(tag@).spec_parse(input@) is None,
        spec_instr_with_fd_rest(tag@).spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_with_fd_rest( tag );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_with_fd_rest<'a>(v: <InstrWithFdRestCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize, tag: u64) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_with_fd_rest(tag@).wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_with_fd_rest(tag@).spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_with_fd_rest(tag@).spec_serialize(v@))
        },
{
    let combinator = instr_with_fd_rest( tag );
    combinator.serialize(v, data, pos)
}

pub fn instr_with_fd_rest_len<'a>(v: <InstrWithFdRestCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, tag: u64) -> (serialize_len: usize)
    requires
        spec_instr_with_fd_rest(tag@).wf(v@),
        spec_instr_with_fd_rest(tag@).spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_with_fd_rest(tag@).spec_serialize(v@).len(),
{
    let combinator = instr_with_fd_rest( tag );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}


pub struct SpecInstrWithFd {
    pub tag: u64,
    pub rest: SpecInstrWithFdRest,
}

pub type SpecInstrWithFdInner = (u64, SpecInstrWithFdRest);


impl SpecFrom<SpecInstrWithFd> for SpecInstrWithFdInner {
    open spec fn spec_from(m: SpecInstrWithFd) -> SpecInstrWithFdInner {
        (m.tag, m.rest)
    }
}

impl SpecFrom<SpecInstrWithFdInner> for SpecInstrWithFd {
    open spec fn spec_from(m: SpecInstrWithFdInner) -> SpecInstrWithFd {
        let (tag, rest) = m;
        SpecInstrWithFd { tag, rest }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct InstrWithFd<'a> {
    pub tag: u64,
    pub rest: InstrWithFdRest<'a>,
}

impl View for InstrWithFd<'_> {
    type V = SpecInstrWithFd;

    open spec fn view(&self) -> Self::V {
        SpecInstrWithFd {
            tag: self.tag@,
            rest: self.rest@,
        }
    }
}
pub type InstrWithFdInner<'a> = (u64, InstrWithFdRest<'a>);

pub type InstrWithFdInnerRef<'a> = (&'a u64, &'a InstrWithFdRest<'a>);
impl<'a> From<&'a InstrWithFd<'a>> for InstrWithFdInnerRef<'a> {
    fn ex_from(m: &'a InstrWithFd) -> InstrWithFdInnerRef<'a> {
        (&m.tag, &m.rest)
    }
}

impl<'a> From<InstrWithFdInner<'a>> for InstrWithFd<'a> {
    fn ex_from(m: InstrWithFdInner) -> InstrWithFd {
        let (tag, rest) = m;
        InstrWithFd { tag, rest }
    }
}

pub struct InstrWithFdMapper;
impl View for InstrWithFdMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrWithFdMapper {
    type Src = SpecInstrWithFdInner;
    type Dst = SpecInstrWithFd;
}
impl SpecIsoProof for InstrWithFdMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrWithFdMapper {
    type Src = InstrWithFdInner<'a>;
    type Dst = InstrWithFd<'a>;
    type RefSrc = InstrWithFdInnerRef<'a>;
}

pub struct SpecInstrWithFdCombinator(pub SpecInstrWithFdCombinatorAlias);

impl SpecCombinator for SpecInstrWithFdCombinator {
    type Type = SpecInstrWithFd;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrWithFdCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrWithFdCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrWithFdCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, SpecInstrWithFdRestCombinator>, InstrWithFdMapper>;

pub struct InstrWithFdCombinator(pub InstrWithFdCombinatorAlias);

impl View for InstrWithFdCombinator {
    type V = SpecInstrWithFdCombinator;
    open spec fn view(&self) -> Self::V { SpecInstrWithFdCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrWithFdCombinator {
    type Type = InstrWithFd<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrWithFdCombinatorAlias = Mapped<Pair<UnsignedLEB128, InstrWithFdRestCombinator, InstrWithFdCont0>, InstrWithFdMapper>;


pub open spec fn spec_instr_with_fd() -> SpecInstrWithFdCombinator {
    SpecInstrWithFdCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_instr_with_fd_cont0(deps)),
        mapper: InstrWithFdMapper,
    })
}

pub open spec fn spec_instr_with_fd_cont0(deps: u64) -> SpecInstrWithFdRestCombinator {
    let tag = deps;
    spec_instr_with_fd_rest(tag)
}

impl View for InstrWithFdCont0 {
    type V = spec_fn(u64) -> SpecInstrWithFdRestCombinator;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_instr_with_fd_cont0(deps)
        }
    }
}

                
pub fn instr_with_fd<'a>() -> (o: InstrWithFdCombinator)
    ensures o@ == spec_instr_with_fd(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrWithFdCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, InstrWithFdCont0),
        mapper: InstrWithFdMapper,
    });
    assert({
        &&& combinator@ == spec_instr_with_fd()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_with_fd<'a>(input: &'a [u8]) -> (res: PResult<<InstrWithFdCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_with_fd().spec_parse(input@) == Some((n as int, v@)),
        spec_instr_with_fd().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_with_fd().spec_parse(input@) is None,
        spec_instr_with_fd().spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_with_fd();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_with_fd<'a>(v: <InstrWithFdCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_with_fd().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_with_fd().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_with_fd().spec_serialize(v@))
        },
{
    let combinator = instr_with_fd();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn instr_with_fd_len<'a>(v: <InstrWithFdCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_instr_with_fd().wf(v@),
        spec_instr_with_fd().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_with_fd().spec_serialize(v@).len(),
{
    let combinator = instr_with_fd();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct InstrWithFdCont0;
type InstrWithFdCont0Type<'a, 'b> = &'b u64;
type InstrWithFdCont0SType<'a, 'x> = &'x u64;
type InstrWithFdCont0Input<'a, 'b, 'x> = POrSType<InstrWithFdCont0Type<'a, 'b>, InstrWithFdCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<InstrWithFdCont0Input<'a, 'b, 'x>> for InstrWithFdCont0 {
    type Output = InstrWithFdRestCombinator;

    open spec fn requires(&self, deps: InstrWithFdCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: InstrWithFdCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_instr_with_fd_cont0(deps@)
    }

    fn apply(&self, deps: InstrWithFdCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let tag = *deps;
                instr_with_fd_rest(tag)
            }
            POrSType::S(deps) => {
                let tag = deps;
                let tag = *tag;
                instr_with_fd_rest(tag)
            }
        }
    }
}
                

pub enum SpecInstrRest {
    Variant0(SpecInstrVariable),
    Variant1(SpecInstrControl2),
    Variant2(SpecInstrControl1),
    Variant3(SpecInstrMemory),
    Variant4(SpecInstrReference),
    Variant5(SpecInstrParametric),
    Variant6(SpecInstrTable),
    Variant7(SpecInstrNumeric),
    Variant8(SpecInstrWithFc),
    Variant9(SpecInstrWithFd),
    Variant10(SpecEmpty),
}

pub type SpecInstrRestInner = Either<SpecInstrVariable, Either<SpecInstrControl2, Either<SpecInstrControl1, Either<SpecInstrMemory, Either<SpecInstrReference, Either<SpecInstrParametric, Either<SpecInstrTable, Either<SpecInstrNumeric, Either<SpecInstrWithFc, Either<SpecInstrWithFd, SpecEmpty>>>>>>>>>>;

impl SpecFrom<SpecInstrRest> for SpecInstrRestInner {
    open spec fn spec_from(m: SpecInstrRest) -> SpecInstrRestInner {
        match m {
            SpecInstrRest::Variant0(m) => Either::Left(m),
            SpecInstrRest::Variant1(m) => Either::Right(Either::Left(m)),
            SpecInstrRest::Variant2(m) => Either::Right(Either::Right(Either::Left(m))),
            SpecInstrRest::Variant3(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            SpecInstrRest::Variant4(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            SpecInstrRest::Variant5(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))),
            SpecInstrRest::Variant6(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))),
            SpecInstrRest::Variant7(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))),
            SpecInstrRest::Variant8(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))))),
            SpecInstrRest::Variant9(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))))),
            SpecInstrRest::Variant10(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))))))),
        }
    }

}

                
impl SpecFrom<SpecInstrRestInner> for SpecInstrRest {
    open spec fn spec_from(m: SpecInstrRestInner) -> SpecInstrRest {
        match m {
            Either::Left(m) => SpecInstrRest::Variant0(m),
            Either::Right(Either::Left(m)) => SpecInstrRest::Variant1(m),
            Either::Right(Either::Right(Either::Left(m))) => SpecInstrRest::Variant2(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => SpecInstrRest::Variant3(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => SpecInstrRest::Variant4(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))) => SpecInstrRest::Variant5(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))) => SpecInstrRest::Variant6(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))) => SpecInstrRest::Variant7(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))))) => SpecInstrRest::Variant8(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))))) => SpecInstrRest::Variant9(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))))))) => SpecInstrRest::Variant10(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum InstrRest<'a> {
    Variant0(InstrVariable),
    Variant1(InstrControl2<'a>),
    Variant2(InstrControl1<'a>),
    Variant3(InstrMemory),
    Variant4(InstrReference<'a>),
    Variant5(InstrParametric<'a>),
    Variant6(InstrTable),
    Variant7(InstrNumeric<'a>),
    Variant8(InstrWithFc<'a>),
    Variant9(InstrWithFd<'a>),
    Variant10(Empty<'a>),
}

pub type InstrRestInner<'a> = Either<InstrVariable, Either<InstrControl2<'a>, Either<InstrControl1<'a>, Either<InstrMemory, Either<InstrReference<'a>, Either<InstrParametric<'a>, Either<InstrTable, Either<InstrNumeric<'a>, Either<InstrWithFc<'a>, Either<InstrWithFd<'a>, Empty<'a>>>>>>>>>>>;

pub type InstrRestInnerRef<'a> = Either<&'a InstrVariable, Either<&'a InstrControl2<'a>, Either<&'a InstrControl1<'a>, Either<&'a InstrMemory, Either<&'a InstrReference<'a>, Either<&'a InstrParametric<'a>, Either<&'a InstrTable, Either<&'a InstrNumeric<'a>, Either<&'a InstrWithFc<'a>, Either<&'a InstrWithFd<'a>, &'a Empty<'a>>>>>>>>>>>;


impl<'a> View for InstrRest<'a> {
    type V = SpecInstrRest;
    open spec fn view(&self) -> Self::V {
        match self {
            InstrRest::Variant0(m) => SpecInstrRest::Variant0(m@),
            InstrRest::Variant1(m) => SpecInstrRest::Variant1(m@),
            InstrRest::Variant2(m) => SpecInstrRest::Variant2(m@),
            InstrRest::Variant3(m) => SpecInstrRest::Variant3(m@),
            InstrRest::Variant4(m) => SpecInstrRest::Variant4(m@),
            InstrRest::Variant5(m) => SpecInstrRest::Variant5(m@),
            InstrRest::Variant6(m) => SpecInstrRest::Variant6(m@),
            InstrRest::Variant7(m) => SpecInstrRest::Variant7(m@),
            InstrRest::Variant8(m) => SpecInstrRest::Variant8(m@),
            InstrRest::Variant9(m) => SpecInstrRest::Variant9(m@),
            InstrRest::Variant10(m) => SpecInstrRest::Variant10(m@),
        }
    }
}


impl<'a> From<&'a InstrRest<'a>> for InstrRestInnerRef<'a> {
    fn ex_from(m: &'a InstrRest<'a>) -> InstrRestInnerRef<'a> {
        match m {
            InstrRest::Variant0(m) => Either::Left(m),
            InstrRest::Variant1(m) => Either::Right(Either::Left(m)),
            InstrRest::Variant2(m) => Either::Right(Either::Right(Either::Left(m))),
            InstrRest::Variant3(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            InstrRest::Variant4(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            InstrRest::Variant5(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))),
            InstrRest::Variant6(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))),
            InstrRest::Variant7(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))),
            InstrRest::Variant8(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))))),
            InstrRest::Variant9(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))))),
            InstrRest::Variant10(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))))))),
        }
    }

}

impl<'a> From<InstrRestInner<'a>> for InstrRest<'a> {
    fn ex_from(m: InstrRestInner<'a>) -> InstrRest<'a> {
        match m {
            Either::Left(m) => InstrRest::Variant0(m),
            Either::Right(Either::Left(m)) => InstrRest::Variant1(m),
            Either::Right(Either::Right(Either::Left(m))) => InstrRest::Variant2(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => InstrRest::Variant3(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => InstrRest::Variant4(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))) => InstrRest::Variant5(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))) => InstrRest::Variant6(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))) => InstrRest::Variant7(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))))) => InstrRest::Variant8(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))))))) => InstrRest::Variant9(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m)))))))))) => InstrRest::Variant10(m),
        }
    }
    
}


pub struct InstrRestMapper;
impl View for InstrRestMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrRestMapper {
    type Src = SpecInstrRestInner;
    type Dst = SpecInstrRest;
}
impl SpecIsoProof for InstrRestMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrRestMapper {
    type Src = InstrRestInner<'a>;
    type Dst = InstrRest<'a>;
    type RefSrc = InstrRestInnerRef<'a>;
}

type SpecInstrRestCombinatorAlias1 = Choice<Cond<SpecInstrWithFdCombinator>, Cond<SpecEmptyCombinator>>;
type SpecInstrRestCombinatorAlias2 = Choice<Cond<SpecInstrWithFcCombinator>, SpecInstrRestCombinatorAlias1>;
type SpecInstrRestCombinatorAlias3 = Choice<Cond<SpecInstrNumericCombinator>, SpecInstrRestCombinatorAlias2>;
type SpecInstrRestCombinatorAlias4 = Choice<Cond<SpecInstrTableCombinator>, SpecInstrRestCombinatorAlias3>;
type SpecInstrRestCombinatorAlias5 = Choice<Cond<SpecInstrParametricCombinator>, SpecInstrRestCombinatorAlias4>;
type SpecInstrRestCombinatorAlias6 = Choice<Cond<SpecInstrReferenceCombinator>, SpecInstrRestCombinatorAlias5>;
type SpecInstrRestCombinatorAlias7 = Choice<Cond<SpecInstrMemoryCombinator>, SpecInstrRestCombinatorAlias6>;
type SpecInstrRestCombinatorAlias8 = Choice<Cond<SpecInstrControl1Combinator>, SpecInstrRestCombinatorAlias7>;
type SpecInstrRestCombinatorAlias9 = Choice<Cond<SpecInstrControl2Combinator>, SpecInstrRestCombinatorAlias8>;
type SpecInstrRestCombinatorAlias10 = Choice<Cond<SpecInstrVariableCombinator>, SpecInstrRestCombinatorAlias9>;
pub struct SpecInstrRestCombinator(pub SpecInstrRestCombinatorAlias);

impl SpecCombinator for SpecInstrRestCombinator {
    type Type = SpecInstrRest;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrRestCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrRestCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrRestCombinatorAlias = Mapped<SpecInstrRestCombinatorAlias10, InstrRestMapper>;
type InstrRestCombinatorAlias1 = Choice<Cond<InstrWithFdCombinator>, Cond<EmptyCombinator>>;
type InstrRestCombinatorAlias2 = Choice<Cond<InstrWithFcCombinator>, InstrRestCombinator1>;
type InstrRestCombinatorAlias3 = Choice<Cond<InstrNumericCombinator>, InstrRestCombinator2>;
type InstrRestCombinatorAlias4 = Choice<Cond<InstrTableCombinator>, InstrRestCombinator3>;
type InstrRestCombinatorAlias5 = Choice<Cond<InstrParametricCombinator>, InstrRestCombinator4>;
type InstrRestCombinatorAlias6 = Choice<Cond<InstrReferenceCombinator>, InstrRestCombinator5>;
type InstrRestCombinatorAlias7 = Choice<Cond<InstrMemoryCombinator>, InstrRestCombinator6>;
type InstrRestCombinatorAlias8 = Choice<Cond<InstrControl1Combinator>, InstrRestCombinator7>;
type InstrRestCombinatorAlias9 = Choice<Cond<InstrControl2Combinator>, InstrRestCombinator8>;
type InstrRestCombinatorAlias10 = Choice<Cond<InstrVariableCombinator>, InstrRestCombinator9>;
pub struct InstrRestCombinator1(pub InstrRestCombinatorAlias1);
impl View for InstrRestCombinator1 {
    type V = SpecInstrRestCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrRestCombinator1, InstrRestCombinatorAlias1);

pub struct InstrRestCombinator2(pub InstrRestCombinatorAlias2);
impl View for InstrRestCombinator2 {
    type V = SpecInstrRestCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrRestCombinator2, InstrRestCombinatorAlias2);

pub struct InstrRestCombinator3(pub InstrRestCombinatorAlias3);
impl View for InstrRestCombinator3 {
    type V = SpecInstrRestCombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrRestCombinator3, InstrRestCombinatorAlias3);

pub struct InstrRestCombinator4(pub InstrRestCombinatorAlias4);
impl View for InstrRestCombinator4 {
    type V = SpecInstrRestCombinatorAlias4;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrRestCombinator4, InstrRestCombinatorAlias4);

pub struct InstrRestCombinator5(pub InstrRestCombinatorAlias5);
impl View for InstrRestCombinator5 {
    type V = SpecInstrRestCombinatorAlias5;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrRestCombinator5, InstrRestCombinatorAlias5);

pub struct InstrRestCombinator6(pub InstrRestCombinatorAlias6);
impl View for InstrRestCombinator6 {
    type V = SpecInstrRestCombinatorAlias6;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrRestCombinator6, InstrRestCombinatorAlias6);

pub struct InstrRestCombinator7(pub InstrRestCombinatorAlias7);
impl View for InstrRestCombinator7 {
    type V = SpecInstrRestCombinatorAlias7;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrRestCombinator7, InstrRestCombinatorAlias7);

pub struct InstrRestCombinator8(pub InstrRestCombinatorAlias8);
impl View for InstrRestCombinator8 {
    type V = SpecInstrRestCombinatorAlias8;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrRestCombinator8, InstrRestCombinatorAlias8);

pub struct InstrRestCombinator9(pub InstrRestCombinatorAlias9);
impl View for InstrRestCombinator9 {
    type V = SpecInstrRestCombinatorAlias9;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrRestCombinator9, InstrRestCombinatorAlias9);

pub struct InstrRestCombinator10(pub InstrRestCombinatorAlias10);
impl View for InstrRestCombinator10 {
    type V = SpecInstrRestCombinatorAlias10;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(InstrRestCombinator10, InstrRestCombinatorAlias10);

pub struct InstrRestCombinator(pub InstrRestCombinatorAlias);

impl View for InstrRestCombinator {
    type V = SpecInstrRestCombinator;
    open spec fn view(&self) -> Self::V { SpecInstrRestCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrRestCombinator {
    type Type = InstrRest<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrRestCombinatorAlias = Mapped<InstrRestCombinator10, InstrRestMapper>;


pub open spec fn spec_instr_rest(opcode: u8) -> SpecInstrRestCombinator {
    SpecInstrRestCombinator(Mapped { inner: Choice(Cond { cond: opcode >= 32 && opcode <= 36, inner: spec_instr_variable(opcode) }, Choice(Cond { cond: opcode >= 11 && opcode <= 17, inner: spec_instr_control2(opcode) }, Choice(Cond { cond: opcode >= 0 && opcode <= 5, inner: spec_instr_control1(opcode) }, Choice(Cond { cond: opcode >= 40 && opcode <= 64, inner: spec_instr_memory(opcode) }, Choice(Cond { cond: opcode >= 208 && opcode <= 210, inner: spec_instr_reference(opcode) }, Choice(Cond { cond: opcode >= 26 && opcode <= 28, inner: spec_instr_parametric(opcode) }, Choice(Cond { cond: opcode >= 37 && opcode <= 38, inner: spec_instr_table(opcode) }, Choice(Cond { cond: opcode >= 65 && opcode <= 68, inner: spec_instr_numeric(opcode) }, Choice(Cond { cond: opcode == 252, inner: spec_instr_with_fc() }, Choice(Cond { cond: opcode == 253, inner: spec_instr_with_fd() }, Cond { cond: !(opcode >= 32 && opcode <= 36 || opcode >= 11 && opcode <= 17 || opcode >= 0 && opcode <= 5 || opcode >= 40 && opcode <= 64 || opcode >= 208 && opcode <= 210 || opcode >= 26 && opcode <= 28 || opcode >= 37 && opcode <= 38 || opcode >= 65 && opcode <= 68 || opcode == 252 || opcode == 253), inner: spec_empty() })))))))))), mapper: InstrRestMapper })
}

pub fn instr_rest<'a>(opcode: u8) -> (o: InstrRestCombinator)
    ensures o@ == spec_instr_rest(opcode@),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrRestCombinator(Mapped { inner: InstrRestCombinator10(Choice::new(Cond { cond: opcode >= 32 && opcode <= 36, inner: instr_variable(opcode) }, InstrRestCombinator9(Choice::new(Cond { cond: opcode >= 11 && opcode <= 17, inner: instr_control2(opcode) }, InstrRestCombinator8(Choice::new(Cond { cond: opcode >= 0 && opcode <= 5, inner: instr_control1(opcode) }, InstrRestCombinator7(Choice::new(Cond { cond: opcode >= 40 && opcode <= 64, inner: instr_memory(opcode) }, InstrRestCombinator6(Choice::new(Cond { cond: opcode >= 208 && opcode <= 210, inner: instr_reference(opcode) }, InstrRestCombinator5(Choice::new(Cond { cond: opcode >= 26 && opcode <= 28, inner: instr_parametric(opcode) }, InstrRestCombinator4(Choice::new(Cond { cond: opcode >= 37 && opcode <= 38, inner: instr_table(opcode) }, InstrRestCombinator3(Choice::new(Cond { cond: opcode >= 65 && opcode <= 68, inner: instr_numeric(opcode) }, InstrRestCombinator2(Choice::new(Cond { cond: opcode == 252, inner: instr_with_fc() }, InstrRestCombinator1(Choice::new(Cond { cond: opcode == 253, inner: instr_with_fd() }, Cond { cond: !(opcode >= 32 && opcode <= 36 || opcode >= 11 && opcode <= 17 || opcode >= 0 && opcode <= 5 || opcode >= 40 && opcode <= 64 || opcode >= 208 && opcode <= 210 || opcode >= 26 && opcode <= 28 || opcode >= 37 && opcode <= 38 || opcode >= 65 && opcode <= 68 || opcode == 252 || opcode == 253), inner: empty() })))))))))))))))))))), mapper: InstrRestMapper });
    assert({
        &&& combinator@ == spec_instr_rest(opcode@)
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr_rest<'a>(input: &'a [u8], opcode: u8) -> (res: PResult<<InstrRestCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr_rest(opcode@).spec_parse(input@) == Some((n as int, v@)),
        spec_instr_rest(opcode@).spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr_rest(opcode@).spec_parse(input@) is None,
        spec_instr_rest(opcode@).spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr_rest( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr_rest<'a>(v: <InstrRestCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize, opcode: u8) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr_rest(opcode@).wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr_rest(opcode@).spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr_rest(opcode@).spec_serialize(v@))
        },
{
    let combinator = instr_rest( opcode );
    combinator.serialize(v, data, pos)
}

pub fn instr_rest_len<'a>(v: <InstrRestCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, opcode: u8) -> (serialize_len: usize)
    requires
        spec_instr_rest(opcode@).wf(v@),
        spec_instr_rest(opcode@).spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr_rest(opcode@).spec_serialize(v@).len(),
{
    let combinator = instr_rest( opcode );
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}


pub struct SpecInstr {
    pub opcode: u8,
    pub rest: SpecInstrRest,
}

pub type SpecInstrInner = (u8, SpecInstrRest);


impl SpecFrom<SpecInstr> for SpecInstrInner {
    open spec fn spec_from(m: SpecInstr) -> SpecInstrInner {
        (m.opcode, m.rest)
    }
}

impl SpecFrom<SpecInstrInner> for SpecInstr {
    open spec fn spec_from(m: SpecInstrInner) -> SpecInstr {
        let (opcode, rest) = m;
        SpecInstr { opcode, rest }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Instr<'a> {
    pub opcode: u8,
    pub rest: InstrRest<'a>,
}

impl View for Instr<'_> {
    type V = SpecInstr;

    open spec fn view(&self) -> Self::V {
        SpecInstr {
            opcode: self.opcode@,
            rest: self.rest@,
        }
    }
}
pub type InstrInner<'a> = (u8, InstrRest<'a>);

pub type InstrInnerRef<'a> = (&'a u8, &'a InstrRest<'a>);
impl<'a> From<&'a Instr<'a>> for InstrInnerRef<'a> {
    fn ex_from(m: &'a Instr) -> InstrInnerRef<'a> {
        (&m.opcode, &m.rest)
    }
}

impl<'a> From<InstrInner<'a>> for Instr<'a> {
    fn ex_from(m: InstrInner) -> Instr {
        let (opcode, rest) = m;
        Instr { opcode, rest }
    }
}

pub struct InstrMapper;
impl View for InstrMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for InstrMapper {
    type Src = SpecInstrInner;
    type Dst = SpecInstr;
}
impl SpecIsoProof for InstrMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for InstrMapper {
    type Src = InstrInner<'a>;
    type Dst = Instr<'a>;
    type RefSrc = InstrInnerRef<'a>;
}

pub struct SpecInstrCombinator(pub SpecInstrCombinatorAlias);

impl SpecCombinator for SpecInstrCombinator {
    type Type = SpecInstr;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecInstrCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecInstrCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecInstrCombinatorAlias = Mapped<SpecPair<SpecInstrBytecodeCombinator, SpecInstrRestCombinator>, InstrMapper>;

pub struct InstrCombinator(pub InstrCombinatorAlias);

impl View for InstrCombinator {
    type V = SpecInstrCombinator;
    open spec fn view(&self) -> Self::V { SpecInstrCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for InstrCombinator {
    type Type = Instr<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type InstrCombinatorAlias = Mapped<Pair<InstrBytecodeCombinator, InstrRestCombinator, InstrCont0>, InstrMapper>;


pub open spec fn spec_instr() -> SpecInstrCombinator {
    SpecInstrCombinator(
    Mapped {
        inner: Pair::spec_new(spec_instr_bytecode(), |deps| spec_instr_cont0(deps)),
        mapper: InstrMapper,
    })
}

pub open spec fn spec_instr_cont0(deps: u8) -> SpecInstrRestCombinator {
    let opcode = deps;
    spec_instr_rest(opcode)
}

impl View for InstrCont0 {
    type V = spec_fn(u8) -> SpecInstrRestCombinator;

    open spec fn view(&self) -> Self::V {
        |deps: u8| {
            spec_instr_cont0(deps)
        }
    }
}

                
pub fn instr<'a>() -> (o: InstrCombinator)
    ensures o@ == spec_instr(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = InstrCombinator(
    Mapped {
        inner: Pair::new(instr_bytecode(), InstrCont0),
        mapper: InstrMapper,
    });
    assert({
        &&& combinator@ == spec_instr()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_instr<'a>(input: &'a [u8]) -> (res: PResult<<InstrCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_instr().spec_parse(input@) == Some((n as int, v@)),
        spec_instr().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_instr().spec_parse(input@) is None,
        spec_instr().spec_parse(input@) is None ==> res is Err,
{
    let combinator = instr();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_instr<'a>(v: <InstrCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_instr().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_instr().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_instr().spec_serialize(v@))
        },
{
    let combinator = instr();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn instr_len<'a>(v: <InstrCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_instr().wf(v@),
        spec_instr().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_instr().spec_serialize(v@).len(),
{
    let combinator = instr();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct InstrCont0;
type InstrCont0Type<'a, 'b> = &'b u8;
type InstrCont0SType<'a, 'x> = &'x u8;
type InstrCont0Input<'a, 'b, 'x> = POrSType<InstrCont0Type<'a, 'b>, InstrCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<InstrCont0Input<'a, 'b, 'x>> for InstrCont0 {
    type Output = InstrRestCombinator;

    open spec fn requires(&self, deps: InstrCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: InstrCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_instr_cont0(deps@)
    }

    fn apply(&self, deps: InstrCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let opcode = *deps;
                instr_rest(opcode)
            }
            POrSType::S(deps) => {
                let opcode = deps;
                let opcode = *opcode;
                instr_rest(opcode)
            }
        }
    }
}
                

pub struct SpecExprInner {
    pub l: u64,
    pub v: Seq<SpecInstr>,
}

pub type SpecExprInnerInner = (u64, Seq<SpecInstr>);


impl SpecFrom<SpecExprInner> for SpecExprInnerInner {
    open spec fn spec_from(m: SpecExprInner) -> SpecExprInnerInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecExprInnerInner> for SpecExprInner {
    open spec fn spec_from(m: SpecExprInnerInner) -> SpecExprInner {
        let (l, v) = m;
        SpecExprInner { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ExprInner<'a> {
    pub l: u64,
    pub v: RepeatResult<Instr<'a>>,
}

impl View for ExprInner<'_> {
    type V = SpecExprInner;

    open spec fn view(&self) -> Self::V {
        SpecExprInner {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type ExprInnerInner<'a> = (u64, RepeatResult<Instr<'a>>);

pub type ExprInnerInnerRef<'a> = (&'a u64, &'a RepeatResult<Instr<'a>>);
impl<'a> From<&'a ExprInner<'a>> for ExprInnerInnerRef<'a> {
    fn ex_from(m: &'a ExprInner) -> ExprInnerInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl<'a> From<ExprInnerInner<'a>> for ExprInner<'a> {
    fn ex_from(m: ExprInnerInner) -> ExprInner {
        let (l, v) = m;
        ExprInner { l, v }
    }
}

pub struct ExprInnerMapper;
impl View for ExprInnerMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ExprInnerMapper {
    type Src = SpecExprInnerInner;
    type Dst = SpecExprInner;
}
impl SpecIsoProof for ExprInnerMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ExprInnerMapper {
    type Src = ExprInnerInner<'a>;
    type Dst = ExprInner<'a>;
    type RefSrc = ExprInnerInnerRef<'a>;
}

pub struct SpecExprInnerCombinator(pub SpecExprInnerCombinatorAlias);

impl SpecCombinator for SpecExprInnerCombinator {
    type Type = SpecExprInner;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecExprInnerCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecExprInnerCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecExprInnerCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecInstrCombinator>>, ExprInnerMapper>;

pub struct ExprInnerCombinator(pub ExprInnerCombinatorAlias);

impl View for ExprInnerCombinator {
    type V = SpecExprInnerCombinator;
    open spec fn view(&self) -> Self::V { SpecExprInnerCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ExprInnerCombinator {
    type Type = ExprInner<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ExprInnerCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<InstrCombinator>, ExprInnerCont0>, ExprInnerMapper>;


pub open spec fn spec_expr_inner() -> SpecExprInnerCombinator {
    SpecExprInnerCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_expr_inner_cont0(deps)),
        mapper: ExprInnerMapper,
    })
}

pub open spec fn spec_expr_inner_cont0(deps: u64) -> RepeatN<SpecInstrCombinator> {
    let l = deps;
    RepeatN(spec_instr(), l.spec_into())
}

impl View for ExprInnerCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecInstrCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_expr_inner_cont0(deps)
        }
    }
}

                
pub fn expr_inner<'a>() -> (o: ExprInnerCombinator)
    ensures o@ == spec_expr_inner(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ExprInnerCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, ExprInnerCont0),
        mapper: ExprInnerMapper,
    });
    assert({
        &&& combinator@ == spec_expr_inner()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_expr_inner<'a>(input: &'a [u8]) -> (res: PResult<<ExprInnerCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_expr_inner().spec_parse(input@) == Some((n as int, v@)),
        spec_expr_inner().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_expr_inner().spec_parse(input@) is None,
        spec_expr_inner().spec_parse(input@) is None ==> res is Err,
{
    let combinator = expr_inner();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_expr_inner<'a>(v: <ExprInnerCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_expr_inner().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_expr_inner().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_expr_inner().spec_serialize(v@))
        },
{
    let combinator = expr_inner();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn expr_inner_len<'a>(v: <ExprInnerCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_expr_inner().wf(v@),
        spec_expr_inner().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_expr_inner().spec_serialize(v@).len(),
{
    let combinator = expr_inner();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct ExprInnerCont0;
type ExprInnerCont0Type<'a, 'b> = &'b u64;
type ExprInnerCont0SType<'a, 'x> = &'x u64;
type ExprInnerCont0Input<'a, 'b, 'x> = POrSType<ExprInnerCont0Type<'a, 'b>, ExprInnerCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<ExprInnerCont0Input<'a, 'b, 'x>> for ExprInnerCont0 {
    type Output = RepeatN<InstrCombinator>;

    open spec fn requires(&self, deps: ExprInnerCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: ExprInnerCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_expr_inner_cont0(deps@)
    }

    fn apply(&self, deps: ExprInnerCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(instr(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(instr(), l.ex_into())
            }
        }
    }
}
                
pub type SpecExpr = SpecExprInner;
pub type Expr<'a> = ExprInner<'a>;
pub type ExprRef<'a> = &'a ExprInner<'a>;


pub const Expr_0_BACK_CONST: u8 = 11;

pub struct SpecExprCombinator(pub SpecExprCombinatorAlias);

impl SpecCombinator for SpecExprCombinator {
    type Type = SpecExpr;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecExprCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecExprCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecExprCombinatorAlias = Terminated<SpecExprInnerCombinator, Tag<U8, u8>>;


pub struct ExprCombinator(pub ExprCombinatorAlias);

impl View for ExprCombinator {
    type V = SpecExprCombinator;
    open spec fn view(&self) -> Self::V { SpecExprCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ExprCombinator {
    type Type = Expr<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ExprCombinatorAlias = Terminated<ExprInnerCombinator, Tag<U8, u8>>;


pub open spec fn spec_expr() -> SpecExprCombinator {
    SpecExprCombinator(Terminated(spec_expr_inner(), Tag::spec_new(U8, Expr_0_BACK_CONST)))
}

                
pub fn expr<'a>() -> (o: ExprCombinator)
    ensures o@ == spec_expr(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ExprCombinator(Terminated(expr_inner(), Tag::new(U8, Expr_0_BACK_CONST)));
    assert({
        &&& combinator@ == spec_expr()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_expr<'a>(input: &'a [u8]) -> (res: PResult<<ExprCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_expr().spec_parse(input@) == Some((n as int, v@)),
        spec_expr().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_expr().spec_parse(input@) is None,
        spec_expr().spec_parse(input@) is None ==> res is Err,
{
    let combinator = expr();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_expr<'a>(v: <ExprCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_expr().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_expr().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_expr().spec_serialize(v@))
        },
{
    let combinator = expr();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn expr_len<'a>(v: <ExprCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_expr().wf(v@),
        spec_expr().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_expr().spec_serialize(v@).len(),
{
    let combinator = expr();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecGlobal {
    pub gt: SpecGlobaltype,
    pub init: SpecExpr,
}

pub type SpecGlobalInner = (SpecGlobaltype, SpecExpr);


impl SpecFrom<SpecGlobal> for SpecGlobalInner {
    open spec fn spec_from(m: SpecGlobal) -> SpecGlobalInner {
        (m.gt, m.init)
    }
}

impl SpecFrom<SpecGlobalInner> for SpecGlobal {
    open spec fn spec_from(m: SpecGlobalInner) -> SpecGlobal {
        let (gt, init) = m;
        SpecGlobal { gt, init }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Global<'a> {
    pub gt: Globaltype,
    pub init: Expr<'a>,
}

impl View for Global<'_> {
    type V = SpecGlobal;

    open spec fn view(&self) -> Self::V {
        SpecGlobal {
            gt: self.gt@,
            init: self.init@,
        }
    }
}
pub type GlobalInner<'a> = (Globaltype, Expr<'a>);

pub type GlobalInnerRef<'a> = (&'a Globaltype, &'a Expr<'a>);
impl<'a> From<&'a Global<'a>> for GlobalInnerRef<'a> {
    fn ex_from(m: &'a Global) -> GlobalInnerRef<'a> {
        (&m.gt, &m.init)
    }
}

impl<'a> From<GlobalInner<'a>> for Global<'a> {
    fn ex_from(m: GlobalInner) -> Global {
        let (gt, init) = m;
        Global { gt, init }
    }
}

pub struct GlobalMapper;
impl View for GlobalMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for GlobalMapper {
    type Src = SpecGlobalInner;
    type Dst = SpecGlobal;
}
impl SpecIsoProof for GlobalMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for GlobalMapper {
    type Src = GlobalInner<'a>;
    type Dst = Global<'a>;
    type RefSrc = GlobalInnerRef<'a>;
}
type SpecGlobalCombinatorAlias1 = (SpecGlobaltypeCombinator, SpecExprCombinator);
pub struct SpecGlobalCombinator(pub SpecGlobalCombinatorAlias);

impl SpecCombinator for SpecGlobalCombinator {
    type Type = SpecGlobal;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecGlobalCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecGlobalCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecGlobalCombinatorAlias = Mapped<SpecGlobalCombinatorAlias1, GlobalMapper>;
type GlobalCombinatorAlias1 = (GlobaltypeCombinator, ExprCombinator);
pub struct GlobalCombinator1(pub GlobalCombinatorAlias1);
impl View for GlobalCombinator1 {
    type V = SpecGlobalCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(GlobalCombinator1, GlobalCombinatorAlias1);

pub struct GlobalCombinator(pub GlobalCombinatorAlias);

impl View for GlobalCombinator {
    type V = SpecGlobalCombinator;
    open spec fn view(&self) -> Self::V { SpecGlobalCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for GlobalCombinator {
    type Type = Global<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type GlobalCombinatorAlias = Mapped<GlobalCombinator1, GlobalMapper>;


pub open spec fn spec_global() -> SpecGlobalCombinator {
    SpecGlobalCombinator(
    Mapped {
        inner: (spec_globaltype(), spec_expr()),
        mapper: GlobalMapper,
    })
}

                
pub fn global<'a>() -> (o: GlobalCombinator)
    ensures o@ == spec_global(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = GlobalCombinator(
    Mapped {
        inner: GlobalCombinator1((globaltype(), expr())),
        mapper: GlobalMapper,
    });
    assert({
        &&& combinator@ == spec_global()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_global<'a>(input: &'a [u8]) -> (res: PResult<<GlobalCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_global().spec_parse(input@) == Some((n as int, v@)),
        spec_global().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_global().spec_parse(input@) is None,
        spec_global().spec_parse(input@) is None ==> res is Err,
{
    let combinator = global();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_global<'a>(v: <GlobalCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_global().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_global().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_global().spec_serialize(v@))
        },
{
    let combinator = global();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn global_len<'a>(v: <GlobalCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_global().wf(v@),
        spec_global().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_global().spec_serialize(v@).len(),
{
    let combinator = global();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecGlobalsecContent {
    pub l: u64,
    pub v: Seq<SpecGlobal>,
}

pub type SpecGlobalsecContentInner = (u64, Seq<SpecGlobal>);


impl SpecFrom<SpecGlobalsecContent> for SpecGlobalsecContentInner {
    open spec fn spec_from(m: SpecGlobalsecContent) -> SpecGlobalsecContentInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecGlobalsecContentInner> for SpecGlobalsecContent {
    open spec fn spec_from(m: SpecGlobalsecContentInner) -> SpecGlobalsecContent {
        let (l, v) = m;
        SpecGlobalsecContent { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct GlobalsecContent<'a> {
    pub l: u64,
    pub v: RepeatResult<Global<'a>>,
}

impl View for GlobalsecContent<'_> {
    type V = SpecGlobalsecContent;

    open spec fn view(&self) -> Self::V {
        SpecGlobalsecContent {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type GlobalsecContentInner<'a> = (u64, RepeatResult<Global<'a>>);

pub type GlobalsecContentInnerRef<'a> = (&'a u64, &'a RepeatResult<Global<'a>>);
impl<'a> From<&'a GlobalsecContent<'a>> for GlobalsecContentInnerRef<'a> {
    fn ex_from(m: &'a GlobalsecContent) -> GlobalsecContentInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl<'a> From<GlobalsecContentInner<'a>> for GlobalsecContent<'a> {
    fn ex_from(m: GlobalsecContentInner) -> GlobalsecContent {
        let (l, v) = m;
        GlobalsecContent { l, v }
    }
}

pub struct GlobalsecContentMapper;
impl View for GlobalsecContentMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for GlobalsecContentMapper {
    type Src = SpecGlobalsecContentInner;
    type Dst = SpecGlobalsecContent;
}
impl SpecIsoProof for GlobalsecContentMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for GlobalsecContentMapper {
    type Src = GlobalsecContentInner<'a>;
    type Dst = GlobalsecContent<'a>;
    type RefSrc = GlobalsecContentInnerRef<'a>;
}

pub struct SpecGlobalsecContentCombinator(pub SpecGlobalsecContentCombinatorAlias);

impl SpecCombinator for SpecGlobalsecContentCombinator {
    type Type = SpecGlobalsecContent;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecGlobalsecContentCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecGlobalsecContentCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecGlobalsecContentCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecGlobalCombinator>>, GlobalsecContentMapper>;

pub struct GlobalsecContentCombinator(pub GlobalsecContentCombinatorAlias);

impl View for GlobalsecContentCombinator {
    type V = SpecGlobalsecContentCombinator;
    open spec fn view(&self) -> Self::V { SpecGlobalsecContentCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for GlobalsecContentCombinator {
    type Type = GlobalsecContent<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type GlobalsecContentCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<GlobalCombinator>, GlobalsecContentCont0>, GlobalsecContentMapper>;


pub open spec fn spec_globalsec_content() -> SpecGlobalsecContentCombinator {
    SpecGlobalsecContentCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_globalsec_content_cont0(deps)),
        mapper: GlobalsecContentMapper,
    })
}

pub open spec fn spec_globalsec_content_cont0(deps: u64) -> RepeatN<SpecGlobalCombinator> {
    let l = deps;
    RepeatN(spec_global(), l.spec_into())
}

impl View for GlobalsecContentCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecGlobalCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_globalsec_content_cont0(deps)
        }
    }
}

                
pub fn globalsec_content<'a>() -> (o: GlobalsecContentCombinator)
    ensures o@ == spec_globalsec_content(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = GlobalsecContentCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, GlobalsecContentCont0),
        mapper: GlobalsecContentMapper,
    });
    assert({
        &&& combinator@ == spec_globalsec_content()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_globalsec_content<'a>(input: &'a [u8]) -> (res: PResult<<GlobalsecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_globalsec_content().spec_parse(input@) == Some((n as int, v@)),
        spec_globalsec_content().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_globalsec_content().spec_parse(input@) is None,
        spec_globalsec_content().spec_parse(input@) is None ==> res is Err,
{
    let combinator = globalsec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_globalsec_content<'a>(v: <GlobalsecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_globalsec_content().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_globalsec_content().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_globalsec_content().spec_serialize(v@))
        },
{
    let combinator = globalsec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn globalsec_content_len<'a>(v: <GlobalsecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_globalsec_content().wf(v@),
        spec_globalsec_content().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_globalsec_content().spec_serialize(v@).len(),
{
    let combinator = globalsec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct GlobalsecContentCont0;
type GlobalsecContentCont0Type<'a, 'b> = &'b u64;
type GlobalsecContentCont0SType<'a, 'x> = &'x u64;
type GlobalsecContentCont0Input<'a, 'b, 'x> = POrSType<GlobalsecContentCont0Type<'a, 'b>, GlobalsecContentCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<GlobalsecContentCont0Input<'a, 'b, 'x>> for GlobalsecContentCont0 {
    type Output = RepeatN<GlobalCombinator>;

    open spec fn requires(&self, deps: GlobalsecContentCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: GlobalsecContentCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_globalsec_content_cont0(deps@)
    }

    fn apply(&self, deps: GlobalsecContentCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(global(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(global(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecGlobalsec {
    pub size: u64,
    pub cont: SpecGlobalsecContent,
}

pub type SpecGlobalsecInner = (u64, SpecGlobalsecContent);


impl SpecFrom<SpecGlobalsec> for SpecGlobalsecInner {
    open spec fn spec_from(m: SpecGlobalsec) -> SpecGlobalsecInner {
        (m.size, m.cont)
    }
}

impl SpecFrom<SpecGlobalsecInner> for SpecGlobalsec {
    open spec fn spec_from(m: SpecGlobalsecInner) -> SpecGlobalsec {
        let (size, cont) = m;
        SpecGlobalsec { size, cont }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Globalsec<'a> {
    pub size: u64,
    pub cont: GlobalsecContent<'a>,
}

impl View for Globalsec<'_> {
    type V = SpecGlobalsec;

    open spec fn view(&self) -> Self::V {
        SpecGlobalsec {
            size: self.size@,
            cont: self.cont@,
        }
    }
}
pub type GlobalsecInner<'a> = (u64, GlobalsecContent<'a>);

pub type GlobalsecInnerRef<'a> = (&'a u64, &'a GlobalsecContent<'a>);
impl<'a> From<&'a Globalsec<'a>> for GlobalsecInnerRef<'a> {
    fn ex_from(m: &'a Globalsec) -> GlobalsecInnerRef<'a> {
        (&m.size, &m.cont)
    }
}

impl<'a> From<GlobalsecInner<'a>> for Globalsec<'a> {
    fn ex_from(m: GlobalsecInner) -> Globalsec {
        let (size, cont) = m;
        Globalsec { size, cont }
    }
}

pub struct GlobalsecMapper;
impl View for GlobalsecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for GlobalsecMapper {
    type Src = SpecGlobalsecInner;
    type Dst = SpecGlobalsec;
}
impl SpecIsoProof for GlobalsecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for GlobalsecMapper {
    type Src = GlobalsecInner<'a>;
    type Dst = Globalsec<'a>;
    type RefSrc = GlobalsecInnerRef<'a>;
}

pub struct SpecGlobalsecCombinator(pub SpecGlobalsecCombinatorAlias);

impl SpecCombinator for SpecGlobalsecCombinator {
    type Type = SpecGlobalsec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecGlobalsecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecGlobalsecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecGlobalsecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, SpecGlobalsecContentCombinator>>, GlobalsecMapper>;

pub struct GlobalsecCombinator(pub GlobalsecCombinatorAlias);

impl View for GlobalsecCombinator {
    type V = SpecGlobalsecCombinator;
    open spec fn view(&self) -> Self::V { SpecGlobalsecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for GlobalsecCombinator {
    type Type = Globalsec<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type GlobalsecCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, GlobalsecContentCombinator>, GlobalsecCont0>, GlobalsecMapper>;


pub open spec fn spec_globalsec() -> SpecGlobalsecCombinator {
    SpecGlobalsecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_globalsec_cont0(deps)),
        mapper: GlobalsecMapper,
    })
}

pub open spec fn spec_globalsec_cont0(deps: u64) -> AndThen<bytes::Variable, SpecGlobalsecContentCombinator> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), spec_globalsec_content())
}

impl View for GlobalsecCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, SpecGlobalsecContentCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_globalsec_cont0(deps)
        }
    }
}

                
pub fn globalsec<'a>() -> (o: GlobalsecCombinator)
    ensures o@ == spec_globalsec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = GlobalsecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, GlobalsecCont0),
        mapper: GlobalsecMapper,
    });
    assert({
        &&& combinator@ == spec_globalsec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_globalsec<'a>(input: &'a [u8]) -> (res: PResult<<GlobalsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_globalsec().spec_parse(input@) == Some((n as int, v@)),
        spec_globalsec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_globalsec().spec_parse(input@) is None,
        spec_globalsec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = globalsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_globalsec<'a>(v: <GlobalsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_globalsec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_globalsec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_globalsec().spec_serialize(v@))
        },
{
    let combinator = globalsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn globalsec_len<'a>(v: <GlobalsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_globalsec().wf(v@),
        spec_globalsec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_globalsec().spec_serialize(v@).len(),
{
    let combinator = globalsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct GlobalsecCont0;
type GlobalsecCont0Type<'a, 'b> = &'b u64;
type GlobalsecCont0SType<'a, 'x> = &'x u64;
type GlobalsecCont0Input<'a, 'b, 'x> = POrSType<GlobalsecCont0Type<'a, 'b>, GlobalsecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<GlobalsecCont0Input<'a, 'b, 'x>> for GlobalsecCont0 {
    type Output = AndThen<bytes::Variable, GlobalsecContentCombinator>;

    open spec fn requires(&self, deps: GlobalsecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: GlobalsecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_globalsec_cont0(deps@)
    }

    fn apply(&self, deps: GlobalsecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), globalsec_content())
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), globalsec_content())
            }
        }
    }
}
                
pub type SpecSigned64 = Seq<u8>;
pub type Signed64<'a> = &'a [u8];
pub type Signed64Ref<'a> = &'a &'a [u8];


pub struct SpecSigned64Combinator(pub SpecSigned64CombinatorAlias);

impl SpecCombinator for SpecSigned64Combinator {
    type Type = SpecSigned64;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecSigned64Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecSigned64CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecSigned64CombinatorAlias = bytes::Fixed<8>;

pub struct Signed64Combinator(pub Signed64CombinatorAlias);

impl View for Signed64Combinator {
    type V = SpecSigned64Combinator;
    open spec fn view(&self) -> Self::V { SpecSigned64Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for Signed64Combinator {
    type Type = Signed64<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type Signed64CombinatorAlias = bytes::Fixed<8>;


pub open spec fn spec_signed_64() -> SpecSigned64Combinator {
    SpecSigned64Combinator(bytes::Fixed::<8>)
}

                
pub fn signed_64<'a>() -> (o: Signed64Combinator)
    ensures o@ == spec_signed_64(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = Signed64Combinator(bytes::Fixed::<8>);
    assert({
        &&& combinator@ == spec_signed_64()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_signed_64<'a>(input: &'a [u8]) -> (res: PResult<<Signed64Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_signed_64().spec_parse(input@) == Some((n as int, v@)),
        spec_signed_64().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_signed_64().spec_parse(input@) is None,
        spec_signed_64().spec_parse(input@) is None ==> res is Err,
{
    let combinator = signed_64();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_signed_64<'a>(v: <Signed64Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_signed_64().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_signed_64().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_signed_64().spec_serialize(v@))
        },
{
    let combinator = signed_64();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn signed_64_len<'a>(v: <Signed64Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_signed_64().wf(v@),
        spec_signed_64().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_signed_64().spec_serialize(v@).len(),
{
    let combinator = signed_64();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecTabletype {
    pub elemtype: SpecReftype,
    pub limits: SpecLimits,
}

pub type SpecTabletypeInner = (SpecReftype, SpecLimits);


impl SpecFrom<SpecTabletype> for SpecTabletypeInner {
    open spec fn spec_from(m: SpecTabletype) -> SpecTabletypeInner {
        (m.elemtype, m.limits)
    }
}

impl SpecFrom<SpecTabletypeInner> for SpecTabletype {
    open spec fn spec_from(m: SpecTabletypeInner) -> SpecTabletype {
        let (elemtype, limits) = m;
        SpecTabletype { elemtype, limits }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Tabletype {
    pub elemtype: Reftype,
    pub limits: Limits,
}

impl View for Tabletype {
    type V = SpecTabletype;

    open spec fn view(&self) -> Self::V {
        SpecTabletype {
            elemtype: self.elemtype@,
            limits: self.limits@,
        }
    }
}
pub type TabletypeInner = (Reftype, Limits);

pub type TabletypeInnerRef<'a> = (&'a Reftype, &'a Limits);
impl<'a> From<&'a Tabletype> for TabletypeInnerRef<'a> {
    fn ex_from(m: &'a Tabletype) -> TabletypeInnerRef<'a> {
        (&m.elemtype, &m.limits)
    }
}

impl From<TabletypeInner> for Tabletype {
    fn ex_from(m: TabletypeInner) -> Tabletype {
        let (elemtype, limits) = m;
        Tabletype { elemtype, limits }
    }
}

pub struct TabletypeMapper;
impl View for TabletypeMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for TabletypeMapper {
    type Src = SpecTabletypeInner;
    type Dst = SpecTabletype;
}
impl SpecIsoProof for TabletypeMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for TabletypeMapper {
    type Src = TabletypeInner;
    type Dst = Tabletype;
    type RefSrc = TabletypeInnerRef<'a>;
}
type SpecTabletypeCombinatorAlias1 = (SpecReftypeCombinator, SpecLimitsCombinator);
pub struct SpecTabletypeCombinator(pub SpecTabletypeCombinatorAlias);

impl SpecCombinator for SpecTabletypeCombinator {
    type Type = SpecTabletype;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTabletypeCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTabletypeCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTabletypeCombinatorAlias = Mapped<SpecTabletypeCombinatorAlias1, TabletypeMapper>;
type TabletypeCombinatorAlias1 = (ReftypeCombinator, LimitsCombinator);
pub struct TabletypeCombinator1(pub TabletypeCombinatorAlias1);
impl View for TabletypeCombinator1 {
    type V = SpecTabletypeCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(TabletypeCombinator1, TabletypeCombinatorAlias1);

pub struct TabletypeCombinator(pub TabletypeCombinatorAlias);

impl View for TabletypeCombinator {
    type V = SpecTabletypeCombinator;
    open spec fn view(&self) -> Self::V { SpecTabletypeCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TabletypeCombinator {
    type Type = Tabletype;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TabletypeCombinatorAlias = Mapped<TabletypeCombinator1, TabletypeMapper>;


pub open spec fn spec_tabletype() -> SpecTabletypeCombinator {
    SpecTabletypeCombinator(
    Mapped {
        inner: (spec_reftype(), spec_limits()),
        mapper: TabletypeMapper,
    })
}

                
pub fn tabletype<'a>() -> (o: TabletypeCombinator)
    ensures o@ == spec_tabletype(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TabletypeCombinator(
    Mapped {
        inner: TabletypeCombinator1((reftype(), limits())),
        mapper: TabletypeMapper,
    });
    assert({
        &&& combinator@ == spec_tabletype()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_tabletype<'a>(input: &'a [u8]) -> (res: PResult<<TabletypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_tabletype().spec_parse(input@) == Some((n as int, v@)),
        spec_tabletype().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_tabletype().spec_parse(input@) is None,
        spec_tabletype().spec_parse(input@) is None ==> res is Err,
{
    let combinator = tabletype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_tabletype<'a>(v: <TabletypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_tabletype().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_tabletype().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_tabletype().spec_serialize(v@))
        },
{
    let combinator = tabletype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn tabletype_len<'a>(v: <TabletypeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_tabletype().wf(v@),
        spec_tabletype().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_tabletype().spec_serialize(v@).len(),
{
    let combinator = tabletype();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub enum SpecImportdesc {
    Func(SpecTypeidx),
    Table(SpecTabletype),
    Mem(SpecMemtype),
    Global(SpecGlobaltype),
}

pub type SpecImportdescInner = Either<SpecTypeidx, Either<SpecTabletype, Either<SpecMemtype, SpecGlobaltype>>>;

impl SpecFrom<SpecImportdesc> for SpecImportdescInner {
    open spec fn spec_from(m: SpecImportdesc) -> SpecImportdescInner {
        match m {
            SpecImportdesc::Func(m) => Either::Left(m),
            SpecImportdesc::Table(m) => Either::Right(Either::Left(m)),
            SpecImportdesc::Mem(m) => Either::Right(Either::Right(Either::Left(m))),
            SpecImportdesc::Global(m) => Either::Right(Either::Right(Either::Right(m))),
        }
    }

}

                
impl SpecFrom<SpecImportdescInner> for SpecImportdesc {
    open spec fn spec_from(m: SpecImportdescInner) -> SpecImportdesc {
        match m {
            Either::Left(m) => SpecImportdesc::Func(m),
            Either::Right(Either::Left(m)) => SpecImportdesc::Table(m),
            Either::Right(Either::Right(Either::Left(m))) => SpecImportdesc::Mem(m),
            Either::Right(Either::Right(Either::Right(m))) => SpecImportdesc::Global(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Importdesc {
    Func(Typeidx),
    Table(Tabletype),
    Mem(Memtype),
    Global(Globaltype),
}

pub type ImportdescInner = Either<Typeidx, Either<Tabletype, Either<Memtype, Globaltype>>>;

pub type ImportdescInnerRef<'a> = Either<&'a Typeidx, Either<&'a Tabletype, Either<&'a Memtype, &'a Globaltype>>>;


impl View for Importdesc {
    type V = SpecImportdesc;
    open spec fn view(&self) -> Self::V {
        match self {
            Importdesc::Func(m) => SpecImportdesc::Func(m@),
            Importdesc::Table(m) => SpecImportdesc::Table(m@),
            Importdesc::Mem(m) => SpecImportdesc::Mem(m@),
            Importdesc::Global(m) => SpecImportdesc::Global(m@),
        }
    }
}


impl<'a> From<&'a Importdesc> for ImportdescInnerRef<'a> {
    fn ex_from(m: &'a Importdesc) -> ImportdescInnerRef<'a> {
        match m {
            Importdesc::Func(m) => Either::Left(m),
            Importdesc::Table(m) => Either::Right(Either::Left(m)),
            Importdesc::Mem(m) => Either::Right(Either::Right(Either::Left(m))),
            Importdesc::Global(m) => Either::Right(Either::Right(Either::Right(m))),
        }
    }

}

impl From<ImportdescInner> for Importdesc {
    fn ex_from(m: ImportdescInner) -> Importdesc {
        match m {
            Either::Left(m) => Importdesc::Func(m),
            Either::Right(Either::Left(m)) => Importdesc::Table(m),
            Either::Right(Either::Right(Either::Left(m))) => Importdesc::Mem(m),
            Either::Right(Either::Right(Either::Right(m))) => Importdesc::Global(m),
        }
    }
    
}


pub struct ImportdescMapper;
impl View for ImportdescMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ImportdescMapper {
    type Src = SpecImportdescInner;
    type Dst = SpecImportdesc;
}
impl SpecIsoProof for ImportdescMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ImportdescMapper {
    type Src = ImportdescInner;
    type Dst = Importdesc;
    type RefSrc = ImportdescInnerRef<'a>;
}

pub const IMPORTDESCFUNC_0_FRONT_CONST: u8 = 0;

pub const IMPORTDESCTABLE_0_FRONT_CONST: u8 = 1;

pub const IMPORTDESCMEM_0_FRONT_CONST: u8 = 2;

pub const IMPORTDESCGLOBAL_0_FRONT_CONST: u8 = 3;

type SpecImportdescCombinatorAlias1 = Choice<Preceded<Tag<U8, u8>, SpecMemtypeCombinator>, Preceded<Tag<U8, u8>, SpecGlobaltypeCombinator>>;
type SpecImportdescCombinatorAlias2 = Choice<Preceded<Tag<U8, u8>, SpecTabletypeCombinator>, SpecImportdescCombinatorAlias1>;
type SpecImportdescCombinatorAlias3 = Choice<Preceded<Tag<U8, u8>, SpecTypeidxCombinator>, SpecImportdescCombinatorAlias2>;
pub struct SpecImportdescCombinator(pub SpecImportdescCombinatorAlias);

impl SpecCombinator for SpecImportdescCombinator {
    type Type = SpecImportdesc;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecImportdescCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecImportdescCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecImportdescCombinatorAlias = Mapped<SpecImportdescCombinatorAlias3, ImportdescMapper>;




type ImportdescCombinatorAlias1 = Choice<Preceded<Tag<U8, u8>, MemtypeCombinator>, Preceded<Tag<U8, u8>, GlobaltypeCombinator>>;
type ImportdescCombinatorAlias2 = Choice<Preceded<Tag<U8, u8>, TabletypeCombinator>, ImportdescCombinator1>;
type ImportdescCombinatorAlias3 = Choice<Preceded<Tag<U8, u8>, TypeidxCombinator>, ImportdescCombinator2>;
pub struct ImportdescCombinator1(pub ImportdescCombinatorAlias1);
impl View for ImportdescCombinator1 {
    type V = SpecImportdescCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ImportdescCombinator1, ImportdescCombinatorAlias1);

pub struct ImportdescCombinator2(pub ImportdescCombinatorAlias2);
impl View for ImportdescCombinator2 {
    type V = SpecImportdescCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ImportdescCombinator2, ImportdescCombinatorAlias2);

pub struct ImportdescCombinator3(pub ImportdescCombinatorAlias3);
impl View for ImportdescCombinator3 {
    type V = SpecImportdescCombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ImportdescCombinator3, ImportdescCombinatorAlias3);

pub struct ImportdescCombinator(pub ImportdescCombinatorAlias);

impl View for ImportdescCombinator {
    type V = SpecImportdescCombinator;
    open spec fn view(&self) -> Self::V { SpecImportdescCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ImportdescCombinator {
    type Type = Importdesc;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ImportdescCombinatorAlias = Mapped<ImportdescCombinator3, ImportdescMapper>;


pub open spec fn spec_importdesc() -> SpecImportdescCombinator {
    SpecImportdescCombinator(Mapped { inner: Choice(Preceded(Tag::spec_new(U8, IMPORTDESCFUNC_0_FRONT_CONST), spec_typeidx()), Choice(Preceded(Tag::spec_new(U8, IMPORTDESCTABLE_0_FRONT_CONST), spec_tabletype()), Choice(Preceded(Tag::spec_new(U8, IMPORTDESCMEM_0_FRONT_CONST), spec_memtype()), Preceded(Tag::spec_new(U8, IMPORTDESCGLOBAL_0_FRONT_CONST), spec_globaltype())))), mapper: ImportdescMapper })
}

                
pub fn importdesc<'a>() -> (o: ImportdescCombinator)
    ensures o@ == spec_importdesc(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ImportdescCombinator(Mapped { inner: ImportdescCombinator3(Choice::new(Preceded(Tag::new(U8, IMPORTDESCFUNC_0_FRONT_CONST), typeidx()), ImportdescCombinator2(Choice::new(Preceded(Tag::new(U8, IMPORTDESCTABLE_0_FRONT_CONST), tabletype()), ImportdescCombinator1(Choice::new(Preceded(Tag::new(U8, IMPORTDESCMEM_0_FRONT_CONST), memtype()), Preceded(Tag::new(U8, IMPORTDESCGLOBAL_0_FRONT_CONST), globaltype()))))))), mapper: ImportdescMapper });
    assert({
        &&& combinator@ == spec_importdesc()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_importdesc<'a>(input: &'a [u8]) -> (res: PResult<<ImportdescCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_importdesc().spec_parse(input@) == Some((n as int, v@)),
        spec_importdesc().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_importdesc().spec_parse(input@) is None,
        spec_importdesc().spec_parse(input@) is None ==> res is Err,
{
    let combinator = importdesc();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_importdesc<'a>(v: <ImportdescCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_importdesc().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_importdesc().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_importdesc().spec_serialize(v@))
        },
{
    let combinator = importdesc();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn importdesc_len<'a>(v: <ImportdescCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_importdesc().wf(v@),
        spec_importdesc().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_importdesc().spec_serialize(v@).len(),
{
    let combinator = importdesc();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecImport {
    pub module: SpecName,
    pub name: SpecName,
    pub desc: SpecImportdesc,
}

pub type SpecImportInner = (SpecName, (SpecName, SpecImportdesc));


impl SpecFrom<SpecImport> for SpecImportInner {
    open spec fn spec_from(m: SpecImport) -> SpecImportInner {
        (m.module, (m.name, m.desc))
    }
}

impl SpecFrom<SpecImportInner> for SpecImport {
    open spec fn spec_from(m: SpecImportInner) -> SpecImport {
        let (module, (name, desc)) = m;
        SpecImport { module, name, desc }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Import {
    pub module: Name,
    pub name: Name,
    pub desc: Importdesc,
}

impl View for Import {
    type V = SpecImport;

    open spec fn view(&self) -> Self::V {
        SpecImport {
            module: self.module@,
            name: self.name@,
            desc: self.desc@,
        }
    }
}
pub type ImportInner = (Name, (Name, Importdesc));

pub type ImportInnerRef<'a> = (&'a Name, (&'a Name, &'a Importdesc));
impl<'a> From<&'a Import> for ImportInnerRef<'a> {
    fn ex_from(m: &'a Import) -> ImportInnerRef<'a> {
        (&m.module, (&m.name, &m.desc))
    }
}

impl From<ImportInner> for Import {
    fn ex_from(m: ImportInner) -> Import {
        let (module, (name, desc)) = m;
        Import { module, name, desc }
    }
}

pub struct ImportMapper;
impl View for ImportMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ImportMapper {
    type Src = SpecImportInner;
    type Dst = SpecImport;
}
impl SpecIsoProof for ImportMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ImportMapper {
    type Src = ImportInner;
    type Dst = Import;
    type RefSrc = ImportInnerRef<'a>;
}
type SpecImportCombinatorAlias1 = (SpecNameCombinator, SpecImportdescCombinator);
type SpecImportCombinatorAlias2 = (SpecNameCombinator, SpecImportCombinatorAlias1);
pub struct SpecImportCombinator(pub SpecImportCombinatorAlias);

impl SpecCombinator for SpecImportCombinator {
    type Type = SpecImport;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecImportCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecImportCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecImportCombinatorAlias = Mapped<SpecImportCombinatorAlias2, ImportMapper>;
type ImportCombinatorAlias1 = (NameCombinator, ImportdescCombinator);
type ImportCombinatorAlias2 = (NameCombinator, ImportCombinator1);
pub struct ImportCombinator1(pub ImportCombinatorAlias1);
impl View for ImportCombinator1 {
    type V = SpecImportCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ImportCombinator1, ImportCombinatorAlias1);

pub struct ImportCombinator2(pub ImportCombinatorAlias2);
impl View for ImportCombinator2 {
    type V = SpecImportCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ImportCombinator2, ImportCombinatorAlias2);

pub struct ImportCombinator(pub ImportCombinatorAlias);

impl View for ImportCombinator {
    type V = SpecImportCombinator;
    open spec fn view(&self) -> Self::V { SpecImportCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ImportCombinator {
    type Type = Import;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ImportCombinatorAlias = Mapped<ImportCombinator2, ImportMapper>;


pub open spec fn spec_import() -> SpecImportCombinator {
    SpecImportCombinator(
    Mapped {
        inner: (spec_name(), (spec_name(), spec_importdesc())),
        mapper: ImportMapper,
    })
}

                
pub fn import<'a>() -> (o: ImportCombinator)
    ensures o@ == spec_import(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ImportCombinator(
    Mapped {
        inner: ImportCombinator2((name(), ImportCombinator1((name(), importdesc())))),
        mapper: ImportMapper,
    });
    assert({
        &&& combinator@ == spec_import()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_import<'a>(input: &'a [u8]) -> (res: PResult<<ImportCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_import().spec_parse(input@) == Some((n as int, v@)),
        spec_import().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_import().spec_parse(input@) is None,
        spec_import().spec_parse(input@) is None ==> res is Err,
{
    let combinator = import();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_import<'a>(v: <ImportCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_import().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_import().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_import().spec_serialize(v@))
        },
{
    let combinator = import();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn import_len<'a>(v: <ImportCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_import().wf(v@),
        spec_import().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_import().spec_serialize(v@).len(),
{
    let combinator = import();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecTable {
    pub ty: SpecTabletype,
}

pub type SpecTableInner = SpecTabletype;


impl SpecFrom<SpecTable> for SpecTableInner {
    open spec fn spec_from(m: SpecTable) -> SpecTableInner {
        m.ty
    }
}

impl SpecFrom<SpecTableInner> for SpecTable {
    open spec fn spec_from(m: SpecTableInner) -> SpecTable {
        let ty = m;
        SpecTable { ty }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Table {
    pub ty: Tabletype,
}

impl View for Table {
    type V = SpecTable;

    open spec fn view(&self) -> Self::V {
        SpecTable {
            ty: self.ty@,
        }
    }
}
pub type TableInner = Tabletype;

pub type TableInnerRef<'a> = &'a Tabletype;
impl<'a> From<&'a Table> for TableInnerRef<'a> {
    fn ex_from(m: &'a Table) -> TableInnerRef<'a> {
        &m.ty
    }
}

impl From<TableInner> for Table {
    fn ex_from(m: TableInner) -> Table {
        let ty = m;
        Table { ty }
    }
}

pub struct TableMapper;
impl View for TableMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for TableMapper {
    type Src = SpecTableInner;
    type Dst = SpecTable;
}
impl SpecIsoProof for TableMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for TableMapper {
    type Src = TableInner;
    type Dst = Table;
    type RefSrc = TableInnerRef<'a>;
}

pub struct SpecTableCombinator(pub SpecTableCombinatorAlias);

impl SpecCombinator for SpecTableCombinator {
    type Type = SpecTable;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTableCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTableCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTableCombinatorAlias = Mapped<SpecTabletypeCombinator, TableMapper>;

pub struct TableCombinator(pub TableCombinatorAlias);

impl View for TableCombinator {
    type V = SpecTableCombinator;
    open spec fn view(&self) -> Self::V { SpecTableCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TableCombinator {
    type Type = Table;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TableCombinatorAlias = Mapped<TabletypeCombinator, TableMapper>;


pub open spec fn spec_table() -> SpecTableCombinator {
    SpecTableCombinator(
    Mapped {
        inner: spec_tabletype(),
        mapper: TableMapper,
    })
}

                
pub fn table<'a>() -> (o: TableCombinator)
    ensures o@ == spec_table(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TableCombinator(
    Mapped {
        inner: tabletype(),
        mapper: TableMapper,
    });
    assert({
        &&& combinator@ == spec_table()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_table<'a>(input: &'a [u8]) -> (res: PResult<<TableCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_table().spec_parse(input@) == Some((n as int, v@)),
        spec_table().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_table().spec_parse(input@) is None,
        spec_table().spec_parse(input@) is None ==> res is Err,
{
    let combinator = table();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_table<'a>(v: <TableCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_table().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_table().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_table().spec_serialize(v@))
        },
{
    let combinator = table();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn table_len<'a>(v: <TableCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_table().wf(v@),
        spec_table().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_table().spec_serialize(v@).len(),
{
    let combinator = table();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecTablesecContent {
    pub l: u64,
    pub v: Seq<SpecTable>,
}

pub type SpecTablesecContentInner = (u64, Seq<SpecTable>);


impl SpecFrom<SpecTablesecContent> for SpecTablesecContentInner {
    open spec fn spec_from(m: SpecTablesecContent) -> SpecTablesecContentInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecTablesecContentInner> for SpecTablesecContent {
    open spec fn spec_from(m: SpecTablesecContentInner) -> SpecTablesecContent {
        let (l, v) = m;
        SpecTablesecContent { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct TablesecContent {
    pub l: u64,
    pub v: RepeatResult<Table>,
}

impl View for TablesecContent {
    type V = SpecTablesecContent;

    open spec fn view(&self) -> Self::V {
        SpecTablesecContent {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type TablesecContentInner = (u64, RepeatResult<Table>);

pub type TablesecContentInnerRef<'a> = (&'a u64, &'a RepeatResult<Table>);
impl<'a> From<&'a TablesecContent> for TablesecContentInnerRef<'a> {
    fn ex_from(m: &'a TablesecContent) -> TablesecContentInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl From<TablesecContentInner> for TablesecContent {
    fn ex_from(m: TablesecContentInner) -> TablesecContent {
        let (l, v) = m;
        TablesecContent { l, v }
    }
}

pub struct TablesecContentMapper;
impl View for TablesecContentMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for TablesecContentMapper {
    type Src = SpecTablesecContentInner;
    type Dst = SpecTablesecContent;
}
impl SpecIsoProof for TablesecContentMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for TablesecContentMapper {
    type Src = TablesecContentInner;
    type Dst = TablesecContent;
    type RefSrc = TablesecContentInnerRef<'a>;
}

pub struct SpecTablesecContentCombinator(pub SpecTablesecContentCombinatorAlias);

impl SpecCombinator for SpecTablesecContentCombinator {
    type Type = SpecTablesecContent;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTablesecContentCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTablesecContentCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTablesecContentCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecTableCombinator>>, TablesecContentMapper>;

pub struct TablesecContentCombinator(pub TablesecContentCombinatorAlias);

impl View for TablesecContentCombinator {
    type V = SpecTablesecContentCombinator;
    open spec fn view(&self) -> Self::V { SpecTablesecContentCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TablesecContentCombinator {
    type Type = TablesecContent;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TablesecContentCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<TableCombinator>, TablesecContentCont0>, TablesecContentMapper>;


pub open spec fn spec_tablesec_content() -> SpecTablesecContentCombinator {
    SpecTablesecContentCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_tablesec_content_cont0(deps)),
        mapper: TablesecContentMapper,
    })
}

pub open spec fn spec_tablesec_content_cont0(deps: u64) -> RepeatN<SpecTableCombinator> {
    let l = deps;
    RepeatN(spec_table(), l.spec_into())
}

impl View for TablesecContentCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecTableCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_tablesec_content_cont0(deps)
        }
    }
}

                
pub fn tablesec_content<'a>() -> (o: TablesecContentCombinator)
    ensures o@ == spec_tablesec_content(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TablesecContentCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, TablesecContentCont0),
        mapper: TablesecContentMapper,
    });
    assert({
        &&& combinator@ == spec_tablesec_content()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_tablesec_content<'a>(input: &'a [u8]) -> (res: PResult<<TablesecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_tablesec_content().spec_parse(input@) == Some((n as int, v@)),
        spec_tablesec_content().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_tablesec_content().spec_parse(input@) is None,
        spec_tablesec_content().spec_parse(input@) is None ==> res is Err,
{
    let combinator = tablesec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_tablesec_content<'a>(v: <TablesecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_tablesec_content().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_tablesec_content().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_tablesec_content().spec_serialize(v@))
        },
{
    let combinator = tablesec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn tablesec_content_len<'a>(v: <TablesecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_tablesec_content().wf(v@),
        spec_tablesec_content().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_tablesec_content().spec_serialize(v@).len(),
{
    let combinator = tablesec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct TablesecContentCont0;
type TablesecContentCont0Type<'a, 'b> = &'b u64;
type TablesecContentCont0SType<'a, 'x> = &'x u64;
type TablesecContentCont0Input<'a, 'b, 'x> = POrSType<TablesecContentCont0Type<'a, 'b>, TablesecContentCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<TablesecContentCont0Input<'a, 'b, 'x>> for TablesecContentCont0 {
    type Output = RepeatN<TableCombinator>;

    open spec fn requires(&self, deps: TablesecContentCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: TablesecContentCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_tablesec_content_cont0(deps@)
    }

    fn apply(&self, deps: TablesecContentCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(table(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(table(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecTablesec {
    pub size: u64,
    pub cont: SpecTablesecContent,
}

pub type SpecTablesecInner = (u64, SpecTablesecContent);


impl SpecFrom<SpecTablesec> for SpecTablesecInner {
    open spec fn spec_from(m: SpecTablesec) -> SpecTablesecInner {
        (m.size, m.cont)
    }
}

impl SpecFrom<SpecTablesecInner> for SpecTablesec {
    open spec fn spec_from(m: SpecTablesecInner) -> SpecTablesec {
        let (size, cont) = m;
        SpecTablesec { size, cont }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Tablesec {
    pub size: u64,
    pub cont: TablesecContent,
}

impl View for Tablesec {
    type V = SpecTablesec;

    open spec fn view(&self) -> Self::V {
        SpecTablesec {
            size: self.size@,
            cont: self.cont@,
        }
    }
}
pub type TablesecInner = (u64, TablesecContent);

pub type TablesecInnerRef<'a> = (&'a u64, &'a TablesecContent);
impl<'a> From<&'a Tablesec> for TablesecInnerRef<'a> {
    fn ex_from(m: &'a Tablesec) -> TablesecInnerRef<'a> {
        (&m.size, &m.cont)
    }
}

impl From<TablesecInner> for Tablesec {
    fn ex_from(m: TablesecInner) -> Tablesec {
        let (size, cont) = m;
        Tablesec { size, cont }
    }
}

pub struct TablesecMapper;
impl View for TablesecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for TablesecMapper {
    type Src = SpecTablesecInner;
    type Dst = SpecTablesec;
}
impl SpecIsoProof for TablesecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for TablesecMapper {
    type Src = TablesecInner;
    type Dst = Tablesec;
    type RefSrc = TablesecInnerRef<'a>;
}

pub struct SpecTablesecCombinator(pub SpecTablesecCombinatorAlias);

impl SpecCombinator for SpecTablesecCombinator {
    type Type = SpecTablesec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTablesecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTablesecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTablesecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, SpecTablesecContentCombinator>>, TablesecMapper>;

pub struct TablesecCombinator(pub TablesecCombinatorAlias);

impl View for TablesecCombinator {
    type V = SpecTablesecCombinator;
    open spec fn view(&self) -> Self::V { SpecTablesecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TablesecCombinator {
    type Type = Tablesec;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TablesecCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, TablesecContentCombinator>, TablesecCont0>, TablesecMapper>;


pub open spec fn spec_tablesec() -> SpecTablesecCombinator {
    SpecTablesecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_tablesec_cont0(deps)),
        mapper: TablesecMapper,
    })
}

pub open spec fn spec_tablesec_cont0(deps: u64) -> AndThen<bytes::Variable, SpecTablesecContentCombinator> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), spec_tablesec_content())
}

impl View for TablesecCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, SpecTablesecContentCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_tablesec_cont0(deps)
        }
    }
}

                
pub fn tablesec<'a>() -> (o: TablesecCombinator)
    ensures o@ == spec_tablesec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TablesecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, TablesecCont0),
        mapper: TablesecMapper,
    });
    assert({
        &&& combinator@ == spec_tablesec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_tablesec<'a>(input: &'a [u8]) -> (res: PResult<<TablesecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_tablesec().spec_parse(input@) == Some((n as int, v@)),
        spec_tablesec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_tablesec().spec_parse(input@) is None,
        spec_tablesec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = tablesec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_tablesec<'a>(v: <TablesecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_tablesec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_tablesec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_tablesec().spec_serialize(v@))
        },
{
    let combinator = tablesec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn tablesec_len<'a>(v: <TablesecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_tablesec().wf(v@),
        spec_tablesec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_tablesec().spec_serialize(v@).len(),
{
    let combinator = tablesec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct TablesecCont0;
type TablesecCont0Type<'a, 'b> = &'b u64;
type TablesecCont0SType<'a, 'x> = &'x u64;
type TablesecCont0Input<'a, 'b, 'x> = POrSType<TablesecCont0Type<'a, 'b>, TablesecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<TablesecCont0Input<'a, 'b, 'x>> for TablesecCont0 {
    type Output = AndThen<bytes::Variable, TablesecContentCombinator>;

    open spec fn requires(&self, deps: TablesecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: TablesecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_tablesec_cont0(deps@)
    }

    fn apply(&self, deps: TablesecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), tablesec_content())
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), tablesec_content())
            }
        }
    }
}
                

pub struct SpecLocals {
    pub l: u64,
    pub v: Seq<SpecLocalCompressed>,
}

pub type SpecLocalsInner = (u64, Seq<SpecLocalCompressed>);


impl SpecFrom<SpecLocals> for SpecLocalsInner {
    open spec fn spec_from(m: SpecLocals) -> SpecLocalsInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecLocalsInner> for SpecLocals {
    open spec fn spec_from(m: SpecLocalsInner) -> SpecLocals {
        let (l, v) = m;
        SpecLocals { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Locals {
    pub l: u64,
    pub v: RepeatResult<LocalCompressed>,
}

impl View for Locals {
    type V = SpecLocals;

    open spec fn view(&self) -> Self::V {
        SpecLocals {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type LocalsInner = (u64, RepeatResult<LocalCompressed>);

pub type LocalsInnerRef<'a> = (&'a u64, &'a RepeatResult<LocalCompressed>);
impl<'a> From<&'a Locals> for LocalsInnerRef<'a> {
    fn ex_from(m: &'a Locals) -> LocalsInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl From<LocalsInner> for Locals {
    fn ex_from(m: LocalsInner) -> Locals {
        let (l, v) = m;
        Locals { l, v }
    }
}

pub struct LocalsMapper;
impl View for LocalsMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for LocalsMapper {
    type Src = SpecLocalsInner;
    type Dst = SpecLocals;
}
impl SpecIsoProof for LocalsMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for LocalsMapper {
    type Src = LocalsInner;
    type Dst = Locals;
    type RefSrc = LocalsInnerRef<'a>;
}

pub struct SpecLocalsCombinator(pub SpecLocalsCombinatorAlias);

impl SpecCombinator for SpecLocalsCombinator {
    type Type = SpecLocals;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecLocalsCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecLocalsCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecLocalsCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecLocalCompressedCombinator>>, LocalsMapper>;

pub struct LocalsCombinator(pub LocalsCombinatorAlias);

impl View for LocalsCombinator {
    type V = SpecLocalsCombinator;
    open spec fn view(&self) -> Self::V { SpecLocalsCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for LocalsCombinator {
    type Type = Locals;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type LocalsCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<LocalCompressedCombinator>, LocalsCont0>, LocalsMapper>;


pub open spec fn spec_locals() -> SpecLocalsCombinator {
    SpecLocalsCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_locals_cont0(deps)),
        mapper: LocalsMapper,
    })
}

pub open spec fn spec_locals_cont0(deps: u64) -> RepeatN<SpecLocalCompressedCombinator> {
    let l = deps;
    RepeatN(spec_local_compressed(), l.spec_into())
}

impl View for LocalsCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecLocalCompressedCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_locals_cont0(deps)
        }
    }
}

                
pub fn locals<'a>() -> (o: LocalsCombinator)
    ensures o@ == spec_locals(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = LocalsCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, LocalsCont0),
        mapper: LocalsMapper,
    });
    assert({
        &&& combinator@ == spec_locals()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_locals<'a>(input: &'a [u8]) -> (res: PResult<<LocalsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_locals().spec_parse(input@) == Some((n as int, v@)),
        spec_locals().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_locals().spec_parse(input@) is None,
        spec_locals().spec_parse(input@) is None ==> res is Err,
{
    let combinator = locals();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_locals<'a>(v: <LocalsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_locals().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_locals().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_locals().spec_serialize(v@))
        },
{
    let combinator = locals();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn locals_len<'a>(v: <LocalsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_locals().wf(v@),
        spec_locals().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_locals().spec_serialize(v@).len(),
{
    let combinator = locals();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct LocalsCont0;
type LocalsCont0Type<'a, 'b> = &'b u64;
type LocalsCont0SType<'a, 'x> = &'x u64;
type LocalsCont0Input<'a, 'b, 'x> = POrSType<LocalsCont0Type<'a, 'b>, LocalsCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<LocalsCont0Input<'a, 'b, 'x>> for LocalsCont0 {
    type Output = RepeatN<LocalCompressedCombinator>;

    open spec fn requires(&self, deps: LocalsCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: LocalsCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_locals_cont0(deps@)
    }

    fn apply(&self, deps: LocalsCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(local_compressed(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(local_compressed(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecFunc {
    pub locals: SpecLocals,
    pub body: SpecExpr,
}

pub type SpecFuncInner = (SpecLocals, SpecExpr);


impl SpecFrom<SpecFunc> for SpecFuncInner {
    open spec fn spec_from(m: SpecFunc) -> SpecFuncInner {
        (m.locals, m.body)
    }
}

impl SpecFrom<SpecFuncInner> for SpecFunc {
    open spec fn spec_from(m: SpecFuncInner) -> SpecFunc {
        let (locals, body) = m;
        SpecFunc { locals, body }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Func<'a> {
    pub locals: Locals,
    pub body: Expr<'a>,
}

impl View for Func<'_> {
    type V = SpecFunc;

    open spec fn view(&self) -> Self::V {
        SpecFunc {
            locals: self.locals@,
            body: self.body@,
        }
    }
}
pub type FuncInner<'a> = (Locals, Expr<'a>);

pub type FuncInnerRef<'a> = (&'a Locals, &'a Expr<'a>);
impl<'a> From<&'a Func<'a>> for FuncInnerRef<'a> {
    fn ex_from(m: &'a Func) -> FuncInnerRef<'a> {
        (&m.locals, &m.body)
    }
}

impl<'a> From<FuncInner<'a>> for Func<'a> {
    fn ex_from(m: FuncInner) -> Func {
        let (locals, body) = m;
        Func { locals, body }
    }
}

pub struct FuncMapper;
impl View for FuncMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for FuncMapper {
    type Src = SpecFuncInner;
    type Dst = SpecFunc;
}
impl SpecIsoProof for FuncMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for FuncMapper {
    type Src = FuncInner<'a>;
    type Dst = Func<'a>;
    type RefSrc = FuncInnerRef<'a>;
}
type SpecFuncCombinatorAlias1 = (SpecLocalsCombinator, SpecExprCombinator);
pub struct SpecFuncCombinator(pub SpecFuncCombinatorAlias);

impl SpecCombinator for SpecFuncCombinator {
    type Type = SpecFunc;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecFuncCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecFuncCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecFuncCombinatorAlias = Mapped<SpecFuncCombinatorAlias1, FuncMapper>;
type FuncCombinatorAlias1 = (LocalsCombinator, ExprCombinator);
pub struct FuncCombinator1(pub FuncCombinatorAlias1);
impl View for FuncCombinator1 {
    type V = SpecFuncCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(FuncCombinator1, FuncCombinatorAlias1);

pub struct FuncCombinator(pub FuncCombinatorAlias);

impl View for FuncCombinator {
    type V = SpecFuncCombinator;
    open spec fn view(&self) -> Self::V { SpecFuncCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for FuncCombinator {
    type Type = Func<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type FuncCombinatorAlias = Mapped<FuncCombinator1, FuncMapper>;


pub open spec fn spec_func() -> SpecFuncCombinator {
    SpecFuncCombinator(
    Mapped {
        inner: (spec_locals(), spec_expr()),
        mapper: FuncMapper,
    })
}

                
pub fn func<'a>() -> (o: FuncCombinator)
    ensures o@ == spec_func(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = FuncCombinator(
    Mapped {
        inner: FuncCombinator1((locals(), expr())),
        mapper: FuncMapper,
    });
    assert({
        &&& combinator@ == spec_func()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_func<'a>(input: &'a [u8]) -> (res: PResult<<FuncCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_func().spec_parse(input@) == Some((n as int, v@)),
        spec_func().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_func().spec_parse(input@) is None,
        spec_func().spec_parse(input@) is None ==> res is Err,
{
    let combinator = func();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_func<'a>(v: <FuncCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_func().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_func().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_func().spec_serialize(v@))
        },
{
    let combinator = func();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn func_len<'a>(v: <FuncCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_func().wf(v@),
        spec_func().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_func().spec_serialize(v@).len(),
{
    let combinator = func();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecCode {
    pub size: u64,
    pub code: SpecFunc,
}

pub type SpecCodeInner = (u64, SpecFunc);


impl SpecFrom<SpecCode> for SpecCodeInner {
    open spec fn spec_from(m: SpecCode) -> SpecCodeInner {
        (m.size, m.code)
    }
}

impl SpecFrom<SpecCodeInner> for SpecCode {
    open spec fn spec_from(m: SpecCodeInner) -> SpecCode {
        let (size, code) = m;
        SpecCode { size, code }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Code<'a> {
    pub size: u64,
    pub code: Func<'a>,
}

impl View for Code<'_> {
    type V = SpecCode;

    open spec fn view(&self) -> Self::V {
        SpecCode {
            size: self.size@,
            code: self.code@,
        }
    }
}
pub type CodeInner<'a> = (u64, Func<'a>);

pub type CodeInnerRef<'a> = (&'a u64, &'a Func<'a>);
impl<'a> From<&'a Code<'a>> for CodeInnerRef<'a> {
    fn ex_from(m: &'a Code) -> CodeInnerRef<'a> {
        (&m.size, &m.code)
    }
}

impl<'a> From<CodeInner<'a>> for Code<'a> {
    fn ex_from(m: CodeInner) -> Code {
        let (size, code) = m;
        Code { size, code }
    }
}

pub struct CodeMapper;
impl View for CodeMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for CodeMapper {
    type Src = SpecCodeInner;
    type Dst = SpecCode;
}
impl SpecIsoProof for CodeMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for CodeMapper {
    type Src = CodeInner<'a>;
    type Dst = Code<'a>;
    type RefSrc = CodeInnerRef<'a>;
}

pub struct SpecCodeCombinator(pub SpecCodeCombinatorAlias);

impl SpecCombinator for SpecCodeCombinator {
    type Type = SpecCode;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecCodeCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecCodeCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecCodeCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, SpecFuncCombinator>>, CodeMapper>;

pub struct CodeCombinator(pub CodeCombinatorAlias);

impl View for CodeCombinator {
    type V = SpecCodeCombinator;
    open spec fn view(&self) -> Self::V { SpecCodeCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for CodeCombinator {
    type Type = Code<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type CodeCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, FuncCombinator>, CodeCont0>, CodeMapper>;


pub open spec fn spec_code() -> SpecCodeCombinator {
    SpecCodeCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_code_cont0(deps)),
        mapper: CodeMapper,
    })
}

pub open spec fn spec_code_cont0(deps: u64) -> AndThen<bytes::Variable, SpecFuncCombinator> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), spec_func())
}

impl View for CodeCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, SpecFuncCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_code_cont0(deps)
        }
    }
}

                
pub fn code<'a>() -> (o: CodeCombinator)
    ensures o@ == spec_code(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = CodeCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, CodeCont0),
        mapper: CodeMapper,
    });
    assert({
        &&& combinator@ == spec_code()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_code<'a>(input: &'a [u8]) -> (res: PResult<<CodeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_code().spec_parse(input@) == Some((n as int, v@)),
        spec_code().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_code().spec_parse(input@) is None,
        spec_code().spec_parse(input@) is None ==> res is Err,
{
    let combinator = code();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_code<'a>(v: <CodeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_code().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_code().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_code().spec_serialize(v@))
        },
{
    let combinator = code();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn code_len<'a>(v: <CodeCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_code().wf(v@),
        spec_code().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_code().spec_serialize(v@).len(),
{
    let combinator = code();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct CodeCont0;
type CodeCont0Type<'a, 'b> = &'b u64;
type CodeCont0SType<'a, 'x> = &'x u64;
type CodeCont0Input<'a, 'b, 'x> = POrSType<CodeCont0Type<'a, 'b>, CodeCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<CodeCont0Input<'a, 'b, 'x>> for CodeCont0 {
    type Output = AndThen<bytes::Variable, FuncCombinator>;

    open spec fn requires(&self, deps: CodeCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: CodeCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_code_cont0(deps@)
    }

    fn apply(&self, deps: CodeCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), func())
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), func())
            }
        }
    }
}
                

pub struct SpecFuncidxs {
    pub l: u64,
    pub v: Seq<SpecFuncidx>,
}

pub type SpecFuncidxsInner = (u64, Seq<SpecFuncidx>);


impl SpecFrom<SpecFuncidxs> for SpecFuncidxsInner {
    open spec fn spec_from(m: SpecFuncidxs) -> SpecFuncidxsInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecFuncidxsInner> for SpecFuncidxs {
    open spec fn spec_from(m: SpecFuncidxsInner) -> SpecFuncidxs {
        let (l, v) = m;
        SpecFuncidxs { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Funcidxs {
    pub l: u64,
    pub v: RepeatResult<Funcidx>,
}

impl View for Funcidxs {
    type V = SpecFuncidxs;

    open spec fn view(&self) -> Self::V {
        SpecFuncidxs {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type FuncidxsInner = (u64, RepeatResult<Funcidx>);

pub type FuncidxsInnerRef<'a> = (&'a u64, &'a RepeatResult<Funcidx>);
impl<'a> From<&'a Funcidxs> for FuncidxsInnerRef<'a> {
    fn ex_from(m: &'a Funcidxs) -> FuncidxsInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl From<FuncidxsInner> for Funcidxs {
    fn ex_from(m: FuncidxsInner) -> Funcidxs {
        let (l, v) = m;
        Funcidxs { l, v }
    }
}

pub struct FuncidxsMapper;
impl View for FuncidxsMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for FuncidxsMapper {
    type Src = SpecFuncidxsInner;
    type Dst = SpecFuncidxs;
}
impl SpecIsoProof for FuncidxsMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for FuncidxsMapper {
    type Src = FuncidxsInner;
    type Dst = Funcidxs;
    type RefSrc = FuncidxsInnerRef<'a>;
}

pub struct SpecFuncidxsCombinator(pub SpecFuncidxsCombinatorAlias);

impl SpecCombinator for SpecFuncidxsCombinator {
    type Type = SpecFuncidxs;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecFuncidxsCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecFuncidxsCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecFuncidxsCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecFuncidxCombinator>>, FuncidxsMapper>;

pub struct FuncidxsCombinator(pub FuncidxsCombinatorAlias);

impl View for FuncidxsCombinator {
    type V = SpecFuncidxsCombinator;
    open spec fn view(&self) -> Self::V { SpecFuncidxsCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for FuncidxsCombinator {
    type Type = Funcidxs;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type FuncidxsCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<FuncidxCombinator>, FuncidxsCont0>, FuncidxsMapper>;


pub open spec fn spec_funcidxs() -> SpecFuncidxsCombinator {
    SpecFuncidxsCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_funcidxs_cont0(deps)),
        mapper: FuncidxsMapper,
    })
}

pub open spec fn spec_funcidxs_cont0(deps: u64) -> RepeatN<SpecFuncidxCombinator> {
    let l = deps;
    RepeatN(spec_funcidx(), l.spec_into())
}

impl View for FuncidxsCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecFuncidxCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_funcidxs_cont0(deps)
        }
    }
}

                
pub fn funcidxs<'a>() -> (o: FuncidxsCombinator)
    ensures o@ == spec_funcidxs(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = FuncidxsCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, FuncidxsCont0),
        mapper: FuncidxsMapper,
    });
    assert({
        &&& combinator@ == spec_funcidxs()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_funcidxs<'a>(input: &'a [u8]) -> (res: PResult<<FuncidxsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_funcidxs().spec_parse(input@) == Some((n as int, v@)),
        spec_funcidxs().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_funcidxs().spec_parse(input@) is None,
        spec_funcidxs().spec_parse(input@) is None ==> res is Err,
{
    let combinator = funcidxs();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_funcidxs<'a>(v: <FuncidxsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_funcidxs().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_funcidxs().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_funcidxs().spec_serialize(v@))
        },
{
    let combinator = funcidxs();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn funcidxs_len<'a>(v: <FuncidxsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_funcidxs().wf(v@),
        spec_funcidxs().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_funcidxs().spec_serialize(v@).len(),
{
    let combinator = funcidxs();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct FuncidxsCont0;
type FuncidxsCont0Type<'a, 'b> = &'b u64;
type FuncidxsCont0SType<'a, 'x> = &'x u64;
type FuncidxsCont0Input<'a, 'b, 'x> = POrSType<FuncidxsCont0Type<'a, 'b>, FuncidxsCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<FuncidxsCont0Input<'a, 'b, 'x>> for FuncidxsCont0 {
    type Output = RepeatN<FuncidxCombinator>;

    open spec fn requires(&self, deps: FuncidxsCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: FuncidxsCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_funcidxs_cont0(deps@)
    }

    fn apply(&self, deps: FuncidxsCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(funcidx(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(funcidx(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecParsedElem0 {
    pub e: SpecExpr,
    pub init: SpecFuncidxs,
}

pub type SpecParsedElem0Inner = (SpecExpr, SpecFuncidxs);


impl SpecFrom<SpecParsedElem0> for SpecParsedElem0Inner {
    open spec fn spec_from(m: SpecParsedElem0) -> SpecParsedElem0Inner {
        (m.e, m.init)
    }
}

impl SpecFrom<SpecParsedElem0Inner> for SpecParsedElem0 {
    open spec fn spec_from(m: SpecParsedElem0Inner) -> SpecParsedElem0 {
        let (e, init) = m;
        SpecParsedElem0 { e, init }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ParsedElem0<'a> {
    pub e: Expr<'a>,
    pub init: Funcidxs,
}

impl View for ParsedElem0<'_> {
    type V = SpecParsedElem0;

    open spec fn view(&self) -> Self::V {
        SpecParsedElem0 {
            e: self.e@,
            init: self.init@,
        }
    }
}
pub type ParsedElem0Inner<'a> = (Expr<'a>, Funcidxs);

pub type ParsedElem0InnerRef<'a> = (&'a Expr<'a>, &'a Funcidxs);
impl<'a> From<&'a ParsedElem0<'a>> for ParsedElem0InnerRef<'a> {
    fn ex_from(m: &'a ParsedElem0) -> ParsedElem0InnerRef<'a> {
        (&m.e, &m.init)
    }
}

impl<'a> From<ParsedElem0Inner<'a>> for ParsedElem0<'a> {
    fn ex_from(m: ParsedElem0Inner) -> ParsedElem0 {
        let (e, init) = m;
        ParsedElem0 { e, init }
    }
}

pub struct ParsedElem0Mapper;
impl View for ParsedElem0Mapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ParsedElem0Mapper {
    type Src = SpecParsedElem0Inner;
    type Dst = SpecParsedElem0;
}
impl SpecIsoProof for ParsedElem0Mapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ParsedElem0Mapper {
    type Src = ParsedElem0Inner<'a>;
    type Dst = ParsedElem0<'a>;
    type RefSrc = ParsedElem0InnerRef<'a>;
}
type SpecParsedElem0CombinatorAlias1 = (SpecExprCombinator, SpecFuncidxsCombinator);
pub struct SpecParsedElem0Combinator(pub SpecParsedElem0CombinatorAlias);

impl SpecCombinator for SpecParsedElem0Combinator {
    type Type = SpecParsedElem0;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecParsedElem0Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecParsedElem0CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecParsedElem0CombinatorAlias = Mapped<SpecParsedElem0CombinatorAlias1, ParsedElem0Mapper>;
type ParsedElem0CombinatorAlias1 = (ExprCombinator, FuncidxsCombinator);
pub struct ParsedElem0Combinator1(pub ParsedElem0CombinatorAlias1);
impl View for ParsedElem0Combinator1 {
    type V = SpecParsedElem0CombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ParsedElem0Combinator1, ParsedElem0CombinatorAlias1);

pub struct ParsedElem0Combinator(pub ParsedElem0CombinatorAlias);

impl View for ParsedElem0Combinator {
    type V = SpecParsedElem0Combinator;
    open spec fn view(&self) -> Self::V { SpecParsedElem0Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ParsedElem0Combinator {
    type Type = ParsedElem0<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ParsedElem0CombinatorAlias = Mapped<ParsedElem0Combinator1, ParsedElem0Mapper>;


pub open spec fn spec_parsed_elem0() -> SpecParsedElem0Combinator {
    SpecParsedElem0Combinator(
    Mapped {
        inner: (spec_expr(), spec_funcidxs()),
        mapper: ParsedElem0Mapper,
    })
}

                
pub fn parsed_elem0<'a>() -> (o: ParsedElem0Combinator)
    ensures o@ == spec_parsed_elem0(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ParsedElem0Combinator(
    Mapped {
        inner: ParsedElem0Combinator1((expr(), funcidxs())),
        mapper: ParsedElem0Mapper,
    });
    assert({
        &&& combinator@ == spec_parsed_elem0()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_parsed_elem0<'a>(input: &'a [u8]) -> (res: PResult<<ParsedElem0Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_parsed_elem0().spec_parse(input@) == Some((n as int, v@)),
        spec_parsed_elem0().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_parsed_elem0().spec_parse(input@) is None,
        spec_parsed_elem0().spec_parse(input@) is None ==> res is Err,
{
    let combinator = parsed_elem0();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_parsed_elem0<'a>(v: <ParsedElem0Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_parsed_elem0().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_parsed_elem0().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_parsed_elem0().spec_serialize(v@))
        },
{
    let combinator = parsed_elem0();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn parsed_elem0_len<'a>(v: <ParsedElem0Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_parsed_elem0().wf(v@),
        spec_parsed_elem0().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_parsed_elem0().spec_serialize(v@).len(),
{
    let combinator = parsed_elem0();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecMemidx = u64;
pub type Memidx = u64;
pub type MemidxRef<'a> = &'a u64;


pub struct SpecMemidxCombinator(pub SpecMemidxCombinatorAlias);

impl SpecCombinator for SpecMemidxCombinator {
    type Type = SpecMemidx;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecMemidxCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecMemidxCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecMemidxCombinatorAlias = UnsignedLEB128;

pub struct MemidxCombinator(pub MemidxCombinatorAlias);

impl View for MemidxCombinator {
    type V = SpecMemidxCombinator;
    open spec fn view(&self) -> Self::V { SpecMemidxCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for MemidxCombinator {
    type Type = Memidx;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type MemidxCombinatorAlias = UnsignedLEB128;


pub open spec fn spec_memidx() -> SpecMemidxCombinator {
    SpecMemidxCombinator(UnsignedLEB128)
}

                
pub fn memidx<'a>() -> (o: MemidxCombinator)
    ensures o@ == spec_memidx(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = MemidxCombinator(UnsignedLEB128);
    assert({
        &&& combinator@ == spec_memidx()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_memidx<'a>(input: &'a [u8]) -> (res: PResult<<MemidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_memidx().spec_parse(input@) == Some((n as int, v@)),
        spec_memidx().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_memidx().spec_parse(input@) is None,
        spec_memidx().spec_parse(input@) is None ==> res is Err,
{
    let combinator = memidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_memidx<'a>(v: <MemidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_memidx().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_memidx().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_memidx().spec_serialize(v@))
        },
{
    let combinator = memidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn memidx_len<'a>(v: <MemidxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_memidx().wf(v@),
        spec_memidx().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_memidx().spec_serialize(v@).len(),
{
    let combinator = memidx();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub enum SpecExportdesc {
    Func(SpecFuncidx),
    Table(SpecTableidx),
    Mem(SpecMemidx),
    Global(SpecGlobalidx),
}

pub type SpecExportdescInner = Either<SpecFuncidx, Either<SpecTableidx, Either<SpecMemidx, SpecGlobalidx>>>;

impl SpecFrom<SpecExportdesc> for SpecExportdescInner {
    open spec fn spec_from(m: SpecExportdesc) -> SpecExportdescInner {
        match m {
            SpecExportdesc::Func(m) => Either::Left(m),
            SpecExportdesc::Table(m) => Either::Right(Either::Left(m)),
            SpecExportdesc::Mem(m) => Either::Right(Either::Right(Either::Left(m))),
            SpecExportdesc::Global(m) => Either::Right(Either::Right(Either::Right(m))),
        }
    }

}

                
impl SpecFrom<SpecExportdescInner> for SpecExportdesc {
    open spec fn spec_from(m: SpecExportdescInner) -> SpecExportdesc {
        match m {
            Either::Left(m) => SpecExportdesc::Func(m),
            Either::Right(Either::Left(m)) => SpecExportdesc::Table(m),
            Either::Right(Either::Right(Either::Left(m))) => SpecExportdesc::Mem(m),
            Either::Right(Either::Right(Either::Right(m))) => SpecExportdesc::Global(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Exportdesc {
    Func(Funcidx),
    Table(Tableidx),
    Mem(Memidx),
    Global(Globalidx),
}

pub type ExportdescInner = Either<Funcidx, Either<Tableidx, Either<Memidx, Globalidx>>>;

pub type ExportdescInnerRef<'a> = Either<&'a Funcidx, Either<&'a Tableidx, Either<&'a Memidx, &'a Globalidx>>>;


impl View for Exportdesc {
    type V = SpecExportdesc;
    open spec fn view(&self) -> Self::V {
        match self {
            Exportdesc::Func(m) => SpecExportdesc::Func(m@),
            Exportdesc::Table(m) => SpecExportdesc::Table(m@),
            Exportdesc::Mem(m) => SpecExportdesc::Mem(m@),
            Exportdesc::Global(m) => SpecExportdesc::Global(m@),
        }
    }
}


impl<'a> From<&'a Exportdesc> for ExportdescInnerRef<'a> {
    fn ex_from(m: &'a Exportdesc) -> ExportdescInnerRef<'a> {
        match m {
            Exportdesc::Func(m) => Either::Left(m),
            Exportdesc::Table(m) => Either::Right(Either::Left(m)),
            Exportdesc::Mem(m) => Either::Right(Either::Right(Either::Left(m))),
            Exportdesc::Global(m) => Either::Right(Either::Right(Either::Right(m))),
        }
    }

}

impl From<ExportdescInner> for Exportdesc {
    fn ex_from(m: ExportdescInner) -> Exportdesc {
        match m {
            Either::Left(m) => Exportdesc::Func(m),
            Either::Right(Either::Left(m)) => Exportdesc::Table(m),
            Either::Right(Either::Right(Either::Left(m))) => Exportdesc::Mem(m),
            Either::Right(Either::Right(Either::Right(m))) => Exportdesc::Global(m),
        }
    }
    
}


pub struct ExportdescMapper;
impl View for ExportdescMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ExportdescMapper {
    type Src = SpecExportdescInner;
    type Dst = SpecExportdesc;
}
impl SpecIsoProof for ExportdescMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ExportdescMapper {
    type Src = ExportdescInner;
    type Dst = Exportdesc;
    type RefSrc = ExportdescInnerRef<'a>;
}

pub const EXPORTDESCFUNC_0_FRONT_CONST: u8 = 0;

pub const EXPORTDESCTABLE_0_FRONT_CONST: u8 = 1;

pub const EXPORTDESCMEM_0_FRONT_CONST: u8 = 2;

pub const EXPORTDESCGLOBAL_0_FRONT_CONST: u8 = 3;

type SpecExportdescCombinatorAlias1 = Choice<Preceded<Tag<U8, u8>, SpecMemidxCombinator>, Preceded<Tag<U8, u8>, SpecGlobalidxCombinator>>;
type SpecExportdescCombinatorAlias2 = Choice<Preceded<Tag<U8, u8>, SpecTableidxCombinator>, SpecExportdescCombinatorAlias1>;
type SpecExportdescCombinatorAlias3 = Choice<Preceded<Tag<U8, u8>, SpecFuncidxCombinator>, SpecExportdescCombinatorAlias2>;
pub struct SpecExportdescCombinator(pub SpecExportdescCombinatorAlias);

impl SpecCombinator for SpecExportdescCombinator {
    type Type = SpecExportdesc;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecExportdescCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecExportdescCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecExportdescCombinatorAlias = Mapped<SpecExportdescCombinatorAlias3, ExportdescMapper>;




type ExportdescCombinatorAlias1 = Choice<Preceded<Tag<U8, u8>, MemidxCombinator>, Preceded<Tag<U8, u8>, GlobalidxCombinator>>;
type ExportdescCombinatorAlias2 = Choice<Preceded<Tag<U8, u8>, TableidxCombinator>, ExportdescCombinator1>;
type ExportdescCombinatorAlias3 = Choice<Preceded<Tag<U8, u8>, FuncidxCombinator>, ExportdescCombinator2>;
pub struct ExportdescCombinator1(pub ExportdescCombinatorAlias1);
impl View for ExportdescCombinator1 {
    type V = SpecExportdescCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ExportdescCombinator1, ExportdescCombinatorAlias1);

pub struct ExportdescCombinator2(pub ExportdescCombinatorAlias2);
impl View for ExportdescCombinator2 {
    type V = SpecExportdescCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ExportdescCombinator2, ExportdescCombinatorAlias2);

pub struct ExportdescCombinator3(pub ExportdescCombinatorAlias3);
impl View for ExportdescCombinator3 {
    type V = SpecExportdescCombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ExportdescCombinator3, ExportdescCombinatorAlias3);

pub struct ExportdescCombinator(pub ExportdescCombinatorAlias);

impl View for ExportdescCombinator {
    type V = SpecExportdescCombinator;
    open spec fn view(&self) -> Self::V { SpecExportdescCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ExportdescCombinator {
    type Type = Exportdesc;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ExportdescCombinatorAlias = Mapped<ExportdescCombinator3, ExportdescMapper>;


pub open spec fn spec_exportdesc() -> SpecExportdescCombinator {
    SpecExportdescCombinator(Mapped { inner: Choice(Preceded(Tag::spec_new(U8, EXPORTDESCFUNC_0_FRONT_CONST), spec_funcidx()), Choice(Preceded(Tag::spec_new(U8, EXPORTDESCTABLE_0_FRONT_CONST), spec_tableidx()), Choice(Preceded(Tag::spec_new(U8, EXPORTDESCMEM_0_FRONT_CONST), spec_memidx()), Preceded(Tag::spec_new(U8, EXPORTDESCGLOBAL_0_FRONT_CONST), spec_globalidx())))), mapper: ExportdescMapper })
}

                
pub fn exportdesc<'a>() -> (o: ExportdescCombinator)
    ensures o@ == spec_exportdesc(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ExportdescCombinator(Mapped { inner: ExportdescCombinator3(Choice::new(Preceded(Tag::new(U8, EXPORTDESCFUNC_0_FRONT_CONST), funcidx()), ExportdescCombinator2(Choice::new(Preceded(Tag::new(U8, EXPORTDESCTABLE_0_FRONT_CONST), tableidx()), ExportdescCombinator1(Choice::new(Preceded(Tag::new(U8, EXPORTDESCMEM_0_FRONT_CONST), memidx()), Preceded(Tag::new(U8, EXPORTDESCGLOBAL_0_FRONT_CONST), globalidx()))))))), mapper: ExportdescMapper });
    assert({
        &&& combinator@ == spec_exportdesc()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_exportdesc<'a>(input: &'a [u8]) -> (res: PResult<<ExportdescCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_exportdesc().spec_parse(input@) == Some((n as int, v@)),
        spec_exportdesc().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_exportdesc().spec_parse(input@) is None,
        spec_exportdesc().spec_parse(input@) is None ==> res is Err,
{
    let combinator = exportdesc();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_exportdesc<'a>(v: <ExportdescCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_exportdesc().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_exportdesc().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_exportdesc().spec_serialize(v@))
        },
{
    let combinator = exportdesc();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn exportdesc_len<'a>(v: <ExportdescCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_exportdesc().wf(v@),
        spec_exportdesc().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_exportdesc().spec_serialize(v@).len(),
{
    let combinator = exportdesc();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecExport {
    pub nm: SpecName,
    pub d: SpecExportdesc,
}

pub type SpecExportInner = (SpecName, SpecExportdesc);


impl SpecFrom<SpecExport> for SpecExportInner {
    open spec fn spec_from(m: SpecExport) -> SpecExportInner {
        (m.nm, m.d)
    }
}

impl SpecFrom<SpecExportInner> for SpecExport {
    open spec fn spec_from(m: SpecExportInner) -> SpecExport {
        let (nm, d) = m;
        SpecExport { nm, d }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Export {
    pub nm: Name,
    pub d: Exportdesc,
}

impl View for Export {
    type V = SpecExport;

    open spec fn view(&self) -> Self::V {
        SpecExport {
            nm: self.nm@,
            d: self.d@,
        }
    }
}
pub type ExportInner = (Name, Exportdesc);

pub type ExportInnerRef<'a> = (&'a Name, &'a Exportdesc);
impl<'a> From<&'a Export> for ExportInnerRef<'a> {
    fn ex_from(m: &'a Export) -> ExportInnerRef<'a> {
        (&m.nm, &m.d)
    }
}

impl From<ExportInner> for Export {
    fn ex_from(m: ExportInner) -> Export {
        let (nm, d) = m;
        Export { nm, d }
    }
}

pub struct ExportMapper;
impl View for ExportMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ExportMapper {
    type Src = SpecExportInner;
    type Dst = SpecExport;
}
impl SpecIsoProof for ExportMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ExportMapper {
    type Src = ExportInner;
    type Dst = Export;
    type RefSrc = ExportInnerRef<'a>;
}
type SpecExportCombinatorAlias1 = (SpecNameCombinator, SpecExportdescCombinator);
pub struct SpecExportCombinator(pub SpecExportCombinatorAlias);

impl SpecCombinator for SpecExportCombinator {
    type Type = SpecExport;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecExportCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecExportCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecExportCombinatorAlias = Mapped<SpecExportCombinatorAlias1, ExportMapper>;
type ExportCombinatorAlias1 = (NameCombinator, ExportdescCombinator);
pub struct ExportCombinator1(pub ExportCombinatorAlias1);
impl View for ExportCombinator1 {
    type V = SpecExportCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ExportCombinator1, ExportCombinatorAlias1);

pub struct ExportCombinator(pub ExportCombinatorAlias);

impl View for ExportCombinator {
    type V = SpecExportCombinator;
    open spec fn view(&self) -> Self::V { SpecExportCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ExportCombinator {
    type Type = Export;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ExportCombinatorAlias = Mapped<ExportCombinator1, ExportMapper>;


pub open spec fn spec_export() -> SpecExportCombinator {
    SpecExportCombinator(
    Mapped {
        inner: (spec_name(), spec_exportdesc()),
        mapper: ExportMapper,
    })
}

                
pub fn export<'a>() -> (o: ExportCombinator)
    ensures o@ == spec_export(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ExportCombinator(
    Mapped {
        inner: ExportCombinator1((name(), exportdesc())),
        mapper: ExportMapper,
    });
    assert({
        &&& combinator@ == spec_export()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_export<'a>(input: &'a [u8]) -> (res: PResult<<ExportCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_export().spec_parse(input@) == Some((n as int, v@)),
        spec_export().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_export().spec_parse(input@) is None,
        spec_export().spec_parse(input@) is None ==> res is Err,
{
    let combinator = export();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_export<'a>(v: <ExportCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_export().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_export().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_export().spec_serialize(v@))
        },
{
    let combinator = export();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn export_len<'a>(v: <ExportCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_export().wf(v@),
        spec_export().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_export().spec_serialize(v@).len(),
{
    let combinator = export();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecSigned32 = Seq<u8>;
pub type Signed32<'a> = &'a [u8];
pub type Signed32Ref<'a> = &'a &'a [u8];


pub struct SpecSigned32Combinator(pub SpecSigned32CombinatorAlias);

impl SpecCombinator for SpecSigned32Combinator {
    type Type = SpecSigned32;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecSigned32Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecSigned32CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecSigned32CombinatorAlias = bytes::Fixed<4>;

pub struct Signed32Combinator(pub Signed32CombinatorAlias);

impl View for Signed32Combinator {
    type V = SpecSigned32Combinator;
    open spec fn view(&self) -> Self::V { SpecSigned32Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for Signed32Combinator {
    type Type = Signed32<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type Signed32CombinatorAlias = bytes::Fixed<4>;


pub open spec fn spec_signed_32() -> SpecSigned32Combinator {
    SpecSigned32Combinator(bytes::Fixed::<4>)
}

                
pub fn signed_32<'a>() -> (o: Signed32Combinator)
    ensures o@ == spec_signed_32(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = Signed32Combinator(bytes::Fixed::<4>);
    assert({
        &&& combinator@ == spec_signed_32()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_signed_32<'a>(input: &'a [u8]) -> (res: PResult<<Signed32Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_signed_32().spec_parse(input@) == Some((n as int, v@)),
        spec_signed_32().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_signed_32().spec_parse(input@) is None,
        spec_signed_32().spec_parse(input@) is None ==> res is Err,
{
    let combinator = signed_32();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_signed_32<'a>(v: <Signed32Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_signed_32().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_signed_32().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_signed_32().spec_serialize(v@))
        },
{
    let combinator = signed_32();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn signed_32_len<'a>(v: <Signed32Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_signed_32().wf(v@),
        spec_signed_32().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_signed_32().spec_serialize(v@).len(),
{
    let combinator = signed_32();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecExprs {
    pub l: u64,
    pub v: Seq<SpecExpr>,
}

pub type SpecExprsInner = (u64, Seq<SpecExpr>);


impl SpecFrom<SpecExprs> for SpecExprsInner {
    open spec fn spec_from(m: SpecExprs) -> SpecExprsInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecExprsInner> for SpecExprs {
    open spec fn spec_from(m: SpecExprsInner) -> SpecExprs {
        let (l, v) = m;
        SpecExprs { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Exprs<'a> {
    pub l: u64,
    pub v: RepeatResult<Expr<'a>>,
}

impl View for Exprs<'_> {
    type V = SpecExprs;

    open spec fn view(&self) -> Self::V {
        SpecExprs {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type ExprsInner<'a> = (u64, RepeatResult<Expr<'a>>);

pub type ExprsInnerRef<'a> = (&'a u64, &'a RepeatResult<Expr<'a>>);
impl<'a> From<&'a Exprs<'a>> for ExprsInnerRef<'a> {
    fn ex_from(m: &'a Exprs) -> ExprsInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl<'a> From<ExprsInner<'a>> for Exprs<'a> {
    fn ex_from(m: ExprsInner) -> Exprs {
        let (l, v) = m;
        Exprs { l, v }
    }
}

pub struct ExprsMapper;
impl View for ExprsMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ExprsMapper {
    type Src = SpecExprsInner;
    type Dst = SpecExprs;
}
impl SpecIsoProof for ExprsMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ExprsMapper {
    type Src = ExprsInner<'a>;
    type Dst = Exprs<'a>;
    type RefSrc = ExprsInnerRef<'a>;
}

pub struct SpecExprsCombinator(pub SpecExprsCombinatorAlias);

impl SpecCombinator for SpecExprsCombinator {
    type Type = SpecExprs;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecExprsCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecExprsCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecExprsCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecExprCombinator>>, ExprsMapper>;

pub struct ExprsCombinator(pub ExprsCombinatorAlias);

impl View for ExprsCombinator {
    type V = SpecExprsCombinator;
    open spec fn view(&self) -> Self::V { SpecExprsCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ExprsCombinator {
    type Type = Exprs<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ExprsCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<ExprCombinator>, ExprsCont0>, ExprsMapper>;


pub open spec fn spec_exprs() -> SpecExprsCombinator {
    SpecExprsCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_exprs_cont0(deps)),
        mapper: ExprsMapper,
    })
}

pub open spec fn spec_exprs_cont0(deps: u64) -> RepeatN<SpecExprCombinator> {
    let l = deps;
    RepeatN(spec_expr(), l.spec_into())
}

impl View for ExprsCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecExprCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_exprs_cont0(deps)
        }
    }
}

                
pub fn exprs<'a>() -> (o: ExprsCombinator)
    ensures o@ == spec_exprs(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ExprsCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, ExprsCont0),
        mapper: ExprsMapper,
    });
    assert({
        &&& combinator@ == spec_exprs()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_exprs<'a>(input: &'a [u8]) -> (res: PResult<<ExprsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_exprs().spec_parse(input@) == Some((n as int, v@)),
        spec_exprs().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_exprs().spec_parse(input@) is None,
        spec_exprs().spec_parse(input@) is None ==> res is Err,
{
    let combinator = exprs();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_exprs<'a>(v: <ExprsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_exprs().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_exprs().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_exprs().spec_serialize(v@))
        },
{
    let combinator = exprs();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn exprs_len<'a>(v: <ExprsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_exprs().wf(v@),
        spec_exprs().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_exprs().spec_serialize(v@).len(),
{
    let combinator = exprs();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct ExprsCont0;
type ExprsCont0Type<'a, 'b> = &'b u64;
type ExprsCont0SType<'a, 'x> = &'x u64;
type ExprsCont0Input<'a, 'b, 'x> = POrSType<ExprsCont0Type<'a, 'b>, ExprsCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<ExprsCont0Input<'a, 'b, 'x>> for ExprsCont0 {
    type Output = RepeatN<ExprCombinator>;

    open spec fn requires(&self, deps: ExprsCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: ExprsCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_exprs_cont0(deps@)
    }

    fn apply(&self, deps: ExprsCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(expr(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(expr(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecParsedElem7 {
    pub et: SpecReftype,
    pub init: SpecExprs,
}

pub type SpecParsedElem7Inner = (SpecReftype, SpecExprs);


impl SpecFrom<SpecParsedElem7> for SpecParsedElem7Inner {
    open spec fn spec_from(m: SpecParsedElem7) -> SpecParsedElem7Inner {
        (m.et, m.init)
    }
}

impl SpecFrom<SpecParsedElem7Inner> for SpecParsedElem7 {
    open spec fn spec_from(m: SpecParsedElem7Inner) -> SpecParsedElem7 {
        let (et, init) = m;
        SpecParsedElem7 { et, init }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ParsedElem7<'a> {
    pub et: Reftype,
    pub init: Exprs<'a>,
}

impl View for ParsedElem7<'_> {
    type V = SpecParsedElem7;

    open spec fn view(&self) -> Self::V {
        SpecParsedElem7 {
            et: self.et@,
            init: self.init@,
        }
    }
}
pub type ParsedElem7Inner<'a> = (Reftype, Exprs<'a>);

pub type ParsedElem7InnerRef<'a> = (&'a Reftype, &'a Exprs<'a>);
impl<'a> From<&'a ParsedElem7<'a>> for ParsedElem7InnerRef<'a> {
    fn ex_from(m: &'a ParsedElem7) -> ParsedElem7InnerRef<'a> {
        (&m.et, &m.init)
    }
}

impl<'a> From<ParsedElem7Inner<'a>> for ParsedElem7<'a> {
    fn ex_from(m: ParsedElem7Inner) -> ParsedElem7 {
        let (et, init) = m;
        ParsedElem7 { et, init }
    }
}

pub struct ParsedElem7Mapper;
impl View for ParsedElem7Mapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ParsedElem7Mapper {
    type Src = SpecParsedElem7Inner;
    type Dst = SpecParsedElem7;
}
impl SpecIsoProof for ParsedElem7Mapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ParsedElem7Mapper {
    type Src = ParsedElem7Inner<'a>;
    type Dst = ParsedElem7<'a>;
    type RefSrc = ParsedElem7InnerRef<'a>;
}
type SpecParsedElem7CombinatorAlias1 = (SpecReftypeCombinator, SpecExprsCombinator);
pub struct SpecParsedElem7Combinator(pub SpecParsedElem7CombinatorAlias);

impl SpecCombinator for SpecParsedElem7Combinator {
    type Type = SpecParsedElem7;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecParsedElem7Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecParsedElem7CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecParsedElem7CombinatorAlias = Mapped<SpecParsedElem7CombinatorAlias1, ParsedElem7Mapper>;
type ParsedElem7CombinatorAlias1 = (ReftypeCombinator, ExprsCombinator);
pub struct ParsedElem7Combinator1(pub ParsedElem7CombinatorAlias1);
impl View for ParsedElem7Combinator1 {
    type V = SpecParsedElem7CombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ParsedElem7Combinator1, ParsedElem7CombinatorAlias1);

pub struct ParsedElem7Combinator(pub ParsedElem7CombinatorAlias);

impl View for ParsedElem7Combinator {
    type V = SpecParsedElem7Combinator;
    open spec fn view(&self) -> Self::V { SpecParsedElem7Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ParsedElem7Combinator {
    type Type = ParsedElem7<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ParsedElem7CombinatorAlias = Mapped<ParsedElem7Combinator1, ParsedElem7Mapper>;


pub open spec fn spec_parsed_elem7() -> SpecParsedElem7Combinator {
    SpecParsedElem7Combinator(
    Mapped {
        inner: (spec_reftype(), spec_exprs()),
        mapper: ParsedElem7Mapper,
    })
}

                
pub fn parsed_elem7<'a>() -> (o: ParsedElem7Combinator)
    ensures o@ == spec_parsed_elem7(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ParsedElem7Combinator(
    Mapped {
        inner: ParsedElem7Combinator1((reftype(), exprs())),
        mapper: ParsedElem7Mapper,
    });
    assert({
        &&& combinator@ == spec_parsed_elem7()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_parsed_elem7<'a>(input: &'a [u8]) -> (res: PResult<<ParsedElem7Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_parsed_elem7().spec_parse(input@) == Some((n as int, v@)),
        spec_parsed_elem7().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_parsed_elem7().spec_parse(input@) is None,
        spec_parsed_elem7().spec_parse(input@) is None ==> res is Err,
{
    let combinator = parsed_elem7();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_parsed_elem7<'a>(v: <ParsedElem7Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_parsed_elem7().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_parsed_elem7().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_parsed_elem7().spec_serialize(v@))
        },
{
    let combinator = parsed_elem7();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn parsed_elem7_len<'a>(v: <ParsedElem7Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_parsed_elem7().wf(v@),
        spec_parsed_elem7().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_parsed_elem7().spec_serialize(v@).len(),
{
    let combinator = parsed_elem7();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecExports {
    pub l: u64,
    pub v: Seq<SpecExport>,
}

pub type SpecExportsInner = (u64, Seq<SpecExport>);


impl SpecFrom<SpecExports> for SpecExportsInner {
    open spec fn spec_from(m: SpecExports) -> SpecExportsInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecExportsInner> for SpecExports {
    open spec fn spec_from(m: SpecExportsInner) -> SpecExports {
        let (l, v) = m;
        SpecExports { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Exports {
    pub l: u64,
    pub v: RepeatResult<Export>,
}

impl View for Exports {
    type V = SpecExports;

    open spec fn view(&self) -> Self::V {
        SpecExports {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type ExportsInner = (u64, RepeatResult<Export>);

pub type ExportsInnerRef<'a> = (&'a u64, &'a RepeatResult<Export>);
impl<'a> From<&'a Exports> for ExportsInnerRef<'a> {
    fn ex_from(m: &'a Exports) -> ExportsInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl From<ExportsInner> for Exports {
    fn ex_from(m: ExportsInner) -> Exports {
        let (l, v) = m;
        Exports { l, v }
    }
}

pub struct ExportsMapper;
impl View for ExportsMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ExportsMapper {
    type Src = SpecExportsInner;
    type Dst = SpecExports;
}
impl SpecIsoProof for ExportsMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ExportsMapper {
    type Src = ExportsInner;
    type Dst = Exports;
    type RefSrc = ExportsInnerRef<'a>;
}

pub struct SpecExportsCombinator(pub SpecExportsCombinatorAlias);

impl SpecCombinator for SpecExportsCombinator {
    type Type = SpecExports;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecExportsCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecExportsCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecExportsCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecExportCombinator>>, ExportsMapper>;

pub struct ExportsCombinator(pub ExportsCombinatorAlias);

impl View for ExportsCombinator {
    type V = SpecExportsCombinator;
    open spec fn view(&self) -> Self::V { SpecExportsCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ExportsCombinator {
    type Type = Exports;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ExportsCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<ExportCombinator>, ExportsCont0>, ExportsMapper>;


pub open spec fn spec_exports() -> SpecExportsCombinator {
    SpecExportsCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_exports_cont0(deps)),
        mapper: ExportsMapper,
    })
}

pub open spec fn spec_exports_cont0(deps: u64) -> RepeatN<SpecExportCombinator> {
    let l = deps;
    RepeatN(spec_export(), l.spec_into())
}

impl View for ExportsCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecExportCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_exports_cont0(deps)
        }
    }
}

                
pub fn exports<'a>() -> (o: ExportsCombinator)
    ensures o@ == spec_exports(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ExportsCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, ExportsCont0),
        mapper: ExportsMapper,
    });
    assert({
        &&& combinator@ == spec_exports()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_exports<'a>(input: &'a [u8]) -> (res: PResult<<ExportsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_exports().spec_parse(input@) == Some((n as int, v@)),
        spec_exports().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_exports().spec_parse(input@) is None,
        spec_exports().spec_parse(input@) is None ==> res is Err,
{
    let combinator = exports();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_exports<'a>(v: <ExportsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_exports().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_exports().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_exports().spec_serialize(v@))
        },
{
    let combinator = exports();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn exports_len<'a>(v: <ExportsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_exports().wf(v@),
        spec_exports().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_exports().spec_serialize(v@).len(),
{
    let combinator = exports();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct ExportsCont0;
type ExportsCont0Type<'a, 'b> = &'b u64;
type ExportsCont0SType<'a, 'x> = &'x u64;
type ExportsCont0Input<'a, 'b, 'x> = POrSType<ExportsCont0Type<'a, 'b>, ExportsCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<ExportsCont0Input<'a, 'b, 'x>> for ExportsCont0 {
    type Output = RepeatN<ExportCombinator>;

    open spec fn requires(&self, deps: ExportsCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: ExportsCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_exports_cont0(deps@)
    }

    fn apply(&self, deps: ExportsCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(export(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(export(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecExportsec {
    pub size: u64,
    pub cont: SpecExports,
}

pub type SpecExportsecInner = (u64, SpecExports);


impl SpecFrom<SpecExportsec> for SpecExportsecInner {
    open spec fn spec_from(m: SpecExportsec) -> SpecExportsecInner {
        (m.size, m.cont)
    }
}

impl SpecFrom<SpecExportsecInner> for SpecExportsec {
    open spec fn spec_from(m: SpecExportsecInner) -> SpecExportsec {
        let (size, cont) = m;
        SpecExportsec { size, cont }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Exportsec {
    pub size: u64,
    pub cont: Exports,
}

impl View for Exportsec {
    type V = SpecExportsec;

    open spec fn view(&self) -> Self::V {
        SpecExportsec {
            size: self.size@,
            cont: self.cont@,
        }
    }
}
pub type ExportsecInner = (u64, Exports);

pub type ExportsecInnerRef<'a> = (&'a u64, &'a Exports);
impl<'a> From<&'a Exportsec> for ExportsecInnerRef<'a> {
    fn ex_from(m: &'a Exportsec) -> ExportsecInnerRef<'a> {
        (&m.size, &m.cont)
    }
}

impl From<ExportsecInner> for Exportsec {
    fn ex_from(m: ExportsecInner) -> Exportsec {
        let (size, cont) = m;
        Exportsec { size, cont }
    }
}

pub struct ExportsecMapper;
impl View for ExportsecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ExportsecMapper {
    type Src = SpecExportsecInner;
    type Dst = SpecExportsec;
}
impl SpecIsoProof for ExportsecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ExportsecMapper {
    type Src = ExportsecInner;
    type Dst = Exportsec;
    type RefSrc = ExportsecInnerRef<'a>;
}

pub struct SpecExportsecCombinator(pub SpecExportsecCombinatorAlias);

impl SpecCombinator for SpecExportsecCombinator {
    type Type = SpecExportsec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecExportsecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecExportsecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecExportsecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, SpecExportsCombinator>>, ExportsecMapper>;

pub struct ExportsecCombinator(pub ExportsecCombinatorAlias);

impl View for ExportsecCombinator {
    type V = SpecExportsecCombinator;
    open spec fn view(&self) -> Self::V { SpecExportsecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ExportsecCombinator {
    type Type = Exportsec;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ExportsecCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, ExportsCombinator>, ExportsecCont0>, ExportsecMapper>;


pub open spec fn spec_exportsec() -> SpecExportsecCombinator {
    SpecExportsecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_exportsec_cont0(deps)),
        mapper: ExportsecMapper,
    })
}

pub open spec fn spec_exportsec_cont0(deps: u64) -> AndThen<bytes::Variable, SpecExportsCombinator> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), spec_exports())
}

impl View for ExportsecCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, SpecExportsCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_exportsec_cont0(deps)
        }
    }
}

                
pub fn exportsec<'a>() -> (o: ExportsecCombinator)
    ensures o@ == spec_exportsec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ExportsecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, ExportsecCont0),
        mapper: ExportsecMapper,
    });
    assert({
        &&& combinator@ == spec_exportsec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_exportsec<'a>(input: &'a [u8]) -> (res: PResult<<ExportsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_exportsec().spec_parse(input@) == Some((n as int, v@)),
        spec_exportsec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_exportsec().spec_parse(input@) is None,
        spec_exportsec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = exportsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_exportsec<'a>(v: <ExportsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_exportsec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_exportsec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_exportsec().spec_serialize(v@))
        },
{
    let combinator = exportsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn exportsec_len<'a>(v: <ExportsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_exportsec().wf(v@),
        spec_exportsec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_exportsec().spec_serialize(v@).len(),
{
    let combinator = exportsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct ExportsecCont0;
type ExportsecCont0Type<'a, 'b> = &'b u64;
type ExportsecCont0SType<'a, 'x> = &'x u64;
type ExportsecCont0Input<'a, 'b, 'x> = POrSType<ExportsecCont0Type<'a, 'b>, ExportsecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<ExportsecCont0Input<'a, 'b, 'x>> for ExportsecCont0 {
    type Output = AndThen<bytes::Variable, ExportsCombinator>;

    open spec fn requires(&self, deps: ExportsecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: ExportsecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_exportsec_cont0(deps@)
    }

    fn apply(&self, deps: ExportsecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), exports())
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), exports())
            }
        }
    }
}
                
pub type SpecMyCustomSection = SpecByteVec;
pub type MyCustomSection = ByteVec;
pub type MyCustomSectionRef<'a> = &'a ByteVec;


pub struct SpecMyCustomSectionCombinator(pub SpecMyCustomSectionCombinatorAlias);

impl SpecCombinator for SpecMyCustomSectionCombinator {
    type Type = SpecMyCustomSection;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecMyCustomSectionCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecMyCustomSectionCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecMyCustomSectionCombinatorAlias = SpecByteVecCombinator;

pub struct MyCustomSectionCombinator(pub MyCustomSectionCombinatorAlias);

impl View for MyCustomSectionCombinator {
    type V = SpecMyCustomSectionCombinator;
    open spec fn view(&self) -> Self::V { SpecMyCustomSectionCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for MyCustomSectionCombinator {
    type Type = MyCustomSection;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type MyCustomSectionCombinatorAlias = ByteVecCombinator;


pub open spec fn spec_my_custom_section() -> SpecMyCustomSectionCombinator {
    SpecMyCustomSectionCombinator(spec_byte_vec())
}

                
pub fn my_custom_section<'a>() -> (o: MyCustomSectionCombinator)
    ensures o@ == spec_my_custom_section(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = MyCustomSectionCombinator(byte_vec());
    assert({
        &&& combinator@ == spec_my_custom_section()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_my_custom_section<'a>(input: &'a [u8]) -> (res: PResult<<MyCustomSectionCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_my_custom_section().spec_parse(input@) == Some((n as int, v@)),
        spec_my_custom_section().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_my_custom_section().spec_parse(input@) is None,
        spec_my_custom_section().spec_parse(input@) is None ==> res is Err,
{
    let combinator = my_custom_section();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_my_custom_section<'a>(v: <MyCustomSectionCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_my_custom_section().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_my_custom_section().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_my_custom_section().spec_serialize(v@))
        },
{
    let combinator = my_custom_section();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn my_custom_section_len<'a>(v: <MyCustomSectionCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_my_custom_section().wf(v@),
        spec_my_custom_section().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_my_custom_section().spec_serialize(v@).len(),
{
    let combinator = my_custom_section();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecCustom {
    pub name: SpecName,
    pub data: SpecMyCustomSection,
}

pub type SpecCustomInner = (SpecName, SpecMyCustomSection);


impl SpecFrom<SpecCustom> for SpecCustomInner {
    open spec fn spec_from(m: SpecCustom) -> SpecCustomInner {
        (m.name, m.data)
    }
}

impl SpecFrom<SpecCustomInner> for SpecCustom {
    open spec fn spec_from(m: SpecCustomInner) -> SpecCustom {
        let (name, data) = m;
        SpecCustom { name, data }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Custom {
    pub name: Name,
    pub data: MyCustomSection,
}

impl View for Custom {
    type V = SpecCustom;

    open spec fn view(&self) -> Self::V {
        SpecCustom {
            name: self.name@,
            data: self.data@,
        }
    }
}
pub type CustomInner = (Name, MyCustomSection);

pub type CustomInnerRef<'a> = (&'a Name, &'a MyCustomSection);
impl<'a> From<&'a Custom> for CustomInnerRef<'a> {
    fn ex_from(m: &'a Custom) -> CustomInnerRef<'a> {
        (&m.name, &m.data)
    }
}

impl From<CustomInner> for Custom {
    fn ex_from(m: CustomInner) -> Custom {
        let (name, data) = m;
        Custom { name, data }
    }
}

pub struct CustomMapper;
impl View for CustomMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for CustomMapper {
    type Src = SpecCustomInner;
    type Dst = SpecCustom;
}
impl SpecIsoProof for CustomMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for CustomMapper {
    type Src = CustomInner;
    type Dst = Custom;
    type RefSrc = CustomInnerRef<'a>;
}
type SpecCustomCombinatorAlias1 = (SpecNameCombinator, SpecMyCustomSectionCombinator);
pub struct SpecCustomCombinator(pub SpecCustomCombinatorAlias);

impl SpecCombinator for SpecCustomCombinator {
    type Type = SpecCustom;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecCustomCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecCustomCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecCustomCombinatorAlias = Mapped<SpecCustomCombinatorAlias1, CustomMapper>;
type CustomCombinatorAlias1 = (NameCombinator, MyCustomSectionCombinator);
pub struct CustomCombinator1(pub CustomCombinatorAlias1);
impl View for CustomCombinator1 {
    type V = SpecCustomCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(CustomCombinator1, CustomCombinatorAlias1);

pub struct CustomCombinator(pub CustomCombinatorAlias);

impl View for CustomCombinator {
    type V = SpecCustomCombinator;
    open spec fn view(&self) -> Self::V { SpecCustomCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for CustomCombinator {
    type Type = Custom;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type CustomCombinatorAlias = Mapped<CustomCombinator1, CustomMapper>;


pub open spec fn spec_custom() -> SpecCustomCombinator {
    SpecCustomCombinator(
    Mapped {
        inner: (spec_name(), spec_my_custom_section()),
        mapper: CustomMapper,
    })
}

                
pub fn custom<'a>() -> (o: CustomCombinator)
    ensures o@ == spec_custom(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = CustomCombinator(
    Mapped {
        inner: CustomCombinator1((name(), my_custom_section())),
        mapper: CustomMapper,
    });
    assert({
        &&& combinator@ == spec_custom()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_custom<'a>(input: &'a [u8]) -> (res: PResult<<CustomCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_custom().spec_parse(input@) == Some((n as int, v@)),
        spec_custom().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_custom().spec_parse(input@) is None,
        spec_custom().spec_parse(input@) is None ==> res is Err,
{
    let combinator = custom();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_custom<'a>(v: <CustomCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_custom().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_custom().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_custom().spec_serialize(v@))
        },
{
    let combinator = custom();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn custom_len<'a>(v: <CustomCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_custom().wf(v@),
        spec_custom().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_custom().spec_serialize(v@).len(),
{
    let combinator = custom();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecCustomsec {
    pub size: u64,
    pub cont: SpecCustom,
}

pub type SpecCustomsecInner = (u64, SpecCustom);


impl SpecFrom<SpecCustomsec> for SpecCustomsecInner {
    open spec fn spec_from(m: SpecCustomsec) -> SpecCustomsecInner {
        (m.size, m.cont)
    }
}

impl SpecFrom<SpecCustomsecInner> for SpecCustomsec {
    open spec fn spec_from(m: SpecCustomsecInner) -> SpecCustomsec {
        let (size, cont) = m;
        SpecCustomsec { size, cont }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Customsec {
    pub size: u64,
    pub cont: Custom,
}

impl View for Customsec {
    type V = SpecCustomsec;

    open spec fn view(&self) -> Self::V {
        SpecCustomsec {
            size: self.size@,
            cont: self.cont@,
        }
    }
}
pub type CustomsecInner = (u64, Custom);

pub type CustomsecInnerRef<'a> = (&'a u64, &'a Custom);
impl<'a> From<&'a Customsec> for CustomsecInnerRef<'a> {
    fn ex_from(m: &'a Customsec) -> CustomsecInnerRef<'a> {
        (&m.size, &m.cont)
    }
}

impl From<CustomsecInner> for Customsec {
    fn ex_from(m: CustomsecInner) -> Customsec {
        let (size, cont) = m;
        Customsec { size, cont }
    }
}

pub struct CustomsecMapper;
impl View for CustomsecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for CustomsecMapper {
    type Src = SpecCustomsecInner;
    type Dst = SpecCustomsec;
}
impl SpecIsoProof for CustomsecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for CustomsecMapper {
    type Src = CustomsecInner;
    type Dst = Customsec;
    type RefSrc = CustomsecInnerRef<'a>;
}

pub struct SpecCustomsecCombinator(pub SpecCustomsecCombinatorAlias);

impl SpecCombinator for SpecCustomsecCombinator {
    type Type = SpecCustomsec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecCustomsecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecCustomsecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecCustomsecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, SpecCustomCombinator>>, CustomsecMapper>;

pub struct CustomsecCombinator(pub CustomsecCombinatorAlias);

impl View for CustomsecCombinator {
    type V = SpecCustomsecCombinator;
    open spec fn view(&self) -> Self::V { SpecCustomsecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for CustomsecCombinator {
    type Type = Customsec;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type CustomsecCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, CustomCombinator>, CustomsecCont0>, CustomsecMapper>;


pub open spec fn spec_customsec() -> SpecCustomsecCombinator {
    SpecCustomsecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_customsec_cont0(deps)),
        mapper: CustomsecMapper,
    })
}

pub open spec fn spec_customsec_cont0(deps: u64) -> AndThen<bytes::Variable, SpecCustomCombinator> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), spec_custom())
}

impl View for CustomsecCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, SpecCustomCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_customsec_cont0(deps)
        }
    }
}

                
pub fn customsec<'a>() -> (o: CustomsecCombinator)
    ensures o@ == spec_customsec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = CustomsecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, CustomsecCont0),
        mapper: CustomsecMapper,
    });
    assert({
        &&& combinator@ == spec_customsec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_customsec<'a>(input: &'a [u8]) -> (res: PResult<<CustomsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_customsec().spec_parse(input@) == Some((n as int, v@)),
        spec_customsec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_customsec().spec_parse(input@) is None,
        spec_customsec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = customsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_customsec<'a>(v: <CustomsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_customsec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_customsec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_customsec().spec_serialize(v@))
        },
{
    let combinator = customsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn customsec_len<'a>(v: <CustomsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_customsec().wf(v@),
        spec_customsec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_customsec().spec_serialize(v@).len(),
{
    let combinator = customsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct CustomsecCont0;
type CustomsecCont0Type<'a, 'b> = &'b u64;
type CustomsecCont0SType<'a, 'x> = &'x u64;
type CustomsecCont0Input<'a, 'b, 'x> = POrSType<CustomsecCont0Type<'a, 'b>, CustomsecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<CustomsecCont0Input<'a, 'b, 'x>> for CustomsecCont0 {
    type Output = AndThen<bytes::Variable, CustomCombinator>;

    open spec fn requires(&self, deps: CustomsecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: CustomsecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_customsec_cont0(deps@)
    }

    fn apply(&self, deps: CustomsecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), custom())
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), custom())
            }
        }
    }
}
                

pub struct SpecActiveDatax {
    pub memory: SpecMemidx,
    pub offset: SpecExpr,
    pub init: SpecByteVec,
}

pub type SpecActiveDataxInner = (SpecMemidx, (SpecExpr, SpecByteVec));


impl SpecFrom<SpecActiveDatax> for SpecActiveDataxInner {
    open spec fn spec_from(m: SpecActiveDatax) -> SpecActiveDataxInner {
        (m.memory, (m.offset, m.init))
    }
}

impl SpecFrom<SpecActiveDataxInner> for SpecActiveDatax {
    open spec fn spec_from(m: SpecActiveDataxInner) -> SpecActiveDatax {
        let (memory, (offset, init)) = m;
        SpecActiveDatax { memory, offset, init }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ActiveDatax<'a> {
    pub memory: Memidx,
    pub offset: Expr<'a>,
    pub init: ByteVec,
}

impl View for ActiveDatax<'_> {
    type V = SpecActiveDatax;

    open spec fn view(&self) -> Self::V {
        SpecActiveDatax {
            memory: self.memory@,
            offset: self.offset@,
            init: self.init@,
        }
    }
}
pub type ActiveDataxInner<'a> = (Memidx, (Expr<'a>, ByteVec));

pub type ActiveDataxInnerRef<'a> = (&'a Memidx, (&'a Expr<'a>, &'a ByteVec));
impl<'a> From<&'a ActiveDatax<'a>> for ActiveDataxInnerRef<'a> {
    fn ex_from(m: &'a ActiveDatax) -> ActiveDataxInnerRef<'a> {
        (&m.memory, (&m.offset, &m.init))
    }
}

impl<'a> From<ActiveDataxInner<'a>> for ActiveDatax<'a> {
    fn ex_from(m: ActiveDataxInner) -> ActiveDatax {
        let (memory, (offset, init)) = m;
        ActiveDatax { memory, offset, init }
    }
}

pub struct ActiveDataxMapper;
impl View for ActiveDataxMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ActiveDataxMapper {
    type Src = SpecActiveDataxInner;
    type Dst = SpecActiveDatax;
}
impl SpecIsoProof for ActiveDataxMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ActiveDataxMapper {
    type Src = ActiveDataxInner<'a>;
    type Dst = ActiveDatax<'a>;
    type RefSrc = ActiveDataxInnerRef<'a>;
}
type SpecActiveDataxCombinatorAlias1 = (SpecExprCombinator, SpecByteVecCombinator);
type SpecActiveDataxCombinatorAlias2 = (SpecMemidxCombinator, SpecActiveDataxCombinatorAlias1);
pub struct SpecActiveDataxCombinator(pub SpecActiveDataxCombinatorAlias);

impl SpecCombinator for SpecActiveDataxCombinator {
    type Type = SpecActiveDatax;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecActiveDataxCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecActiveDataxCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecActiveDataxCombinatorAlias = Mapped<SpecActiveDataxCombinatorAlias2, ActiveDataxMapper>;
type ActiveDataxCombinatorAlias1 = (ExprCombinator, ByteVecCombinator);
type ActiveDataxCombinatorAlias2 = (MemidxCombinator, ActiveDataxCombinator1);
pub struct ActiveDataxCombinator1(pub ActiveDataxCombinatorAlias1);
impl View for ActiveDataxCombinator1 {
    type V = SpecActiveDataxCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ActiveDataxCombinator1, ActiveDataxCombinatorAlias1);

pub struct ActiveDataxCombinator2(pub ActiveDataxCombinatorAlias2);
impl View for ActiveDataxCombinator2 {
    type V = SpecActiveDataxCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ActiveDataxCombinator2, ActiveDataxCombinatorAlias2);

pub struct ActiveDataxCombinator(pub ActiveDataxCombinatorAlias);

impl View for ActiveDataxCombinator {
    type V = SpecActiveDataxCombinator;
    open spec fn view(&self) -> Self::V { SpecActiveDataxCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ActiveDataxCombinator {
    type Type = ActiveDatax<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ActiveDataxCombinatorAlias = Mapped<ActiveDataxCombinator2, ActiveDataxMapper>;


pub open spec fn spec_active_datax() -> SpecActiveDataxCombinator {
    SpecActiveDataxCombinator(
    Mapped {
        inner: (spec_memidx(), (spec_expr(), spec_byte_vec())),
        mapper: ActiveDataxMapper,
    })
}

                
pub fn active_datax<'a>() -> (o: ActiveDataxCombinator)
    ensures o@ == spec_active_datax(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ActiveDataxCombinator(
    Mapped {
        inner: ActiveDataxCombinator2((memidx(), ActiveDataxCombinator1((expr(), byte_vec())))),
        mapper: ActiveDataxMapper,
    });
    assert({
        &&& combinator@ == spec_active_datax()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_active_datax<'a>(input: &'a [u8]) -> (res: PResult<<ActiveDataxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_active_datax().spec_parse(input@) == Some((n as int, v@)),
        spec_active_datax().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_active_datax().spec_parse(input@) is None,
        spec_active_datax().spec_parse(input@) is None ==> res is Err,
{
    let combinator = active_datax();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_active_datax<'a>(v: <ActiveDataxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_active_datax().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_active_datax().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_active_datax().spec_serialize(v@))
        },
{
    let combinator = active_datax();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn active_datax_len<'a>(v: <ActiveDataxCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_active_datax().wf(v@),
        spec_active_datax().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_active_datax().spec_serialize(v@).len(),
{
    let combinator = active_datax();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecParsedElem4 {
    pub offset: SpecExpr,
    pub init: SpecExprs,
}

pub type SpecParsedElem4Inner = (SpecExpr, SpecExprs);


impl SpecFrom<SpecParsedElem4> for SpecParsedElem4Inner {
    open spec fn spec_from(m: SpecParsedElem4) -> SpecParsedElem4Inner {
        (m.offset, m.init)
    }
}

impl SpecFrom<SpecParsedElem4Inner> for SpecParsedElem4 {
    open spec fn spec_from(m: SpecParsedElem4Inner) -> SpecParsedElem4 {
        let (offset, init) = m;
        SpecParsedElem4 { offset, init }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ParsedElem4<'a> {
    pub offset: Expr<'a>,
    pub init: Exprs<'a>,
}

impl View for ParsedElem4<'_> {
    type V = SpecParsedElem4;

    open spec fn view(&self) -> Self::V {
        SpecParsedElem4 {
            offset: self.offset@,
            init: self.init@,
        }
    }
}
pub type ParsedElem4Inner<'a> = (Expr<'a>, Exprs<'a>);

pub type ParsedElem4InnerRef<'a> = (&'a Expr<'a>, &'a Exprs<'a>);
impl<'a> From<&'a ParsedElem4<'a>> for ParsedElem4InnerRef<'a> {
    fn ex_from(m: &'a ParsedElem4) -> ParsedElem4InnerRef<'a> {
        (&m.offset, &m.init)
    }
}

impl<'a> From<ParsedElem4Inner<'a>> for ParsedElem4<'a> {
    fn ex_from(m: ParsedElem4Inner) -> ParsedElem4 {
        let (offset, init) = m;
        ParsedElem4 { offset, init }
    }
}

pub struct ParsedElem4Mapper;
impl View for ParsedElem4Mapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ParsedElem4Mapper {
    type Src = SpecParsedElem4Inner;
    type Dst = SpecParsedElem4;
}
impl SpecIsoProof for ParsedElem4Mapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ParsedElem4Mapper {
    type Src = ParsedElem4Inner<'a>;
    type Dst = ParsedElem4<'a>;
    type RefSrc = ParsedElem4InnerRef<'a>;
}
type SpecParsedElem4CombinatorAlias1 = (SpecExprCombinator, SpecExprsCombinator);
pub struct SpecParsedElem4Combinator(pub SpecParsedElem4CombinatorAlias);

impl SpecCombinator for SpecParsedElem4Combinator {
    type Type = SpecParsedElem4;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecParsedElem4Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecParsedElem4CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecParsedElem4CombinatorAlias = Mapped<SpecParsedElem4CombinatorAlias1, ParsedElem4Mapper>;
type ParsedElem4CombinatorAlias1 = (ExprCombinator, ExprsCombinator);
pub struct ParsedElem4Combinator1(pub ParsedElem4CombinatorAlias1);
impl View for ParsedElem4Combinator1 {
    type V = SpecParsedElem4CombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ParsedElem4Combinator1, ParsedElem4CombinatorAlias1);

pub struct ParsedElem4Combinator(pub ParsedElem4CombinatorAlias);

impl View for ParsedElem4Combinator {
    type V = SpecParsedElem4Combinator;
    open spec fn view(&self) -> Self::V { SpecParsedElem4Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ParsedElem4Combinator {
    type Type = ParsedElem4<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ParsedElem4CombinatorAlias = Mapped<ParsedElem4Combinator1, ParsedElem4Mapper>;


pub open spec fn spec_parsed_elem4() -> SpecParsedElem4Combinator {
    SpecParsedElem4Combinator(
    Mapped {
        inner: (spec_expr(), spec_exprs()),
        mapper: ParsedElem4Mapper,
    })
}

                
pub fn parsed_elem4<'a>() -> (o: ParsedElem4Combinator)
    ensures o@ == spec_parsed_elem4(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ParsedElem4Combinator(
    Mapped {
        inner: ParsedElem4Combinator1((expr(), exprs())),
        mapper: ParsedElem4Mapper,
    });
    assert({
        &&& combinator@ == spec_parsed_elem4()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_parsed_elem4<'a>(input: &'a [u8]) -> (res: PResult<<ParsedElem4Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_parsed_elem4().spec_parse(input@) == Some((n as int, v@)),
        spec_parsed_elem4().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_parsed_elem4().spec_parse(input@) is None,
        spec_parsed_elem4().spec_parse(input@) is None ==> res is Err,
{
    let combinator = parsed_elem4();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_parsed_elem4<'a>(v: <ParsedElem4Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_parsed_elem4().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_parsed_elem4().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_parsed_elem4().spec_serialize(v@))
        },
{
    let combinator = parsed_elem4();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn parsed_elem4_len<'a>(v: <ParsedElem4Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_parsed_elem4().wf(v@),
        spec_parsed_elem4().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_parsed_elem4().spec_serialize(v@).len(),
{
    let combinator = parsed_elem4();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecParsedElem1 {
    pub et: SpecELEMKIND,
    pub init: SpecFuncidxs,
}

pub type SpecParsedElem1Inner = (SpecELEMKIND, SpecFuncidxs);


impl SpecFrom<SpecParsedElem1> for SpecParsedElem1Inner {
    open spec fn spec_from(m: SpecParsedElem1) -> SpecParsedElem1Inner {
        (m.et, m.init)
    }
}

impl SpecFrom<SpecParsedElem1Inner> for SpecParsedElem1 {
    open spec fn spec_from(m: SpecParsedElem1Inner) -> SpecParsedElem1 {
        let (et, init) = m;
        SpecParsedElem1 { et, init }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ParsedElem1 {
    pub et: ELEMKIND,
    pub init: Funcidxs,
}

impl View for ParsedElem1 {
    type V = SpecParsedElem1;

    open spec fn view(&self) -> Self::V {
        SpecParsedElem1 {
            et: self.et@,
            init: self.init@,
        }
    }
}
pub type ParsedElem1Inner = (ELEMKIND, Funcidxs);

pub type ParsedElem1InnerRef<'a> = (&'a ELEMKIND, &'a Funcidxs);
impl<'a> From<&'a ParsedElem1> for ParsedElem1InnerRef<'a> {
    fn ex_from(m: &'a ParsedElem1) -> ParsedElem1InnerRef<'a> {
        (&m.et, &m.init)
    }
}

impl From<ParsedElem1Inner> for ParsedElem1 {
    fn ex_from(m: ParsedElem1Inner) -> ParsedElem1 {
        let (et, init) = m;
        ParsedElem1 { et, init }
    }
}

pub struct ParsedElem1Mapper;
impl View for ParsedElem1Mapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ParsedElem1Mapper {
    type Src = SpecParsedElem1Inner;
    type Dst = SpecParsedElem1;
}
impl SpecIsoProof for ParsedElem1Mapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ParsedElem1Mapper {
    type Src = ParsedElem1Inner;
    type Dst = ParsedElem1;
    type RefSrc = ParsedElem1InnerRef<'a>;
}
type SpecParsedElem1CombinatorAlias1 = (SpecELEMKINDCombinator, SpecFuncidxsCombinator);
pub struct SpecParsedElem1Combinator(pub SpecParsedElem1CombinatorAlias);

impl SpecCombinator for SpecParsedElem1Combinator {
    type Type = SpecParsedElem1;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecParsedElem1Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecParsedElem1CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecParsedElem1CombinatorAlias = Mapped<SpecParsedElem1CombinatorAlias1, ParsedElem1Mapper>;
type ParsedElem1CombinatorAlias1 = (ELEMKINDCombinator, FuncidxsCombinator);
pub struct ParsedElem1Combinator1(pub ParsedElem1CombinatorAlias1);
impl View for ParsedElem1Combinator1 {
    type V = SpecParsedElem1CombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ParsedElem1Combinator1, ParsedElem1CombinatorAlias1);

pub struct ParsedElem1Combinator(pub ParsedElem1CombinatorAlias);

impl View for ParsedElem1Combinator {
    type V = SpecParsedElem1Combinator;
    open spec fn view(&self) -> Self::V { SpecParsedElem1Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ParsedElem1Combinator {
    type Type = ParsedElem1;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ParsedElem1CombinatorAlias = Mapped<ParsedElem1Combinator1, ParsedElem1Mapper>;


pub open spec fn spec_parsed_elem1() -> SpecParsedElem1Combinator {
    SpecParsedElem1Combinator(
    Mapped {
        inner: (spec_ELEMKIND(), spec_funcidxs()),
        mapper: ParsedElem1Mapper,
    })
}

                
pub fn parsed_elem1<'a>() -> (o: ParsedElem1Combinator)
    ensures o@ == spec_parsed_elem1(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ParsedElem1Combinator(
    Mapped {
        inner: ParsedElem1Combinator1((ELEMKIND(), funcidxs())),
        mapper: ParsedElem1Mapper,
    });
    assert({
        &&& combinator@ == spec_parsed_elem1()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_parsed_elem1<'a>(input: &'a [u8]) -> (res: PResult<<ParsedElem1Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_parsed_elem1().spec_parse(input@) == Some((n as int, v@)),
        spec_parsed_elem1().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_parsed_elem1().spec_parse(input@) is None,
        spec_parsed_elem1().spec_parse(input@) is None ==> res is Err,
{
    let combinator = parsed_elem1();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_parsed_elem1<'a>(v: <ParsedElem1Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_parsed_elem1().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_parsed_elem1().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_parsed_elem1().spec_serialize(v@))
        },
{
    let combinator = parsed_elem1();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn parsed_elem1_len<'a>(v: <ParsedElem1Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_parsed_elem1().wf(v@),
        spec_parsed_elem1().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_parsed_elem1().spec_serialize(v@).len(),
{
    let combinator = parsed_elem1();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecCodesecContent {
    pub l: u64,
    pub v: Seq<SpecCode>,
}

pub type SpecCodesecContentInner = (u64, Seq<SpecCode>);


impl SpecFrom<SpecCodesecContent> for SpecCodesecContentInner {
    open spec fn spec_from(m: SpecCodesecContent) -> SpecCodesecContentInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecCodesecContentInner> for SpecCodesecContent {
    open spec fn spec_from(m: SpecCodesecContentInner) -> SpecCodesecContent {
        let (l, v) = m;
        SpecCodesecContent { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct CodesecContent<'a> {
    pub l: u64,
    pub v: RepeatResult<Code<'a>>,
}

impl View for CodesecContent<'_> {
    type V = SpecCodesecContent;

    open spec fn view(&self) -> Self::V {
        SpecCodesecContent {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type CodesecContentInner<'a> = (u64, RepeatResult<Code<'a>>);

pub type CodesecContentInnerRef<'a> = (&'a u64, &'a RepeatResult<Code<'a>>);
impl<'a> From<&'a CodesecContent<'a>> for CodesecContentInnerRef<'a> {
    fn ex_from(m: &'a CodesecContent) -> CodesecContentInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl<'a> From<CodesecContentInner<'a>> for CodesecContent<'a> {
    fn ex_from(m: CodesecContentInner) -> CodesecContent {
        let (l, v) = m;
        CodesecContent { l, v }
    }
}

pub struct CodesecContentMapper;
impl View for CodesecContentMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for CodesecContentMapper {
    type Src = SpecCodesecContentInner;
    type Dst = SpecCodesecContent;
}
impl SpecIsoProof for CodesecContentMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for CodesecContentMapper {
    type Src = CodesecContentInner<'a>;
    type Dst = CodesecContent<'a>;
    type RefSrc = CodesecContentInnerRef<'a>;
}

pub struct SpecCodesecContentCombinator(pub SpecCodesecContentCombinatorAlias);

impl SpecCombinator for SpecCodesecContentCombinator {
    type Type = SpecCodesecContent;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecCodesecContentCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecCodesecContentCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecCodesecContentCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecCodeCombinator>>, CodesecContentMapper>;

pub struct CodesecContentCombinator(pub CodesecContentCombinatorAlias);

impl View for CodesecContentCombinator {
    type V = SpecCodesecContentCombinator;
    open spec fn view(&self) -> Self::V { SpecCodesecContentCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for CodesecContentCombinator {
    type Type = CodesecContent<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type CodesecContentCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<CodeCombinator>, CodesecContentCont0>, CodesecContentMapper>;


pub open spec fn spec_codesec_content() -> SpecCodesecContentCombinator {
    SpecCodesecContentCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_codesec_content_cont0(deps)),
        mapper: CodesecContentMapper,
    })
}

pub open spec fn spec_codesec_content_cont0(deps: u64) -> RepeatN<SpecCodeCombinator> {
    let l = deps;
    RepeatN(spec_code(), l.spec_into())
}

impl View for CodesecContentCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecCodeCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_codesec_content_cont0(deps)
        }
    }
}

                
pub fn codesec_content<'a>() -> (o: CodesecContentCombinator)
    ensures o@ == spec_codesec_content(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = CodesecContentCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, CodesecContentCont0),
        mapper: CodesecContentMapper,
    });
    assert({
        &&& combinator@ == spec_codesec_content()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_codesec_content<'a>(input: &'a [u8]) -> (res: PResult<<CodesecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_codesec_content().spec_parse(input@) == Some((n as int, v@)),
        spec_codesec_content().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_codesec_content().spec_parse(input@) is None,
        spec_codesec_content().spec_parse(input@) is None ==> res is Err,
{
    let combinator = codesec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_codesec_content<'a>(v: <CodesecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_codesec_content().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_codesec_content().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_codesec_content().spec_serialize(v@))
        },
{
    let combinator = codesec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn codesec_content_len<'a>(v: <CodesecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_codesec_content().wf(v@),
        spec_codesec_content().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_codesec_content().spec_serialize(v@).len(),
{
    let combinator = codesec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct CodesecContentCont0;
type CodesecContentCont0Type<'a, 'b> = &'b u64;
type CodesecContentCont0SType<'a, 'x> = &'x u64;
type CodesecContentCont0Input<'a, 'b, 'x> = POrSType<CodesecContentCont0Type<'a, 'b>, CodesecContentCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<CodesecContentCont0Input<'a, 'b, 'x>> for CodesecContentCont0 {
    type Output = RepeatN<CodeCombinator>;

    open spec fn requires(&self, deps: CodesecContentCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: CodesecContentCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_codesec_content_cont0(deps@)
    }

    fn apply(&self, deps: CodesecContentCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(code(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(code(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecCodesec {
    pub size: u64,
    pub cont: SpecCodesecContent,
}

pub type SpecCodesecInner = (u64, SpecCodesecContent);


impl SpecFrom<SpecCodesec> for SpecCodesecInner {
    open spec fn spec_from(m: SpecCodesec) -> SpecCodesecInner {
        (m.size, m.cont)
    }
}

impl SpecFrom<SpecCodesecInner> for SpecCodesec {
    open spec fn spec_from(m: SpecCodesecInner) -> SpecCodesec {
        let (size, cont) = m;
        SpecCodesec { size, cont }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Codesec<'a> {
    pub size: u64,
    pub cont: CodesecContent<'a>,
}

impl View for Codesec<'_> {
    type V = SpecCodesec;

    open spec fn view(&self) -> Self::V {
        SpecCodesec {
            size: self.size@,
            cont: self.cont@,
        }
    }
}
pub type CodesecInner<'a> = (u64, CodesecContent<'a>);

pub type CodesecInnerRef<'a> = (&'a u64, &'a CodesecContent<'a>);
impl<'a> From<&'a Codesec<'a>> for CodesecInnerRef<'a> {
    fn ex_from(m: &'a Codesec) -> CodesecInnerRef<'a> {
        (&m.size, &m.cont)
    }
}

impl<'a> From<CodesecInner<'a>> for Codesec<'a> {
    fn ex_from(m: CodesecInner) -> Codesec {
        let (size, cont) = m;
        Codesec { size, cont }
    }
}

pub struct CodesecMapper;
impl View for CodesecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for CodesecMapper {
    type Src = SpecCodesecInner;
    type Dst = SpecCodesec;
}
impl SpecIsoProof for CodesecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for CodesecMapper {
    type Src = CodesecInner<'a>;
    type Dst = Codesec<'a>;
    type RefSrc = CodesecInnerRef<'a>;
}

pub struct SpecCodesecCombinator(pub SpecCodesecCombinatorAlias);

impl SpecCombinator for SpecCodesecCombinator {
    type Type = SpecCodesec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecCodesecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecCodesecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecCodesecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, SpecCodesecContentCombinator>>, CodesecMapper>;

pub struct CodesecCombinator(pub CodesecCombinatorAlias);

impl View for CodesecCombinator {
    type V = SpecCodesecCombinator;
    open spec fn view(&self) -> Self::V { SpecCodesecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for CodesecCombinator {
    type Type = Codesec<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type CodesecCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, CodesecContentCombinator>, CodesecCont0>, CodesecMapper>;


pub open spec fn spec_codesec() -> SpecCodesecCombinator {
    SpecCodesecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_codesec_cont0(deps)),
        mapper: CodesecMapper,
    })
}

pub open spec fn spec_codesec_cont0(deps: u64) -> AndThen<bytes::Variable, SpecCodesecContentCombinator> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), spec_codesec_content())
}

impl View for CodesecCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, SpecCodesecContentCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_codesec_cont0(deps)
        }
    }
}

                
pub fn codesec<'a>() -> (o: CodesecCombinator)
    ensures o@ == spec_codesec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = CodesecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, CodesecCont0),
        mapper: CodesecMapper,
    });
    assert({
        &&& combinator@ == spec_codesec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_codesec<'a>(input: &'a [u8]) -> (res: PResult<<CodesecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_codesec().spec_parse(input@) == Some((n as int, v@)),
        spec_codesec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_codesec().spec_parse(input@) is None,
        spec_codesec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = codesec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_codesec<'a>(v: <CodesecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_codesec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_codesec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_codesec().spec_serialize(v@))
        },
{
    let combinator = codesec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn codesec_len<'a>(v: <CodesecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_codesec().wf(v@),
        spec_codesec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_codesec().spec_serialize(v@).len(),
{
    let combinator = codesec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct CodesecCont0;
type CodesecCont0Type<'a, 'b> = &'b u64;
type CodesecCont0SType<'a, 'x> = &'x u64;
type CodesecCont0Input<'a, 'b, 'x> = POrSType<CodesecCont0Type<'a, 'b>, CodesecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<CodesecCont0Input<'a, 'b, 'x>> for CodesecCont0 {
    type Output = AndThen<bytes::Variable, CodesecContentCombinator>;

    open spec fn requires(&self, deps: CodesecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: CodesecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_codesec_cont0(deps@)
    }

    fn apply(&self, deps: CodesecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), codesec_content())
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), codesec_content())
            }
        }
    }
}
                

pub struct SpecParsedElem5 {
    pub et: SpecReftype,
    pub init: SpecExprs,
}

pub type SpecParsedElem5Inner = (SpecReftype, SpecExprs);


impl SpecFrom<SpecParsedElem5> for SpecParsedElem5Inner {
    open spec fn spec_from(m: SpecParsedElem5) -> SpecParsedElem5Inner {
        (m.et, m.init)
    }
}

impl SpecFrom<SpecParsedElem5Inner> for SpecParsedElem5 {
    open spec fn spec_from(m: SpecParsedElem5Inner) -> SpecParsedElem5 {
        let (et, init) = m;
        SpecParsedElem5 { et, init }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ParsedElem5<'a> {
    pub et: Reftype,
    pub init: Exprs<'a>,
}

impl View for ParsedElem5<'_> {
    type V = SpecParsedElem5;

    open spec fn view(&self) -> Self::V {
        SpecParsedElem5 {
            et: self.et@,
            init: self.init@,
        }
    }
}
pub type ParsedElem5Inner<'a> = (Reftype, Exprs<'a>);

pub type ParsedElem5InnerRef<'a> = (&'a Reftype, &'a Exprs<'a>);
impl<'a> From<&'a ParsedElem5<'a>> for ParsedElem5InnerRef<'a> {
    fn ex_from(m: &'a ParsedElem5) -> ParsedElem5InnerRef<'a> {
        (&m.et, &m.init)
    }
}

impl<'a> From<ParsedElem5Inner<'a>> for ParsedElem5<'a> {
    fn ex_from(m: ParsedElem5Inner) -> ParsedElem5 {
        let (et, init) = m;
        ParsedElem5 { et, init }
    }
}

pub struct ParsedElem5Mapper;
impl View for ParsedElem5Mapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ParsedElem5Mapper {
    type Src = SpecParsedElem5Inner;
    type Dst = SpecParsedElem5;
}
impl SpecIsoProof for ParsedElem5Mapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ParsedElem5Mapper {
    type Src = ParsedElem5Inner<'a>;
    type Dst = ParsedElem5<'a>;
    type RefSrc = ParsedElem5InnerRef<'a>;
}
type SpecParsedElem5CombinatorAlias1 = (SpecReftypeCombinator, SpecExprsCombinator);
pub struct SpecParsedElem5Combinator(pub SpecParsedElem5CombinatorAlias);

impl SpecCombinator for SpecParsedElem5Combinator {
    type Type = SpecParsedElem5;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecParsedElem5Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecParsedElem5CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecParsedElem5CombinatorAlias = Mapped<SpecParsedElem5CombinatorAlias1, ParsedElem5Mapper>;
type ParsedElem5CombinatorAlias1 = (ReftypeCombinator, ExprsCombinator);
pub struct ParsedElem5Combinator1(pub ParsedElem5CombinatorAlias1);
impl View for ParsedElem5Combinator1 {
    type V = SpecParsedElem5CombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ParsedElem5Combinator1, ParsedElem5CombinatorAlias1);

pub struct ParsedElem5Combinator(pub ParsedElem5CombinatorAlias);

impl View for ParsedElem5Combinator {
    type V = SpecParsedElem5Combinator;
    open spec fn view(&self) -> Self::V { SpecParsedElem5Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ParsedElem5Combinator {
    type Type = ParsedElem5<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ParsedElem5CombinatorAlias = Mapped<ParsedElem5Combinator1, ParsedElem5Mapper>;


pub open spec fn spec_parsed_elem5() -> SpecParsedElem5Combinator {
    SpecParsedElem5Combinator(
    Mapped {
        inner: (spec_reftype(), spec_exprs()),
        mapper: ParsedElem5Mapper,
    })
}

                
pub fn parsed_elem5<'a>() -> (o: ParsedElem5Combinator)
    ensures o@ == spec_parsed_elem5(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ParsedElem5Combinator(
    Mapped {
        inner: ParsedElem5Combinator1((reftype(), exprs())),
        mapper: ParsedElem5Mapper,
    });
    assert({
        &&& combinator@ == spec_parsed_elem5()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_parsed_elem5<'a>(input: &'a [u8]) -> (res: PResult<<ParsedElem5Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_parsed_elem5().spec_parse(input@) == Some((n as int, v@)),
        spec_parsed_elem5().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_parsed_elem5().spec_parse(input@) is None,
        spec_parsed_elem5().spec_parse(input@) is None ==> res is Err,
{
    let combinator = parsed_elem5();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_parsed_elem5<'a>(v: <ParsedElem5Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_parsed_elem5().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_parsed_elem5().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_parsed_elem5().spec_serialize(v@))
        },
{
    let combinator = parsed_elem5();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn parsed_elem5_len<'a>(v: <ParsedElem5Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_parsed_elem5().wf(v@),
        spec_parsed_elem5().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_parsed_elem5().spec_serialize(v@).len(),
{
    let combinator = parsed_elem5();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecImports {
    pub l: u64,
    pub v: Seq<SpecImport>,
}

pub type SpecImportsInner = (u64, Seq<SpecImport>);


impl SpecFrom<SpecImports> for SpecImportsInner {
    open spec fn spec_from(m: SpecImports) -> SpecImportsInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecImportsInner> for SpecImports {
    open spec fn spec_from(m: SpecImportsInner) -> SpecImports {
        let (l, v) = m;
        SpecImports { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Imports {
    pub l: u64,
    pub v: RepeatResult<Import>,
}

impl View for Imports {
    type V = SpecImports;

    open spec fn view(&self) -> Self::V {
        SpecImports {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type ImportsInner = (u64, RepeatResult<Import>);

pub type ImportsInnerRef<'a> = (&'a u64, &'a RepeatResult<Import>);
impl<'a> From<&'a Imports> for ImportsInnerRef<'a> {
    fn ex_from(m: &'a Imports) -> ImportsInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl From<ImportsInner> for Imports {
    fn ex_from(m: ImportsInner) -> Imports {
        let (l, v) = m;
        Imports { l, v }
    }
}

pub struct ImportsMapper;
impl View for ImportsMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ImportsMapper {
    type Src = SpecImportsInner;
    type Dst = SpecImports;
}
impl SpecIsoProof for ImportsMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ImportsMapper {
    type Src = ImportsInner;
    type Dst = Imports;
    type RefSrc = ImportsInnerRef<'a>;
}

pub struct SpecImportsCombinator(pub SpecImportsCombinatorAlias);

impl SpecCombinator for SpecImportsCombinator {
    type Type = SpecImports;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecImportsCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecImportsCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecImportsCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecImportCombinator>>, ImportsMapper>;

pub struct ImportsCombinator(pub ImportsCombinatorAlias);

impl View for ImportsCombinator {
    type V = SpecImportsCombinator;
    open spec fn view(&self) -> Self::V { SpecImportsCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ImportsCombinator {
    type Type = Imports;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ImportsCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<ImportCombinator>, ImportsCont0>, ImportsMapper>;


pub open spec fn spec_imports() -> SpecImportsCombinator {
    SpecImportsCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_imports_cont0(deps)),
        mapper: ImportsMapper,
    })
}

pub open spec fn spec_imports_cont0(deps: u64) -> RepeatN<SpecImportCombinator> {
    let l = deps;
    RepeatN(spec_import(), l.spec_into())
}

impl View for ImportsCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecImportCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_imports_cont0(deps)
        }
    }
}

                
pub fn imports<'a>() -> (o: ImportsCombinator)
    ensures o@ == spec_imports(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ImportsCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, ImportsCont0),
        mapper: ImportsMapper,
    });
    assert({
        &&& combinator@ == spec_imports()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_imports<'a>(input: &'a [u8]) -> (res: PResult<<ImportsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_imports().spec_parse(input@) == Some((n as int, v@)),
        spec_imports().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_imports().spec_parse(input@) is None,
        spec_imports().spec_parse(input@) is None ==> res is Err,
{
    let combinator = imports();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_imports<'a>(v: <ImportsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_imports().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_imports().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_imports().spec_serialize(v@))
        },
{
    let combinator = imports();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn imports_len<'a>(v: <ImportsCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_imports().wf(v@),
        spec_imports().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_imports().spec_serialize(v@).len(),
{
    let combinator = imports();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct ImportsCont0;
type ImportsCont0Type<'a, 'b> = &'b u64;
type ImportsCont0SType<'a, 'x> = &'x u64;
type ImportsCont0Input<'a, 'b, 'x> = POrSType<ImportsCont0Type<'a, 'b>, ImportsCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<ImportsCont0Input<'a, 'b, 'x>> for ImportsCont0 {
    type Output = RepeatN<ImportCombinator>;

    open spec fn requires(&self, deps: ImportsCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: ImportsCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_imports_cont0(deps@)
    }

    fn apply(&self, deps: ImportsCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(import(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(import(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecImportsec {
    pub size: u64,
    pub cont: SpecImports,
}

pub type SpecImportsecInner = (u64, SpecImports);


impl SpecFrom<SpecImportsec> for SpecImportsecInner {
    open spec fn spec_from(m: SpecImportsec) -> SpecImportsecInner {
        (m.size, m.cont)
    }
}

impl SpecFrom<SpecImportsecInner> for SpecImportsec {
    open spec fn spec_from(m: SpecImportsecInner) -> SpecImportsec {
        let (size, cont) = m;
        SpecImportsec { size, cont }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Importsec {
    pub size: u64,
    pub cont: Imports,
}

impl View for Importsec {
    type V = SpecImportsec;

    open spec fn view(&self) -> Self::V {
        SpecImportsec {
            size: self.size@,
            cont: self.cont@,
        }
    }
}
pub type ImportsecInner = (u64, Imports);

pub type ImportsecInnerRef<'a> = (&'a u64, &'a Imports);
impl<'a> From<&'a Importsec> for ImportsecInnerRef<'a> {
    fn ex_from(m: &'a Importsec) -> ImportsecInnerRef<'a> {
        (&m.size, &m.cont)
    }
}

impl From<ImportsecInner> for Importsec {
    fn ex_from(m: ImportsecInner) -> Importsec {
        let (size, cont) = m;
        Importsec { size, cont }
    }
}

pub struct ImportsecMapper;
impl View for ImportsecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ImportsecMapper {
    type Src = SpecImportsecInner;
    type Dst = SpecImportsec;
}
impl SpecIsoProof for ImportsecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ImportsecMapper {
    type Src = ImportsecInner;
    type Dst = Importsec;
    type RefSrc = ImportsecInnerRef<'a>;
}

pub struct SpecImportsecCombinator(pub SpecImportsecCombinatorAlias);

impl SpecCombinator for SpecImportsecCombinator {
    type Type = SpecImportsec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecImportsecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecImportsecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecImportsecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, SpecImportsCombinator>>, ImportsecMapper>;

pub struct ImportsecCombinator(pub ImportsecCombinatorAlias);

impl View for ImportsecCombinator {
    type V = SpecImportsecCombinator;
    open spec fn view(&self) -> Self::V { SpecImportsecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ImportsecCombinator {
    type Type = Importsec;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ImportsecCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, ImportsCombinator>, ImportsecCont0>, ImportsecMapper>;


pub open spec fn spec_importsec() -> SpecImportsecCombinator {
    SpecImportsecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_importsec_cont0(deps)),
        mapper: ImportsecMapper,
    })
}

pub open spec fn spec_importsec_cont0(deps: u64) -> AndThen<bytes::Variable, SpecImportsCombinator> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), spec_imports())
}

impl View for ImportsecCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, SpecImportsCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_importsec_cont0(deps)
        }
    }
}

                
pub fn importsec<'a>() -> (o: ImportsecCombinator)
    ensures o@ == spec_importsec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ImportsecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, ImportsecCont0),
        mapper: ImportsecMapper,
    });
    assert({
        &&& combinator@ == spec_importsec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_importsec<'a>(input: &'a [u8]) -> (res: PResult<<ImportsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_importsec().spec_parse(input@) == Some((n as int, v@)),
        spec_importsec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_importsec().spec_parse(input@) is None,
        spec_importsec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = importsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_importsec<'a>(v: <ImportsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_importsec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_importsec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_importsec().spec_serialize(v@))
        },
{
    let combinator = importsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn importsec_len<'a>(v: <ImportsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_importsec().wf(v@),
        spec_importsec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_importsec().spec_serialize(v@).len(),
{
    let combinator = importsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct ImportsecCont0;
type ImportsecCont0Type<'a, 'b> = &'b u64;
type ImportsecCont0SType<'a, 'x> = &'x u64;
type ImportsecCont0Input<'a, 'b, 'x> = POrSType<ImportsecCont0Type<'a, 'b>, ImportsecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<ImportsecCont0Input<'a, 'b, 'x>> for ImportsecCont0 {
    type Output = AndThen<bytes::Variable, ImportsCombinator>;

    open spec fn requires(&self, deps: ImportsecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: ImportsecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_importsec_cont0(deps@)
    }

    fn apply(&self, deps: ImportsecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), imports())
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), imports())
            }
        }
    }
}
                
pub type SpecPassiveData = SpecByteVec;
pub type PassiveData = ByteVec;
pub type PassiveDataRef<'a> = &'a ByteVec;


pub struct SpecPassiveDataCombinator(pub SpecPassiveDataCombinatorAlias);

impl SpecCombinator for SpecPassiveDataCombinator {
    type Type = SpecPassiveData;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecPassiveDataCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecPassiveDataCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecPassiveDataCombinatorAlias = SpecByteVecCombinator;

pub struct PassiveDataCombinator(pub PassiveDataCombinatorAlias);

impl View for PassiveDataCombinator {
    type V = SpecPassiveDataCombinator;
    open spec fn view(&self) -> Self::V { SpecPassiveDataCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for PassiveDataCombinator {
    type Type = PassiveData;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type PassiveDataCombinatorAlias = ByteVecCombinator;


pub open spec fn spec_passive_data() -> SpecPassiveDataCombinator {
    SpecPassiveDataCombinator(spec_byte_vec())
}

                
pub fn passive_data<'a>() -> (o: PassiveDataCombinator)
    ensures o@ == spec_passive_data(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = PassiveDataCombinator(byte_vec());
    assert({
        &&& combinator@ == spec_passive_data()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_passive_data<'a>(input: &'a [u8]) -> (res: PResult<<PassiveDataCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_passive_data().spec_parse(input@) == Some((n as int, v@)),
        spec_passive_data().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_passive_data().spec_parse(input@) is None,
        spec_passive_data().spec_parse(input@) is None ==> res is Err,
{
    let combinator = passive_data();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_passive_data<'a>(v: <PassiveDataCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_passive_data().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_passive_data().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_passive_data().spec_serialize(v@))
        },
{
    let combinator = passive_data();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn passive_data_len<'a>(v: <PassiveDataCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_passive_data().wf(v@),
        spec_passive_data().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_passive_data().spec_serialize(v@).len(),
{
    let combinator = passive_data();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecParsedElem2 {
    pub table: SpecTableidx,
    pub offset: SpecExpr,
    pub et: SpecELEMKIND,
    pub init: SpecFuncidxs,
}

pub type SpecParsedElem2Inner = (SpecTableidx, (SpecExpr, (SpecELEMKIND, SpecFuncidxs)));


impl SpecFrom<SpecParsedElem2> for SpecParsedElem2Inner {
    open spec fn spec_from(m: SpecParsedElem2) -> SpecParsedElem2Inner {
        (m.table, (m.offset, (m.et, m.init)))
    }
}

impl SpecFrom<SpecParsedElem2Inner> for SpecParsedElem2 {
    open spec fn spec_from(m: SpecParsedElem2Inner) -> SpecParsedElem2 {
        let (table, (offset, (et, init))) = m;
        SpecParsedElem2 { table, offset, et, init }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ParsedElem2<'a> {
    pub table: Tableidx,
    pub offset: Expr<'a>,
    pub et: ELEMKIND,
    pub init: Funcidxs,
}

impl View for ParsedElem2<'_> {
    type V = SpecParsedElem2;

    open spec fn view(&self) -> Self::V {
        SpecParsedElem2 {
            table: self.table@,
            offset: self.offset@,
            et: self.et@,
            init: self.init@,
        }
    }
}
pub type ParsedElem2Inner<'a> = (Tableidx, (Expr<'a>, (ELEMKIND, Funcidxs)));

pub type ParsedElem2InnerRef<'a> = (&'a Tableidx, (&'a Expr<'a>, (&'a ELEMKIND, &'a Funcidxs)));
impl<'a> From<&'a ParsedElem2<'a>> for ParsedElem2InnerRef<'a> {
    fn ex_from(m: &'a ParsedElem2) -> ParsedElem2InnerRef<'a> {
        (&m.table, (&m.offset, (&m.et, &m.init)))
    }
}

impl<'a> From<ParsedElem2Inner<'a>> for ParsedElem2<'a> {
    fn ex_from(m: ParsedElem2Inner) -> ParsedElem2 {
        let (table, (offset, (et, init))) = m;
        ParsedElem2 { table, offset, et, init }
    }
}

pub struct ParsedElem2Mapper;
impl View for ParsedElem2Mapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ParsedElem2Mapper {
    type Src = SpecParsedElem2Inner;
    type Dst = SpecParsedElem2;
}
impl SpecIsoProof for ParsedElem2Mapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ParsedElem2Mapper {
    type Src = ParsedElem2Inner<'a>;
    type Dst = ParsedElem2<'a>;
    type RefSrc = ParsedElem2InnerRef<'a>;
}
type SpecParsedElem2CombinatorAlias1 = (SpecELEMKINDCombinator, SpecFuncidxsCombinator);
type SpecParsedElem2CombinatorAlias2 = (SpecExprCombinator, SpecParsedElem2CombinatorAlias1);
type SpecParsedElem2CombinatorAlias3 = (SpecTableidxCombinator, SpecParsedElem2CombinatorAlias2);
pub struct SpecParsedElem2Combinator(pub SpecParsedElem2CombinatorAlias);

impl SpecCombinator for SpecParsedElem2Combinator {
    type Type = SpecParsedElem2;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecParsedElem2Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecParsedElem2CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecParsedElem2CombinatorAlias = Mapped<SpecParsedElem2CombinatorAlias3, ParsedElem2Mapper>;
type ParsedElem2CombinatorAlias1 = (ELEMKINDCombinator, FuncidxsCombinator);
type ParsedElem2CombinatorAlias2 = (ExprCombinator, ParsedElem2Combinator1);
type ParsedElem2CombinatorAlias3 = (TableidxCombinator, ParsedElem2Combinator2);
pub struct ParsedElem2Combinator1(pub ParsedElem2CombinatorAlias1);
impl View for ParsedElem2Combinator1 {
    type V = SpecParsedElem2CombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ParsedElem2Combinator1, ParsedElem2CombinatorAlias1);

pub struct ParsedElem2Combinator2(pub ParsedElem2CombinatorAlias2);
impl View for ParsedElem2Combinator2 {
    type V = SpecParsedElem2CombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ParsedElem2Combinator2, ParsedElem2CombinatorAlias2);

pub struct ParsedElem2Combinator3(pub ParsedElem2CombinatorAlias3);
impl View for ParsedElem2Combinator3 {
    type V = SpecParsedElem2CombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ParsedElem2Combinator3, ParsedElem2CombinatorAlias3);

pub struct ParsedElem2Combinator(pub ParsedElem2CombinatorAlias);

impl View for ParsedElem2Combinator {
    type V = SpecParsedElem2Combinator;
    open spec fn view(&self) -> Self::V { SpecParsedElem2Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ParsedElem2Combinator {
    type Type = ParsedElem2<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ParsedElem2CombinatorAlias = Mapped<ParsedElem2Combinator3, ParsedElem2Mapper>;


pub open spec fn spec_parsed_elem2() -> SpecParsedElem2Combinator {
    SpecParsedElem2Combinator(
    Mapped {
        inner: (spec_tableidx(), (spec_expr(), (spec_ELEMKIND(), spec_funcidxs()))),
        mapper: ParsedElem2Mapper,
    })
}

                
pub fn parsed_elem2<'a>() -> (o: ParsedElem2Combinator)
    ensures o@ == spec_parsed_elem2(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ParsedElem2Combinator(
    Mapped {
        inner: ParsedElem2Combinator3((tableidx(), ParsedElem2Combinator2((expr(), ParsedElem2Combinator1((ELEMKIND(), funcidxs())))))),
        mapper: ParsedElem2Mapper,
    });
    assert({
        &&& combinator@ == spec_parsed_elem2()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_parsed_elem2<'a>(input: &'a [u8]) -> (res: PResult<<ParsedElem2Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_parsed_elem2().spec_parse(input@) == Some((n as int, v@)),
        spec_parsed_elem2().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_parsed_elem2().spec_parse(input@) is None,
        spec_parsed_elem2().spec_parse(input@) is None ==> res is Err,
{
    let combinator = parsed_elem2();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_parsed_elem2<'a>(v: <ParsedElem2Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_parsed_elem2().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_parsed_elem2().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_parsed_elem2().spec_serialize(v@))
        },
{
    let combinator = parsed_elem2();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn parsed_elem2_len<'a>(v: <ParsedElem2Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_parsed_elem2().wf(v@),
        spec_parsed_elem2().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_parsed_elem2().spec_serialize(v@).len(),
{
    let combinator = parsed_elem2();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                
pub type SpecParsedElem3 = SpecParsedElem1;
pub type ParsedElem3 = ParsedElem1;
pub type ParsedElem3Ref<'a> = &'a ParsedElem1;


pub struct SpecParsedElem3Combinator(pub SpecParsedElem3CombinatorAlias);

impl SpecCombinator for SpecParsedElem3Combinator {
    type Type = SpecParsedElem3;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecParsedElem3Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecParsedElem3CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecParsedElem3CombinatorAlias = SpecParsedElem1Combinator;

pub struct ParsedElem3Combinator(pub ParsedElem3CombinatorAlias);

impl View for ParsedElem3Combinator {
    type V = SpecParsedElem3Combinator;
    open spec fn view(&self) -> Self::V { SpecParsedElem3Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ParsedElem3Combinator {
    type Type = ParsedElem3;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ParsedElem3CombinatorAlias = ParsedElem1Combinator;


pub open spec fn spec_parsed_elem3() -> SpecParsedElem3Combinator {
    SpecParsedElem3Combinator(spec_parsed_elem1())
}

                
pub fn parsed_elem3<'a>() -> (o: ParsedElem3Combinator)
    ensures o@ == spec_parsed_elem3(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ParsedElem3Combinator(parsed_elem1());
    assert({
        &&& combinator@ == spec_parsed_elem3()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_parsed_elem3<'a>(input: &'a [u8]) -> (res: PResult<<ParsedElem3Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_parsed_elem3().spec_parse(input@) == Some((n as int, v@)),
        spec_parsed_elem3().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_parsed_elem3().spec_parse(input@) is None,
        spec_parsed_elem3().spec_parse(input@) is None ==> res is Err,
{
    let combinator = parsed_elem3();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_parsed_elem3<'a>(v: <ParsedElem3Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_parsed_elem3().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_parsed_elem3().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_parsed_elem3().spec_serialize(v@))
        },
{
    let combinator = parsed_elem3();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn parsed_elem3_len<'a>(v: <ParsedElem3Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_parsed_elem3().wf(v@),
        spec_parsed_elem3().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_parsed_elem3().spec_serialize(v@).len(),
{
    let combinator = parsed_elem3();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecParsedElem6 {
    pub table: SpecTableidx,
    pub offset: SpecExpr,
    pub et: SpecReftype,
    pub init: SpecExprs,
}

pub type SpecParsedElem6Inner = (SpecTableidx, (SpecExpr, (SpecReftype, SpecExprs)));


impl SpecFrom<SpecParsedElem6> for SpecParsedElem6Inner {
    open spec fn spec_from(m: SpecParsedElem6) -> SpecParsedElem6Inner {
        (m.table, (m.offset, (m.et, m.init)))
    }
}

impl SpecFrom<SpecParsedElem6Inner> for SpecParsedElem6 {
    open spec fn spec_from(m: SpecParsedElem6Inner) -> SpecParsedElem6 {
        let (table, (offset, (et, init))) = m;
        SpecParsedElem6 { table, offset, et, init }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ParsedElem6<'a> {
    pub table: Tableidx,
    pub offset: Expr<'a>,
    pub et: Reftype,
    pub init: Exprs<'a>,
}

impl View for ParsedElem6<'_> {
    type V = SpecParsedElem6;

    open spec fn view(&self) -> Self::V {
        SpecParsedElem6 {
            table: self.table@,
            offset: self.offset@,
            et: self.et@,
            init: self.init@,
        }
    }
}
pub type ParsedElem6Inner<'a> = (Tableidx, (Expr<'a>, (Reftype, Exprs<'a>)));

pub type ParsedElem6InnerRef<'a> = (&'a Tableidx, (&'a Expr<'a>, (&'a Reftype, &'a Exprs<'a>)));
impl<'a> From<&'a ParsedElem6<'a>> for ParsedElem6InnerRef<'a> {
    fn ex_from(m: &'a ParsedElem6) -> ParsedElem6InnerRef<'a> {
        (&m.table, (&m.offset, (&m.et, &m.init)))
    }
}

impl<'a> From<ParsedElem6Inner<'a>> for ParsedElem6<'a> {
    fn ex_from(m: ParsedElem6Inner) -> ParsedElem6 {
        let (table, (offset, (et, init))) = m;
        ParsedElem6 { table, offset, et, init }
    }
}

pub struct ParsedElem6Mapper;
impl View for ParsedElem6Mapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ParsedElem6Mapper {
    type Src = SpecParsedElem6Inner;
    type Dst = SpecParsedElem6;
}
impl SpecIsoProof for ParsedElem6Mapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ParsedElem6Mapper {
    type Src = ParsedElem6Inner<'a>;
    type Dst = ParsedElem6<'a>;
    type RefSrc = ParsedElem6InnerRef<'a>;
}
type SpecParsedElem6CombinatorAlias1 = (SpecReftypeCombinator, SpecExprsCombinator);
type SpecParsedElem6CombinatorAlias2 = (SpecExprCombinator, SpecParsedElem6CombinatorAlias1);
type SpecParsedElem6CombinatorAlias3 = (SpecTableidxCombinator, SpecParsedElem6CombinatorAlias2);
pub struct SpecParsedElem6Combinator(pub SpecParsedElem6CombinatorAlias);

impl SpecCombinator for SpecParsedElem6Combinator {
    type Type = SpecParsedElem6;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecParsedElem6Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecParsedElem6CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecParsedElem6CombinatorAlias = Mapped<SpecParsedElem6CombinatorAlias3, ParsedElem6Mapper>;
type ParsedElem6CombinatorAlias1 = (ReftypeCombinator, ExprsCombinator);
type ParsedElem6CombinatorAlias2 = (ExprCombinator, ParsedElem6Combinator1);
type ParsedElem6CombinatorAlias3 = (TableidxCombinator, ParsedElem6Combinator2);
pub struct ParsedElem6Combinator1(pub ParsedElem6CombinatorAlias1);
impl View for ParsedElem6Combinator1 {
    type V = SpecParsedElem6CombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ParsedElem6Combinator1, ParsedElem6CombinatorAlias1);

pub struct ParsedElem6Combinator2(pub ParsedElem6CombinatorAlias2);
impl View for ParsedElem6Combinator2 {
    type V = SpecParsedElem6CombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ParsedElem6Combinator2, ParsedElem6CombinatorAlias2);

pub struct ParsedElem6Combinator3(pub ParsedElem6CombinatorAlias3);
impl View for ParsedElem6Combinator3 {
    type V = SpecParsedElem6CombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ParsedElem6Combinator3, ParsedElem6CombinatorAlias3);

pub struct ParsedElem6Combinator(pub ParsedElem6CombinatorAlias);

impl View for ParsedElem6Combinator {
    type V = SpecParsedElem6Combinator;
    open spec fn view(&self) -> Self::V { SpecParsedElem6Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ParsedElem6Combinator {
    type Type = ParsedElem6<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ParsedElem6CombinatorAlias = Mapped<ParsedElem6Combinator3, ParsedElem6Mapper>;


pub open spec fn spec_parsed_elem6() -> SpecParsedElem6Combinator {
    SpecParsedElem6Combinator(
    Mapped {
        inner: (spec_tableidx(), (spec_expr(), (spec_reftype(), spec_exprs()))),
        mapper: ParsedElem6Mapper,
    })
}

                
pub fn parsed_elem6<'a>() -> (o: ParsedElem6Combinator)
    ensures o@ == spec_parsed_elem6(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ParsedElem6Combinator(
    Mapped {
        inner: ParsedElem6Combinator3((tableidx(), ParsedElem6Combinator2((expr(), ParsedElem6Combinator1((reftype(), exprs())))))),
        mapper: ParsedElem6Mapper,
    });
    assert({
        &&& combinator@ == spec_parsed_elem6()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_parsed_elem6<'a>(input: &'a [u8]) -> (res: PResult<<ParsedElem6Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_parsed_elem6().spec_parse(input@) == Some((n as int, v@)),
        spec_parsed_elem6().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_parsed_elem6().spec_parse(input@) is None,
        spec_parsed_elem6().spec_parse(input@) is None ==> res is Err,
{
    let combinator = parsed_elem6();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_parsed_elem6<'a>(v: <ParsedElem6Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_parsed_elem6().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_parsed_elem6().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_parsed_elem6().spec_serialize(v@))
        },
{
    let combinator = parsed_elem6();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn parsed_elem6_len<'a>(v: <ParsedElem6Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_parsed_elem6().wf(v@),
        spec_parsed_elem6().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_parsed_elem6().spec_serialize(v@).len(),
{
    let combinator = parsed_elem6();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub enum SpecElem {
    Elem0(SpecParsedElem0),
    Elem1(SpecParsedElem1),
    Elem2(SpecParsedElem2),
    Elem3(SpecParsedElem3),
    Elem4(SpecParsedElem4),
    Elem5(SpecParsedElem5),
    Elem6(SpecParsedElem6),
    Elem7(SpecParsedElem7),
}

pub type SpecElemInner = Either<SpecParsedElem0, Either<SpecParsedElem1, Either<SpecParsedElem2, Either<SpecParsedElem3, Either<SpecParsedElem4, Either<SpecParsedElem5, Either<SpecParsedElem6, SpecParsedElem7>>>>>>>;

impl SpecFrom<SpecElem> for SpecElemInner {
    open spec fn spec_from(m: SpecElem) -> SpecElemInner {
        match m {
            SpecElem::Elem0(m) => Either::Left(m),
            SpecElem::Elem1(m) => Either::Right(Either::Left(m)),
            SpecElem::Elem2(m) => Either::Right(Either::Right(Either::Left(m))),
            SpecElem::Elem3(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            SpecElem::Elem4(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            SpecElem::Elem5(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))),
            SpecElem::Elem6(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))),
            SpecElem::Elem7(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m))))))),
        }
    }

}

                
impl SpecFrom<SpecElemInner> for SpecElem {
    open spec fn spec_from(m: SpecElemInner) -> SpecElem {
        match m {
            Either::Left(m) => SpecElem::Elem0(m),
            Either::Right(Either::Left(m)) => SpecElem::Elem1(m),
            Either::Right(Either::Right(Either::Left(m))) => SpecElem::Elem2(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => SpecElem::Elem3(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => SpecElem::Elem4(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))) => SpecElem::Elem5(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))) => SpecElem::Elem6(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m))))))) => SpecElem::Elem7(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Elem<'a> {
    Elem0(ParsedElem0<'a>),
    Elem1(ParsedElem1),
    Elem2(ParsedElem2<'a>),
    Elem3(ParsedElem3),
    Elem4(ParsedElem4<'a>),
    Elem5(ParsedElem5<'a>),
    Elem6(ParsedElem6<'a>),
    Elem7(ParsedElem7<'a>),
}

pub type ElemInner<'a> = Either<ParsedElem0<'a>, Either<ParsedElem1, Either<ParsedElem2<'a>, Either<ParsedElem3, Either<ParsedElem4<'a>, Either<ParsedElem5<'a>, Either<ParsedElem6<'a>, ParsedElem7<'a>>>>>>>>;

pub type ElemInnerRef<'a> = Either<&'a ParsedElem0<'a>, Either<&'a ParsedElem1, Either<&'a ParsedElem2<'a>, Either<&'a ParsedElem3, Either<&'a ParsedElem4<'a>, Either<&'a ParsedElem5<'a>, Either<&'a ParsedElem6<'a>, &'a ParsedElem7<'a>>>>>>>>;


impl<'a> View for Elem<'a> {
    type V = SpecElem;
    open spec fn view(&self) -> Self::V {
        match self {
            Elem::Elem0(m) => SpecElem::Elem0(m@),
            Elem::Elem1(m) => SpecElem::Elem1(m@),
            Elem::Elem2(m) => SpecElem::Elem2(m@),
            Elem::Elem3(m) => SpecElem::Elem3(m@),
            Elem::Elem4(m) => SpecElem::Elem4(m@),
            Elem::Elem5(m) => SpecElem::Elem5(m@),
            Elem::Elem6(m) => SpecElem::Elem6(m@),
            Elem::Elem7(m) => SpecElem::Elem7(m@),
        }
    }
}


impl<'a> From<&'a Elem<'a>> for ElemInnerRef<'a> {
    fn ex_from(m: &'a Elem<'a>) -> ElemInnerRef<'a> {
        match m {
            Elem::Elem0(m) => Either::Left(m),
            Elem::Elem1(m) => Either::Right(Either::Left(m)),
            Elem::Elem2(m) => Either::Right(Either::Right(Either::Left(m))),
            Elem::Elem3(m) => Either::Right(Either::Right(Either::Right(Either::Left(m)))),
            Elem::Elem4(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))),
            Elem::Elem5(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))),
            Elem::Elem6(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))),
            Elem::Elem7(m) => Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m))))))),
        }
    }

}

impl<'a> From<ElemInner<'a>> for Elem<'a> {
    fn ex_from(m: ElemInner<'a>) -> Elem<'a> {
        match m {
            Either::Left(m) => Elem::Elem0(m),
            Either::Right(Either::Left(m)) => Elem::Elem1(m),
            Either::Right(Either::Right(Either::Left(m))) => Elem::Elem2(m),
            Either::Right(Either::Right(Either::Right(Either::Left(m)))) => Elem::Elem3(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))) => Elem::Elem4(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m)))))) => Elem::Elem5(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Left(m))))))) => Elem::Elem6(m),
            Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(Either::Right(m))))))) => Elem::Elem7(m),
        }
    }
    
}


pub struct ElemMapper;
impl View for ElemMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ElemMapper {
    type Src = SpecElemInner;
    type Dst = SpecElem;
}
impl SpecIsoProof for ElemMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ElemMapper {
    type Src = ElemInner<'a>;
    type Dst = Elem<'a>;
    type RefSrc = ElemInnerRef<'a>;
}

pub const ELEMELEM0_0_FRONT_CONST: u64 = 0;

pub const ELEMELEM1_0_FRONT_CONST: u64 = 1;

pub const ELEMELEM2_0_FRONT_CONST: u64 = 2;

pub const ELEMELEM3_0_FRONT_CONST: u64 = 3;

pub const ELEMELEM4_0_FRONT_CONST: u64 = 4;

pub const ELEMELEM5_0_FRONT_CONST: u64 = 5;

pub const ELEMELEM6_0_FRONT_CONST: u64 = 6;

pub const ELEMELEM7_0_FRONT_CONST: u64 = 7;

type SpecElemCombinatorAlias1 = Choice<Preceded<Tag<UnsignedLEB128, u64>, SpecParsedElem6Combinator>, Preceded<Tag<UnsignedLEB128, u64>, SpecParsedElem7Combinator>>;
type SpecElemCombinatorAlias2 = Choice<Preceded<Tag<UnsignedLEB128, u64>, SpecParsedElem5Combinator>, SpecElemCombinatorAlias1>;
type SpecElemCombinatorAlias3 = Choice<Preceded<Tag<UnsignedLEB128, u64>, SpecParsedElem4Combinator>, SpecElemCombinatorAlias2>;
type SpecElemCombinatorAlias4 = Choice<Preceded<Tag<UnsignedLEB128, u64>, SpecParsedElem3Combinator>, SpecElemCombinatorAlias3>;
type SpecElemCombinatorAlias5 = Choice<Preceded<Tag<UnsignedLEB128, u64>, SpecParsedElem2Combinator>, SpecElemCombinatorAlias4>;
type SpecElemCombinatorAlias6 = Choice<Preceded<Tag<UnsignedLEB128, u64>, SpecParsedElem1Combinator>, SpecElemCombinatorAlias5>;
type SpecElemCombinatorAlias7 = Choice<Preceded<Tag<UnsignedLEB128, u64>, SpecParsedElem0Combinator>, SpecElemCombinatorAlias6>;
pub struct SpecElemCombinator(pub SpecElemCombinatorAlias);

impl SpecCombinator for SpecElemCombinator {
    type Type = SpecElem;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecElemCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecElemCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecElemCombinatorAlias = Mapped<SpecElemCombinatorAlias7, ElemMapper>;








type ElemCombinatorAlias1 = Choice<Preceded<Tag<UnsignedLEB128, u64>, ParsedElem6Combinator>, Preceded<Tag<UnsignedLEB128, u64>, ParsedElem7Combinator>>;
type ElemCombinatorAlias2 = Choice<Preceded<Tag<UnsignedLEB128, u64>, ParsedElem5Combinator>, ElemCombinator1>;
type ElemCombinatorAlias3 = Choice<Preceded<Tag<UnsignedLEB128, u64>, ParsedElem4Combinator>, ElemCombinator2>;
type ElemCombinatorAlias4 = Choice<Preceded<Tag<UnsignedLEB128, u64>, ParsedElem3Combinator>, ElemCombinator3>;
type ElemCombinatorAlias5 = Choice<Preceded<Tag<UnsignedLEB128, u64>, ParsedElem2Combinator>, ElemCombinator4>;
type ElemCombinatorAlias6 = Choice<Preceded<Tag<UnsignedLEB128, u64>, ParsedElem1Combinator>, ElemCombinator5>;
type ElemCombinatorAlias7 = Choice<Preceded<Tag<UnsignedLEB128, u64>, ParsedElem0Combinator>, ElemCombinator6>;
pub struct ElemCombinator1(pub ElemCombinatorAlias1);
impl View for ElemCombinator1 {
    type V = SpecElemCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ElemCombinator1, ElemCombinatorAlias1);

pub struct ElemCombinator2(pub ElemCombinatorAlias2);
impl View for ElemCombinator2 {
    type V = SpecElemCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ElemCombinator2, ElemCombinatorAlias2);

pub struct ElemCombinator3(pub ElemCombinatorAlias3);
impl View for ElemCombinator3 {
    type V = SpecElemCombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ElemCombinator3, ElemCombinatorAlias3);

pub struct ElemCombinator4(pub ElemCombinatorAlias4);
impl View for ElemCombinator4 {
    type V = SpecElemCombinatorAlias4;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ElemCombinator4, ElemCombinatorAlias4);

pub struct ElemCombinator5(pub ElemCombinatorAlias5);
impl View for ElemCombinator5 {
    type V = SpecElemCombinatorAlias5;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ElemCombinator5, ElemCombinatorAlias5);

pub struct ElemCombinator6(pub ElemCombinatorAlias6);
impl View for ElemCombinator6 {
    type V = SpecElemCombinatorAlias6;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ElemCombinator6, ElemCombinatorAlias6);

pub struct ElemCombinator7(pub ElemCombinatorAlias7);
impl View for ElemCombinator7 {
    type V = SpecElemCombinatorAlias7;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ElemCombinator7, ElemCombinatorAlias7);

pub struct ElemCombinator(pub ElemCombinatorAlias);

impl View for ElemCombinator {
    type V = SpecElemCombinator;
    open spec fn view(&self) -> Self::V { SpecElemCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ElemCombinator {
    type Type = Elem<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ElemCombinatorAlias = Mapped<ElemCombinator7, ElemMapper>;


pub open spec fn spec_elem() -> SpecElemCombinator {
    SpecElemCombinator(Mapped { inner: Choice(Preceded(Tag::spec_new(UnsignedLEB128, ELEMELEM0_0_FRONT_CONST), spec_parsed_elem0()), Choice(Preceded(Tag::spec_new(UnsignedLEB128, ELEMELEM1_0_FRONT_CONST), spec_parsed_elem1()), Choice(Preceded(Tag::spec_new(UnsignedLEB128, ELEMELEM2_0_FRONT_CONST), spec_parsed_elem2()), Choice(Preceded(Tag::spec_new(UnsignedLEB128, ELEMELEM3_0_FRONT_CONST), spec_parsed_elem3()), Choice(Preceded(Tag::spec_new(UnsignedLEB128, ELEMELEM4_0_FRONT_CONST), spec_parsed_elem4()), Choice(Preceded(Tag::spec_new(UnsignedLEB128, ELEMELEM5_0_FRONT_CONST), spec_parsed_elem5()), Choice(Preceded(Tag::spec_new(UnsignedLEB128, ELEMELEM6_0_FRONT_CONST), spec_parsed_elem6()), Preceded(Tag::spec_new(UnsignedLEB128, ELEMELEM7_0_FRONT_CONST), spec_parsed_elem7())))))))), mapper: ElemMapper })
}

                
pub fn elem<'a>() -> (o: ElemCombinator)
    ensures o@ == spec_elem(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ElemCombinator(Mapped { inner: ElemCombinator7(Choice::new(Preceded(Tag::new(UnsignedLEB128, ELEMELEM0_0_FRONT_CONST), parsed_elem0()), ElemCombinator6(Choice::new(Preceded(Tag::new(UnsignedLEB128, ELEMELEM1_0_FRONT_CONST), parsed_elem1()), ElemCombinator5(Choice::new(Preceded(Tag::new(UnsignedLEB128, ELEMELEM2_0_FRONT_CONST), parsed_elem2()), ElemCombinator4(Choice::new(Preceded(Tag::new(UnsignedLEB128, ELEMELEM3_0_FRONT_CONST), parsed_elem3()), ElemCombinator3(Choice::new(Preceded(Tag::new(UnsignedLEB128, ELEMELEM4_0_FRONT_CONST), parsed_elem4()), ElemCombinator2(Choice::new(Preceded(Tag::new(UnsignedLEB128, ELEMELEM5_0_FRONT_CONST), parsed_elem5()), ElemCombinator1(Choice::new(Preceded(Tag::new(UnsignedLEB128, ELEMELEM6_0_FRONT_CONST), parsed_elem6()), Preceded(Tag::new(UnsignedLEB128, ELEMELEM7_0_FRONT_CONST), parsed_elem7()))))))))))))))), mapper: ElemMapper });
    assert({
        &&& combinator@ == spec_elem()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_elem<'a>(input: &'a [u8]) -> (res: PResult<<ElemCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_elem().spec_parse(input@) == Some((n as int, v@)),
        spec_elem().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_elem().spec_parse(input@) is None,
        spec_elem().spec_parse(input@) is None ==> res is Err,
{
    let combinator = elem();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_elem<'a>(v: <ElemCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_elem().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_elem().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_elem().spec_serialize(v@))
        },
{
    let combinator = elem();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn elem_len<'a>(v: <ElemCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_elem().wf(v@),
        spec_elem().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_elem().spec_serialize(v@).len(),
{
    let combinator = elem();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecElemsecContent {
    pub l: u64,
    pub v: Seq<SpecElem>,
}

pub type SpecElemsecContentInner = (u64, Seq<SpecElem>);


impl SpecFrom<SpecElemsecContent> for SpecElemsecContentInner {
    open spec fn spec_from(m: SpecElemsecContent) -> SpecElemsecContentInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecElemsecContentInner> for SpecElemsecContent {
    open spec fn spec_from(m: SpecElemsecContentInner) -> SpecElemsecContent {
        let (l, v) = m;
        SpecElemsecContent { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ElemsecContent<'a> {
    pub l: u64,
    pub v: RepeatResult<Elem<'a>>,
}

impl View for ElemsecContent<'_> {
    type V = SpecElemsecContent;

    open spec fn view(&self) -> Self::V {
        SpecElemsecContent {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type ElemsecContentInner<'a> = (u64, RepeatResult<Elem<'a>>);

pub type ElemsecContentInnerRef<'a> = (&'a u64, &'a RepeatResult<Elem<'a>>);
impl<'a> From<&'a ElemsecContent<'a>> for ElemsecContentInnerRef<'a> {
    fn ex_from(m: &'a ElemsecContent) -> ElemsecContentInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl<'a> From<ElemsecContentInner<'a>> for ElemsecContent<'a> {
    fn ex_from(m: ElemsecContentInner) -> ElemsecContent {
        let (l, v) = m;
        ElemsecContent { l, v }
    }
}

pub struct ElemsecContentMapper;
impl View for ElemsecContentMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ElemsecContentMapper {
    type Src = SpecElemsecContentInner;
    type Dst = SpecElemsecContent;
}
impl SpecIsoProof for ElemsecContentMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ElemsecContentMapper {
    type Src = ElemsecContentInner<'a>;
    type Dst = ElemsecContent<'a>;
    type RefSrc = ElemsecContentInnerRef<'a>;
}

pub struct SpecElemsecContentCombinator(pub SpecElemsecContentCombinatorAlias);

impl SpecCombinator for SpecElemsecContentCombinator {
    type Type = SpecElemsecContent;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecElemsecContentCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecElemsecContentCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecElemsecContentCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecElemCombinator>>, ElemsecContentMapper>;

pub struct ElemsecContentCombinator(pub ElemsecContentCombinatorAlias);

impl View for ElemsecContentCombinator {
    type V = SpecElemsecContentCombinator;
    open spec fn view(&self) -> Self::V { SpecElemsecContentCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ElemsecContentCombinator {
    type Type = ElemsecContent<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ElemsecContentCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<ElemCombinator>, ElemsecContentCont0>, ElemsecContentMapper>;


pub open spec fn spec_elemsec_content() -> SpecElemsecContentCombinator {
    SpecElemsecContentCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_elemsec_content_cont0(deps)),
        mapper: ElemsecContentMapper,
    })
}

pub open spec fn spec_elemsec_content_cont0(deps: u64) -> RepeatN<SpecElemCombinator> {
    let l = deps;
    RepeatN(spec_elem(), l.spec_into())
}

impl View for ElemsecContentCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecElemCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_elemsec_content_cont0(deps)
        }
    }
}

                
pub fn elemsec_content<'a>() -> (o: ElemsecContentCombinator)
    ensures o@ == spec_elemsec_content(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ElemsecContentCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, ElemsecContentCont0),
        mapper: ElemsecContentMapper,
    });
    assert({
        &&& combinator@ == spec_elemsec_content()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_elemsec_content<'a>(input: &'a [u8]) -> (res: PResult<<ElemsecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_elemsec_content().spec_parse(input@) == Some((n as int, v@)),
        spec_elemsec_content().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_elemsec_content().spec_parse(input@) is None,
        spec_elemsec_content().spec_parse(input@) is None ==> res is Err,
{
    let combinator = elemsec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_elemsec_content<'a>(v: <ElemsecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_elemsec_content().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_elemsec_content().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_elemsec_content().spec_serialize(v@))
        },
{
    let combinator = elemsec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn elemsec_content_len<'a>(v: <ElemsecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_elemsec_content().wf(v@),
        spec_elemsec_content().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_elemsec_content().spec_serialize(v@).len(),
{
    let combinator = elemsec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct ElemsecContentCont0;
type ElemsecContentCont0Type<'a, 'b> = &'b u64;
type ElemsecContentCont0SType<'a, 'x> = &'x u64;
type ElemsecContentCont0Input<'a, 'b, 'x> = POrSType<ElemsecContentCont0Type<'a, 'b>, ElemsecContentCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<ElemsecContentCont0Input<'a, 'b, 'x>> for ElemsecContentCont0 {
    type Output = RepeatN<ElemCombinator>;

    open spec fn requires(&self, deps: ElemsecContentCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: ElemsecContentCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_elemsec_content_cont0(deps@)
    }

    fn apply(&self, deps: ElemsecContentCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(elem(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(elem(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecElemsec {
    pub size: u64,
    pub cont: SpecElemsecContent,
}

pub type SpecElemsecInner = (u64, SpecElemsecContent);


impl SpecFrom<SpecElemsec> for SpecElemsecInner {
    open spec fn spec_from(m: SpecElemsec) -> SpecElemsecInner {
        (m.size, m.cont)
    }
}

impl SpecFrom<SpecElemsecInner> for SpecElemsec {
    open spec fn spec_from(m: SpecElemsecInner) -> SpecElemsec {
        let (size, cont) = m;
        SpecElemsec { size, cont }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Elemsec<'a> {
    pub size: u64,
    pub cont: ElemsecContent<'a>,
}

impl View for Elemsec<'_> {
    type V = SpecElemsec;

    open spec fn view(&self) -> Self::V {
        SpecElemsec {
            size: self.size@,
            cont: self.cont@,
        }
    }
}
pub type ElemsecInner<'a> = (u64, ElemsecContent<'a>);

pub type ElemsecInnerRef<'a> = (&'a u64, &'a ElemsecContent<'a>);
impl<'a> From<&'a Elemsec<'a>> for ElemsecInnerRef<'a> {
    fn ex_from(m: &'a Elemsec) -> ElemsecInnerRef<'a> {
        (&m.size, &m.cont)
    }
}

impl<'a> From<ElemsecInner<'a>> for Elemsec<'a> {
    fn ex_from(m: ElemsecInner) -> Elemsec {
        let (size, cont) = m;
        Elemsec { size, cont }
    }
}

pub struct ElemsecMapper;
impl View for ElemsecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ElemsecMapper {
    type Src = SpecElemsecInner;
    type Dst = SpecElemsec;
}
impl SpecIsoProof for ElemsecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ElemsecMapper {
    type Src = ElemsecInner<'a>;
    type Dst = Elemsec<'a>;
    type RefSrc = ElemsecInnerRef<'a>;
}

pub struct SpecElemsecCombinator(pub SpecElemsecCombinatorAlias);

impl SpecCombinator for SpecElemsecCombinator {
    type Type = SpecElemsec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecElemsecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecElemsecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecElemsecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, SpecElemsecContentCombinator>>, ElemsecMapper>;

pub struct ElemsecCombinator(pub ElemsecCombinatorAlias);

impl View for ElemsecCombinator {
    type V = SpecElemsecCombinator;
    open spec fn view(&self) -> Self::V { SpecElemsecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ElemsecCombinator {
    type Type = Elemsec<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ElemsecCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, ElemsecContentCombinator>, ElemsecCont0>, ElemsecMapper>;


pub open spec fn spec_elemsec() -> SpecElemsecCombinator {
    SpecElemsecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_elemsec_cont0(deps)),
        mapper: ElemsecMapper,
    })
}

pub open spec fn spec_elemsec_cont0(deps: u64) -> AndThen<bytes::Variable, SpecElemsecContentCombinator> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), spec_elemsec_content())
}

impl View for ElemsecCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, SpecElemsecContentCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_elemsec_cont0(deps)
        }
    }
}

                
pub fn elemsec<'a>() -> (o: ElemsecCombinator)
    ensures o@ == spec_elemsec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ElemsecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, ElemsecCont0),
        mapper: ElemsecMapper,
    });
    assert({
        &&& combinator@ == spec_elemsec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_elemsec<'a>(input: &'a [u8]) -> (res: PResult<<ElemsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_elemsec().spec_parse(input@) == Some((n as int, v@)),
        spec_elemsec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_elemsec().spec_parse(input@) is None,
        spec_elemsec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = elemsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_elemsec<'a>(v: <ElemsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_elemsec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_elemsec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_elemsec().spec_serialize(v@))
        },
{
    let combinator = elemsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn elemsec_len<'a>(v: <ElemsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_elemsec().wf(v@),
        spec_elemsec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_elemsec().spec_serialize(v@).len(),
{
    let combinator = elemsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct ElemsecCont0;
type ElemsecCont0Type<'a, 'b> = &'b u64;
type ElemsecCont0SType<'a, 'x> = &'x u64;
type ElemsecCont0Input<'a, 'b, 'x> = POrSType<ElemsecCont0Type<'a, 'b>, ElemsecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<ElemsecCont0Input<'a, 'b, 'x>> for ElemsecCont0 {
    type Output = AndThen<bytes::Variable, ElemsecContentCombinator>;

    open spec fn requires(&self, deps: ElemsecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: ElemsecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_elemsec_cont0(deps@)
    }

    fn apply(&self, deps: ElemsecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), elemsec_content())
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), elemsec_content())
            }
        }
    }
}
                

pub struct SpecTypesec {
    pub size: u64,
    pub cont: SpecTypesecContent,
}

pub type SpecTypesecInner = (u64, SpecTypesecContent);


impl SpecFrom<SpecTypesec> for SpecTypesecInner {
    open spec fn spec_from(m: SpecTypesec) -> SpecTypesecInner {
        (m.size, m.cont)
    }
}

impl SpecFrom<SpecTypesecInner> for SpecTypesec {
    open spec fn spec_from(m: SpecTypesecInner) -> SpecTypesec {
        let (size, cont) = m;
        SpecTypesec { size, cont }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Typesec {
    pub size: u64,
    pub cont: TypesecContent,
}

impl View for Typesec {
    type V = SpecTypesec;

    open spec fn view(&self) -> Self::V {
        SpecTypesec {
            size: self.size@,
            cont: self.cont@,
        }
    }
}
pub type TypesecInner = (u64, TypesecContent);

pub type TypesecInnerRef<'a> = (&'a u64, &'a TypesecContent);
impl<'a> From<&'a Typesec> for TypesecInnerRef<'a> {
    fn ex_from(m: &'a Typesec) -> TypesecInnerRef<'a> {
        (&m.size, &m.cont)
    }
}

impl From<TypesecInner> for Typesec {
    fn ex_from(m: TypesecInner) -> Typesec {
        let (size, cont) = m;
        Typesec { size, cont }
    }
}

pub struct TypesecMapper;
impl View for TypesecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for TypesecMapper {
    type Src = SpecTypesecInner;
    type Dst = SpecTypesec;
}
impl SpecIsoProof for TypesecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for TypesecMapper {
    type Src = TypesecInner;
    type Dst = Typesec;
    type RefSrc = TypesecInnerRef<'a>;
}

pub struct SpecTypesecCombinator(pub SpecTypesecCombinatorAlias);

impl SpecCombinator for SpecTypesecCombinator {
    type Type = SpecTypesec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecTypesecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecTypesecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecTypesecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, SpecTypesecContentCombinator>>, TypesecMapper>;

pub struct TypesecCombinator(pub TypesecCombinatorAlias);

impl View for TypesecCombinator {
    type V = SpecTypesecCombinator;
    open spec fn view(&self) -> Self::V { SpecTypesecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for TypesecCombinator {
    type Type = Typesec;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type TypesecCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, TypesecContentCombinator>, TypesecCont0>, TypesecMapper>;


pub open spec fn spec_typesec() -> SpecTypesecCombinator {
    SpecTypesecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_typesec_cont0(deps)),
        mapper: TypesecMapper,
    })
}

pub open spec fn spec_typesec_cont0(deps: u64) -> AndThen<bytes::Variable, SpecTypesecContentCombinator> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), spec_typesec_content())
}

impl View for TypesecCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, SpecTypesecContentCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_typesec_cont0(deps)
        }
    }
}

                
pub fn typesec<'a>() -> (o: TypesecCombinator)
    ensures o@ == spec_typesec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = TypesecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, TypesecCont0),
        mapper: TypesecMapper,
    });
    assert({
        &&& combinator@ == spec_typesec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_typesec<'a>(input: &'a [u8]) -> (res: PResult<<TypesecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_typesec().spec_parse(input@) == Some((n as int, v@)),
        spec_typesec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_typesec().spec_parse(input@) is None,
        spec_typesec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = typesec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_typesec<'a>(v: <TypesecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_typesec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_typesec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_typesec().spec_serialize(v@))
        },
{
    let combinator = typesec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn typesec_len<'a>(v: <TypesecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_typesec().wf(v@),
        spec_typesec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_typesec().spec_serialize(v@).len(),
{
    let combinator = typesec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct TypesecCont0;
type TypesecCont0Type<'a, 'b> = &'b u64;
type TypesecCont0SType<'a, 'x> = &'x u64;
type TypesecCont0Input<'a, 'b, 'x> = POrSType<TypesecCont0Type<'a, 'b>, TypesecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<TypesecCont0Input<'a, 'b, 'x>> for TypesecCont0 {
    type Output = AndThen<bytes::Variable, TypesecContentCombinator>;

    open spec fn requires(&self, deps: TypesecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: TypesecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_typesec_cont0(deps@)
    }

    fn apply(&self, deps: TypesecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), typesec_content())
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), typesec_content())
            }
        }
    }
}
                

pub struct SpecStart {
    pub func: SpecFuncidx,
}

pub type SpecStartInner = SpecFuncidx;


impl SpecFrom<SpecStart> for SpecStartInner {
    open spec fn spec_from(m: SpecStart) -> SpecStartInner {
        m.func
    }
}

impl SpecFrom<SpecStartInner> for SpecStart {
    open spec fn spec_from(m: SpecStartInner) -> SpecStart {
        let func = m;
        SpecStart { func }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Start {
    pub func: Funcidx,
}

impl View for Start {
    type V = SpecStart;

    open spec fn view(&self) -> Self::V {
        SpecStart {
            func: self.func@,
        }
    }
}
pub type StartInner = Funcidx;

pub type StartInnerRef<'a> = &'a Funcidx;
impl<'a> From<&'a Start> for StartInnerRef<'a> {
    fn ex_from(m: &'a Start) -> StartInnerRef<'a> {
        &m.func
    }
}

impl From<StartInner> for Start {
    fn ex_from(m: StartInner) -> Start {
        let func = m;
        Start { func }
    }
}

pub struct StartMapper;
impl View for StartMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for StartMapper {
    type Src = SpecStartInner;
    type Dst = SpecStart;
}
impl SpecIsoProof for StartMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for StartMapper {
    type Src = StartInner;
    type Dst = Start;
    type RefSrc = StartInnerRef<'a>;
}

pub struct SpecStartCombinator(pub SpecStartCombinatorAlias);

impl SpecCombinator for SpecStartCombinator {
    type Type = SpecStart;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecStartCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecStartCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecStartCombinatorAlias = Mapped<SpecFuncidxCombinator, StartMapper>;

pub struct StartCombinator(pub StartCombinatorAlias);

impl View for StartCombinator {
    type V = SpecStartCombinator;
    open spec fn view(&self) -> Self::V { SpecStartCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for StartCombinator {
    type Type = Start;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type StartCombinatorAlias = Mapped<FuncidxCombinator, StartMapper>;


pub open spec fn spec_start() -> SpecStartCombinator {
    SpecStartCombinator(
    Mapped {
        inner: spec_funcidx(),
        mapper: StartMapper,
    })
}

                
pub fn start<'a>() -> (o: StartCombinator)
    ensures o@ == spec_start(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = StartCombinator(
    Mapped {
        inner: funcidx(),
        mapper: StartMapper,
    });
    assert({
        &&& combinator@ == spec_start()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_start<'a>(input: &'a [u8]) -> (res: PResult<<StartCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_start().spec_parse(input@) == Some((n as int, v@)),
        spec_start().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_start().spec_parse(input@) is None,
        spec_start().spec_parse(input@) is None ==> res is Err,
{
    let combinator = start();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_start<'a>(v: <StartCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_start().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_start().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_start().spec_serialize(v@))
        },
{
    let combinator = start();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn start_len<'a>(v: <StartCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_start().wf(v@),
        spec_start().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_start().spec_serialize(v@).len(),
{
    let combinator = start();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecStartsec {
    pub size: u64,
    pub cont: SpecStart,
}

pub type SpecStartsecInner = (u64, SpecStart);


impl SpecFrom<SpecStartsec> for SpecStartsecInner {
    open spec fn spec_from(m: SpecStartsec) -> SpecStartsecInner {
        (m.size, m.cont)
    }
}

impl SpecFrom<SpecStartsecInner> for SpecStartsec {
    open spec fn spec_from(m: SpecStartsecInner) -> SpecStartsec {
        let (size, cont) = m;
        SpecStartsec { size, cont }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Startsec {
    pub size: u64,
    pub cont: Start,
}

impl View for Startsec {
    type V = SpecStartsec;

    open spec fn view(&self) -> Self::V {
        SpecStartsec {
            size: self.size@,
            cont: self.cont@,
        }
    }
}
pub type StartsecInner = (u64, Start);

pub type StartsecInnerRef<'a> = (&'a u64, &'a Start);
impl<'a> From<&'a Startsec> for StartsecInnerRef<'a> {
    fn ex_from(m: &'a Startsec) -> StartsecInnerRef<'a> {
        (&m.size, &m.cont)
    }
}

impl From<StartsecInner> for Startsec {
    fn ex_from(m: StartsecInner) -> Startsec {
        let (size, cont) = m;
        Startsec { size, cont }
    }
}

pub struct StartsecMapper;
impl View for StartsecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for StartsecMapper {
    type Src = SpecStartsecInner;
    type Dst = SpecStartsec;
}
impl SpecIsoProof for StartsecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for StartsecMapper {
    type Src = StartsecInner;
    type Dst = Startsec;
    type RefSrc = StartsecInnerRef<'a>;
}

pub struct SpecStartsecCombinator(pub SpecStartsecCombinatorAlias);

impl SpecCombinator for SpecStartsecCombinator {
    type Type = SpecStartsec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecStartsecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecStartsecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecStartsecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, SpecStartCombinator>>, StartsecMapper>;

pub struct StartsecCombinator(pub StartsecCombinatorAlias);

impl View for StartsecCombinator {
    type V = SpecStartsecCombinator;
    open spec fn view(&self) -> Self::V { SpecStartsecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for StartsecCombinator {
    type Type = Startsec;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type StartsecCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, StartCombinator>, StartsecCont0>, StartsecMapper>;


pub open spec fn spec_startsec() -> SpecStartsecCombinator {
    SpecStartsecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_startsec_cont0(deps)),
        mapper: StartsecMapper,
    })
}

pub open spec fn spec_startsec_cont0(deps: u64) -> AndThen<bytes::Variable, SpecStartCombinator> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), spec_start())
}

impl View for StartsecCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, SpecStartCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_startsec_cont0(deps)
        }
    }
}

                
pub fn startsec<'a>() -> (o: StartsecCombinator)
    ensures o@ == spec_startsec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = StartsecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, StartsecCont0),
        mapper: StartsecMapper,
    });
    assert({
        &&& combinator@ == spec_startsec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_startsec<'a>(input: &'a [u8]) -> (res: PResult<<StartsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_startsec().spec_parse(input@) == Some((n as int, v@)),
        spec_startsec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_startsec().spec_parse(input@) is None,
        spec_startsec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = startsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_startsec<'a>(v: <StartsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_startsec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_startsec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_startsec().spec_serialize(v@))
        },
{
    let combinator = startsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn startsec_len<'a>(v: <StartsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_startsec().wf(v@),
        spec_startsec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_startsec().spec_serialize(v@).len(),
{
    let combinator = startsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct StartsecCont0;
type StartsecCont0Type<'a, 'b> = &'b u64;
type StartsecCont0SType<'a, 'x> = &'x u64;
type StartsecCont0Input<'a, 'b, 'x> = POrSType<StartsecCont0Type<'a, 'b>, StartsecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<StartsecCont0Input<'a, 'b, 'x>> for StartsecCont0 {
    type Output = AndThen<bytes::Variable, StartCombinator>;

    open spec fn requires(&self, deps: StartsecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: StartsecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_startsec_cont0(deps@)
    }

    fn apply(&self, deps: StartsecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), start())
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), start())
            }
        }
    }
}
                

pub struct SpecActiveData0 {
    pub offset: SpecExpr,
    pub init: SpecByteVec,
}

pub type SpecActiveData0Inner = (SpecExpr, SpecByteVec);


impl SpecFrom<SpecActiveData0> for SpecActiveData0Inner {
    open spec fn spec_from(m: SpecActiveData0) -> SpecActiveData0Inner {
        (m.offset, m.init)
    }
}

impl SpecFrom<SpecActiveData0Inner> for SpecActiveData0 {
    open spec fn spec_from(m: SpecActiveData0Inner) -> SpecActiveData0 {
        let (offset, init) = m;
        SpecActiveData0 { offset, init }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct ActiveData0<'a> {
    pub offset: Expr<'a>,
    pub init: ByteVec,
}

impl View for ActiveData0<'_> {
    type V = SpecActiveData0;

    open spec fn view(&self) -> Self::V {
        SpecActiveData0 {
            offset: self.offset@,
            init: self.init@,
        }
    }
}
pub type ActiveData0Inner<'a> = (Expr<'a>, ByteVec);

pub type ActiveData0InnerRef<'a> = (&'a Expr<'a>, &'a ByteVec);
impl<'a> From<&'a ActiveData0<'a>> for ActiveData0InnerRef<'a> {
    fn ex_from(m: &'a ActiveData0) -> ActiveData0InnerRef<'a> {
        (&m.offset, &m.init)
    }
}

impl<'a> From<ActiveData0Inner<'a>> for ActiveData0<'a> {
    fn ex_from(m: ActiveData0Inner) -> ActiveData0 {
        let (offset, init) = m;
        ActiveData0 { offset, init }
    }
}

pub struct ActiveData0Mapper;
impl View for ActiveData0Mapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ActiveData0Mapper {
    type Src = SpecActiveData0Inner;
    type Dst = SpecActiveData0;
}
impl SpecIsoProof for ActiveData0Mapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ActiveData0Mapper {
    type Src = ActiveData0Inner<'a>;
    type Dst = ActiveData0<'a>;
    type RefSrc = ActiveData0InnerRef<'a>;
}
type SpecActiveData0CombinatorAlias1 = (SpecExprCombinator, SpecByteVecCombinator);
pub struct SpecActiveData0Combinator(pub SpecActiveData0CombinatorAlias);

impl SpecCombinator for SpecActiveData0Combinator {
    type Type = SpecActiveData0;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecActiveData0Combinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecActiveData0CombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecActiveData0CombinatorAlias = Mapped<SpecActiveData0CombinatorAlias1, ActiveData0Mapper>;
type ActiveData0CombinatorAlias1 = (ExprCombinator, ByteVecCombinator);
pub struct ActiveData0Combinator1(pub ActiveData0CombinatorAlias1);
impl View for ActiveData0Combinator1 {
    type V = SpecActiveData0CombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ActiveData0Combinator1, ActiveData0CombinatorAlias1);

pub struct ActiveData0Combinator(pub ActiveData0CombinatorAlias);

impl View for ActiveData0Combinator {
    type V = SpecActiveData0Combinator;
    open spec fn view(&self) -> Self::V { SpecActiveData0Combinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ActiveData0Combinator {
    type Type = ActiveData0<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ActiveData0CombinatorAlias = Mapped<ActiveData0Combinator1, ActiveData0Mapper>;


pub open spec fn spec_active_data0() -> SpecActiveData0Combinator {
    SpecActiveData0Combinator(
    Mapped {
        inner: (spec_expr(), spec_byte_vec()),
        mapper: ActiveData0Mapper,
    })
}

                
pub fn active_data0<'a>() -> (o: ActiveData0Combinator)
    ensures o@ == spec_active_data0(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ActiveData0Combinator(
    Mapped {
        inner: ActiveData0Combinator1((expr(), byte_vec())),
        mapper: ActiveData0Mapper,
    });
    assert({
        &&& combinator@ == spec_active_data0()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_active_data0<'a>(input: &'a [u8]) -> (res: PResult<<ActiveData0Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_active_data0().spec_parse(input@) == Some((n as int, v@)),
        spec_active_data0().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_active_data0().spec_parse(input@) is None,
        spec_active_data0().spec_parse(input@) is None ==> res is Err,
{
    let combinator = active_data0();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_active_data0<'a>(v: <ActiveData0Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_active_data0().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_active_data0().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_active_data0().spec_serialize(v@))
        },
{
    let combinator = active_data0();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn active_data0_len<'a>(v: <ActiveData0Combinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_active_data0().wf(v@),
        spec_active_data0().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_active_data0().spec_serialize(v@).len(),
{
    let combinator = active_data0();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecDatacountsec {
    pub size: u64,
    pub cont: u64,
}

pub type SpecDatacountsecInner = (u64, u64);


impl SpecFrom<SpecDatacountsec> for SpecDatacountsecInner {
    open spec fn spec_from(m: SpecDatacountsec) -> SpecDatacountsecInner {
        (m.size, m.cont)
    }
}

impl SpecFrom<SpecDatacountsecInner> for SpecDatacountsec {
    open spec fn spec_from(m: SpecDatacountsecInner) -> SpecDatacountsec {
        let (size, cont) = m;
        SpecDatacountsec { size, cont }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Datacountsec {
    pub size: u64,
    pub cont: u64,
}

impl View for Datacountsec {
    type V = SpecDatacountsec;

    open spec fn view(&self) -> Self::V {
        SpecDatacountsec {
            size: self.size@,
            cont: self.cont@,
        }
    }
}
pub type DatacountsecInner = (u64, u64);

pub type DatacountsecInnerRef<'a> = (&'a u64, &'a u64);
impl<'a> From<&'a Datacountsec> for DatacountsecInnerRef<'a> {
    fn ex_from(m: &'a Datacountsec) -> DatacountsecInnerRef<'a> {
        (&m.size, &m.cont)
    }
}

impl From<DatacountsecInner> for Datacountsec {
    fn ex_from(m: DatacountsecInner) -> Datacountsec {
        let (size, cont) = m;
        Datacountsec { size, cont }
    }
}

pub struct DatacountsecMapper;
impl View for DatacountsecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for DatacountsecMapper {
    type Src = SpecDatacountsecInner;
    type Dst = SpecDatacountsec;
}
impl SpecIsoProof for DatacountsecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for DatacountsecMapper {
    type Src = DatacountsecInner;
    type Dst = Datacountsec;
    type RefSrc = DatacountsecInnerRef<'a>;
}

pub struct SpecDatacountsecCombinator(pub SpecDatacountsecCombinatorAlias);

impl SpecCombinator for SpecDatacountsecCombinator {
    type Type = SpecDatacountsec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecDatacountsecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecDatacountsecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecDatacountsecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, UnsignedLEB128>>, DatacountsecMapper>;

pub struct DatacountsecCombinator(pub DatacountsecCombinatorAlias);

impl View for DatacountsecCombinator {
    type V = SpecDatacountsecCombinator;
    open spec fn view(&self) -> Self::V { SpecDatacountsecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for DatacountsecCombinator {
    type Type = Datacountsec;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type DatacountsecCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, UnsignedLEB128>, DatacountsecCont0>, DatacountsecMapper>;


pub open spec fn spec_datacountsec() -> SpecDatacountsecCombinator {
    SpecDatacountsecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_datacountsec_cont0(deps)),
        mapper: DatacountsecMapper,
    })
}

pub open spec fn spec_datacountsec_cont0(deps: u64) -> AndThen<bytes::Variable, UnsignedLEB128> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), UnsignedLEB128)
}

impl View for DatacountsecCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, UnsignedLEB128>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_datacountsec_cont0(deps)
        }
    }
}

                
pub fn datacountsec<'a>() -> (o: DatacountsecCombinator)
    ensures o@ == spec_datacountsec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = DatacountsecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, DatacountsecCont0),
        mapper: DatacountsecMapper,
    });
    assert({
        &&& combinator@ == spec_datacountsec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_datacountsec<'a>(input: &'a [u8]) -> (res: PResult<<DatacountsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_datacountsec().spec_parse(input@) == Some((n as int, v@)),
        spec_datacountsec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_datacountsec().spec_parse(input@) is None,
        spec_datacountsec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = datacountsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_datacountsec<'a>(v: <DatacountsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_datacountsec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_datacountsec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_datacountsec().spec_serialize(v@))
        },
{
    let combinator = datacountsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn datacountsec_len<'a>(v: <DatacountsecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_datacountsec().wf(v@),
        spec_datacountsec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_datacountsec().spec_serialize(v@).len(),
{
    let combinator = datacountsec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct DatacountsecCont0;
type DatacountsecCont0Type<'a, 'b> = &'b u64;
type DatacountsecCont0SType<'a, 'x> = &'x u64;
type DatacountsecCont0Input<'a, 'b, 'x> = POrSType<DatacountsecCont0Type<'a, 'b>, DatacountsecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<DatacountsecCont0Input<'a, 'b, 'x>> for DatacountsecCont0 {
    type Output = AndThen<bytes::Variable, UnsignedLEB128>;

    open spec fn requires(&self, deps: DatacountsecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: DatacountsecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_datacountsec_cont0(deps@)
    }

    fn apply(&self, deps: DatacountsecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), UnsignedLEB128)
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), UnsignedLEB128)
            }
        }
    }
}
                

pub enum SpecData {
    ActiveData0(SpecActiveData0),
    PassiveData(SpecPassiveData),
    ActiveDataX(SpecActiveDatax),
}

pub type SpecDataInner = Either<SpecActiveData0, Either<SpecPassiveData, SpecActiveDatax>>;

impl SpecFrom<SpecData> for SpecDataInner {
    open spec fn spec_from(m: SpecData) -> SpecDataInner {
        match m {
            SpecData::ActiveData0(m) => Either::Left(m),
            SpecData::PassiveData(m) => Either::Right(Either::Left(m)),
            SpecData::ActiveDataX(m) => Either::Right(Either::Right(m)),
        }
    }

}

                
impl SpecFrom<SpecDataInner> for SpecData {
    open spec fn spec_from(m: SpecDataInner) -> SpecData {
        match m {
            Either::Left(m) => SpecData::ActiveData0(m),
            Either::Right(Either::Left(m)) => SpecData::PassiveData(m),
            Either::Right(Either::Right(m)) => SpecData::ActiveDataX(m),
        }
    }

}



#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Data<'a> {
    ActiveData0(ActiveData0<'a>),
    PassiveData(PassiveData),
    ActiveDataX(ActiveDatax<'a>),
}

pub type DataInner<'a> = Either<ActiveData0<'a>, Either<PassiveData, ActiveDatax<'a>>>;

pub type DataInnerRef<'a> = Either<&'a ActiveData0<'a>, Either<&'a PassiveData, &'a ActiveDatax<'a>>>;


impl<'a> View for Data<'a> {
    type V = SpecData;
    open spec fn view(&self) -> Self::V {
        match self {
            Data::ActiveData0(m) => SpecData::ActiveData0(m@),
            Data::PassiveData(m) => SpecData::PassiveData(m@),
            Data::ActiveDataX(m) => SpecData::ActiveDataX(m@),
        }
    }
}


impl<'a> From<&'a Data<'a>> for DataInnerRef<'a> {
    fn ex_from(m: &'a Data<'a>) -> DataInnerRef<'a> {
        match m {
            Data::ActiveData0(m) => Either::Left(m),
            Data::PassiveData(m) => Either::Right(Either::Left(m)),
            Data::ActiveDataX(m) => Either::Right(Either::Right(m)),
        }
    }

}

impl<'a> From<DataInner<'a>> for Data<'a> {
    fn ex_from(m: DataInner<'a>) -> Data<'a> {
        match m {
            Either::Left(m) => Data::ActiveData0(m),
            Either::Right(Either::Left(m)) => Data::PassiveData(m),
            Either::Right(Either::Right(m)) => Data::ActiveDataX(m),
        }
    }
    
}


pub struct DataMapper;
impl View for DataMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for DataMapper {
    type Src = SpecDataInner;
    type Dst = SpecData;
}
impl SpecIsoProof for DataMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for DataMapper {
    type Src = DataInner<'a>;
    type Dst = Data<'a>;
    type RefSrc = DataInnerRef<'a>;
}

pub const DATAACTIVEDATA0_0_FRONT_CONST: u64 = 0;

pub const DATAPASSIVEDATA_0_FRONT_CONST: u64 = 1;

pub const DATAACTIVEDATAX_0_FRONT_CONST: u64 = 2;

type SpecDataCombinatorAlias1 = Choice<Preceded<Tag<UnsignedLEB128, u64>, SpecPassiveDataCombinator>, Preceded<Tag<UnsignedLEB128, u64>, SpecActiveDataxCombinator>>;
type SpecDataCombinatorAlias2 = Choice<Preceded<Tag<UnsignedLEB128, u64>, SpecActiveData0Combinator>, SpecDataCombinatorAlias1>;
pub struct SpecDataCombinator(pub SpecDataCombinatorAlias);

impl SpecCombinator for SpecDataCombinator {
    type Type = SpecData;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecDataCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecDataCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecDataCombinatorAlias = Mapped<SpecDataCombinatorAlias2, DataMapper>;



type DataCombinatorAlias1 = Choice<Preceded<Tag<UnsignedLEB128, u64>, PassiveDataCombinator>, Preceded<Tag<UnsignedLEB128, u64>, ActiveDataxCombinator>>;
type DataCombinatorAlias2 = Choice<Preceded<Tag<UnsignedLEB128, u64>, ActiveData0Combinator>, DataCombinator1>;
pub struct DataCombinator1(pub DataCombinatorAlias1);
impl View for DataCombinator1 {
    type V = SpecDataCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(DataCombinator1, DataCombinatorAlias1);

pub struct DataCombinator2(pub DataCombinatorAlias2);
impl View for DataCombinator2 {
    type V = SpecDataCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(DataCombinator2, DataCombinatorAlias2);

pub struct DataCombinator(pub DataCombinatorAlias);

impl View for DataCombinator {
    type V = SpecDataCombinator;
    open spec fn view(&self) -> Self::V { SpecDataCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for DataCombinator {
    type Type = Data<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type DataCombinatorAlias = Mapped<DataCombinator2, DataMapper>;


pub open spec fn spec_data() -> SpecDataCombinator {
    SpecDataCombinator(Mapped { inner: Choice(Preceded(Tag::spec_new(UnsignedLEB128, DATAACTIVEDATA0_0_FRONT_CONST), spec_active_data0()), Choice(Preceded(Tag::spec_new(UnsignedLEB128, DATAPASSIVEDATA_0_FRONT_CONST), spec_passive_data()), Preceded(Tag::spec_new(UnsignedLEB128, DATAACTIVEDATAX_0_FRONT_CONST), spec_active_datax()))), mapper: DataMapper })
}

                
pub fn data<'a>() -> (o: DataCombinator)
    ensures o@ == spec_data(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = DataCombinator(Mapped { inner: DataCombinator2(Choice::new(Preceded(Tag::new(UnsignedLEB128, DATAACTIVEDATA0_0_FRONT_CONST), active_data0()), DataCombinator1(Choice::new(Preceded(Tag::new(UnsignedLEB128, DATAPASSIVEDATA_0_FRONT_CONST), passive_data()), Preceded(Tag::new(UnsignedLEB128, DATAACTIVEDATAX_0_FRONT_CONST), active_datax()))))), mapper: DataMapper });
    assert({
        &&& combinator@ == spec_data()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_data<'a>(input: &'a [u8]) -> (res: PResult<<DataCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_data().spec_parse(input@) == Some((n as int, v@)),
        spec_data().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_data().spec_parse(input@) is None,
        spec_data().spec_parse(input@) is None ==> res is Err,
{
    let combinator = data();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_data<'a>(v: <DataCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_data().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_data().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_data().spec_serialize(v@))
        },
{
    let combinator = data();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn data_len<'a>(v: <DataCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_data().wf(v@),
        spec_data().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_data().spec_serialize(v@).len(),
{
    let combinator = data();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

pub struct SpecDatasecContent {
    pub l: u64,
    pub v: Seq<SpecData>,
}

pub type SpecDatasecContentInner = (u64, Seq<SpecData>);


impl SpecFrom<SpecDatasecContent> for SpecDatasecContentInner {
    open spec fn spec_from(m: SpecDatasecContent) -> SpecDatasecContentInner {
        (m.l, m.v)
    }
}

impl SpecFrom<SpecDatasecContentInner> for SpecDatasecContent {
    open spec fn spec_from(m: SpecDatasecContentInner) -> SpecDatasecContent {
        let (l, v) = m;
        SpecDatasecContent { l, v }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct DatasecContent<'a> {
    pub l: u64,
    pub v: RepeatResult<Data<'a>>,
}

impl View for DatasecContent<'_> {
    type V = SpecDatasecContent;

    open spec fn view(&self) -> Self::V {
        SpecDatasecContent {
            l: self.l@,
            v: self.v@,
        }
    }
}
pub type DatasecContentInner<'a> = (u64, RepeatResult<Data<'a>>);

pub type DatasecContentInnerRef<'a> = (&'a u64, &'a RepeatResult<Data<'a>>);
impl<'a> From<&'a DatasecContent<'a>> for DatasecContentInnerRef<'a> {
    fn ex_from(m: &'a DatasecContent) -> DatasecContentInnerRef<'a> {
        (&m.l, &m.v)
    }
}

impl<'a> From<DatasecContentInner<'a>> for DatasecContent<'a> {
    fn ex_from(m: DatasecContentInner) -> DatasecContent {
        let (l, v) = m;
        DatasecContent { l, v }
    }
}

pub struct DatasecContentMapper;
impl View for DatasecContentMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for DatasecContentMapper {
    type Src = SpecDatasecContentInner;
    type Dst = SpecDatasecContent;
}
impl SpecIsoProof for DatasecContentMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for DatasecContentMapper {
    type Src = DatasecContentInner<'a>;
    type Dst = DatasecContent<'a>;
    type RefSrc = DatasecContentInnerRef<'a>;
}

pub struct SpecDatasecContentCombinator(pub SpecDatasecContentCombinatorAlias);

impl SpecCombinator for SpecDatasecContentCombinator {
    type Type = SpecDatasecContent;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecDatasecContentCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecDatasecContentCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecDatasecContentCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, RepeatN<SpecDataCombinator>>, DatasecContentMapper>;

pub struct DatasecContentCombinator(pub DatasecContentCombinatorAlias);

impl View for DatasecContentCombinator {
    type V = SpecDatasecContentCombinator;
    open spec fn view(&self) -> Self::V { SpecDatasecContentCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for DatasecContentCombinator {
    type Type = DatasecContent<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type DatasecContentCombinatorAlias = Mapped<Pair<UnsignedLEB128, RepeatN<DataCombinator>, DatasecContentCont0>, DatasecContentMapper>;


pub open spec fn spec_datasec_content() -> SpecDatasecContentCombinator {
    SpecDatasecContentCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_datasec_content_cont0(deps)),
        mapper: DatasecContentMapper,
    })
}

pub open spec fn spec_datasec_content_cont0(deps: u64) -> RepeatN<SpecDataCombinator> {
    let l = deps;
    RepeatN(spec_data(), l.spec_into())
}

impl View for DatasecContentCont0 {
    type V = spec_fn(u64) -> RepeatN<SpecDataCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_datasec_content_cont0(deps)
        }
    }
}

                
pub fn datasec_content<'a>() -> (o: DatasecContentCombinator)
    ensures o@ == spec_datasec_content(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = DatasecContentCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, DatasecContentCont0),
        mapper: DatasecContentMapper,
    });
    assert({
        &&& combinator@ == spec_datasec_content()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_datasec_content<'a>(input: &'a [u8]) -> (res: PResult<<DatasecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_datasec_content().spec_parse(input@) == Some((n as int, v@)),
        spec_datasec_content().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_datasec_content().spec_parse(input@) is None,
        spec_datasec_content().spec_parse(input@) is None ==> res is Err,
{
    let combinator = datasec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_datasec_content<'a>(v: <DatasecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_datasec_content().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_datasec_content().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_datasec_content().spec_serialize(v@))
        },
{
    let combinator = datasec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn datasec_content_len<'a>(v: <DatasecContentCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_datasec_content().wf(v@),
        spec_datasec_content().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_datasec_content().spec_serialize(v@).len(),
{
    let combinator = datasec_content();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct DatasecContentCont0;
type DatasecContentCont0Type<'a, 'b> = &'b u64;
type DatasecContentCont0SType<'a, 'x> = &'x u64;
type DatasecContentCont0Input<'a, 'b, 'x> = POrSType<DatasecContentCont0Type<'a, 'b>, DatasecContentCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<DatasecContentCont0Input<'a, 'b, 'x>> for DatasecContentCont0 {
    type Output = RepeatN<DataCombinator>;

    open spec fn requires(&self, deps: DatasecContentCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: DatasecContentCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_datasec_content_cont0(deps@)
    }

    fn apply(&self, deps: DatasecContentCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let l = *deps;
                RepeatN(data(), l.ex_into())
            }
            POrSType::S(deps) => {
                let l = deps;
                let l = *l;
                RepeatN(data(), l.ex_into())
            }
        }
    }
}
                

pub struct SpecDatasec {
    pub size: u64,
    pub cont: SpecDatasecContent,
}

pub type SpecDatasecInner = (u64, SpecDatasecContent);


impl SpecFrom<SpecDatasec> for SpecDatasecInner {
    open spec fn spec_from(m: SpecDatasec) -> SpecDatasecInner {
        (m.size, m.cont)
    }
}

impl SpecFrom<SpecDatasecInner> for SpecDatasec {
    open spec fn spec_from(m: SpecDatasecInner) -> SpecDatasec {
        let (size, cont) = m;
        SpecDatasec { size, cont }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Datasec<'a> {
    pub size: u64,
    pub cont: DatasecContent<'a>,
}

impl View for Datasec<'_> {
    type V = SpecDatasec;

    open spec fn view(&self) -> Self::V {
        SpecDatasec {
            size: self.size@,
            cont: self.cont@,
        }
    }
}
pub type DatasecInner<'a> = (u64, DatasecContent<'a>);

pub type DatasecInnerRef<'a> = (&'a u64, &'a DatasecContent<'a>);
impl<'a> From<&'a Datasec<'a>> for DatasecInnerRef<'a> {
    fn ex_from(m: &'a Datasec) -> DatasecInnerRef<'a> {
        (&m.size, &m.cont)
    }
}

impl<'a> From<DatasecInner<'a>> for Datasec<'a> {
    fn ex_from(m: DatasecInner) -> Datasec {
        let (size, cont) = m;
        Datasec { size, cont }
    }
}

pub struct DatasecMapper;
impl View for DatasecMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for DatasecMapper {
    type Src = SpecDatasecInner;
    type Dst = SpecDatasec;
}
impl SpecIsoProof for DatasecMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for DatasecMapper {
    type Src = DatasecInner<'a>;
    type Dst = Datasec<'a>;
    type RefSrc = DatasecInnerRef<'a>;
}

pub struct SpecDatasecCombinator(pub SpecDatasecCombinatorAlias);

impl SpecCombinator for SpecDatasecCombinator {
    type Type = SpecDatasec;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecDatasecCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecDatasecCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecDatasecCombinatorAlias = Mapped<SpecPair<UnsignedLEB128, AndThen<bytes::Variable, SpecDatasecContentCombinator>>, DatasecMapper>;

pub struct DatasecCombinator(pub DatasecCombinatorAlias);

impl View for DatasecCombinator {
    type V = SpecDatasecCombinator;
    open spec fn view(&self) -> Self::V { SpecDatasecCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for DatasecCombinator {
    type Type = Datasec<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type DatasecCombinatorAlias = Mapped<Pair<UnsignedLEB128, AndThen<bytes::Variable, DatasecContentCombinator>, DatasecCont0>, DatasecMapper>;


pub open spec fn spec_datasec() -> SpecDatasecCombinator {
    SpecDatasecCombinator(
    Mapped {
        inner: Pair::spec_new(UnsignedLEB128, |deps| spec_datasec_cont0(deps)),
        mapper: DatasecMapper,
    })
}

pub open spec fn spec_datasec_cont0(deps: u64) -> AndThen<bytes::Variable, SpecDatasecContentCombinator> {
    let size = deps;
    AndThen(bytes::Variable(size.spec_into()), spec_datasec_content())
}

impl View for DatasecCont0 {
    type V = spec_fn(u64) -> AndThen<bytes::Variable, SpecDatasecContentCombinator>;

    open spec fn view(&self) -> Self::V {
        |deps: u64| {
            spec_datasec_cont0(deps)
        }
    }
}

                
pub fn datasec<'a>() -> (o: DatasecCombinator)
    ensures o@ == spec_datasec(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = DatasecCombinator(
    Mapped {
        inner: Pair::new(UnsignedLEB128, DatasecCont0),
        mapper: DatasecMapper,
    });
    assert({
        &&& combinator@ == spec_datasec()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_datasec<'a>(input: &'a [u8]) -> (res: PResult<<DatasecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_datasec().spec_parse(input@) == Some((n as int, v@)),
        spec_datasec().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_datasec().spec_parse(input@) is None,
        spec_datasec().spec_parse(input@) is None ==> res is Err,
{
    let combinator = datasec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_datasec<'a>(v: <DatasecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_datasec().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_datasec().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_datasec().spec_serialize(v@))
        },
{
    let combinator = datasec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn datasec_len<'a>(v: <DatasecCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_datasec().wf(v@),
        spec_datasec().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_datasec().spec_serialize(v@).len(),
{
    let combinator = datasec();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

pub struct DatasecCont0;
type DatasecCont0Type<'a, 'b> = &'b u64;
type DatasecCont0SType<'a, 'x> = &'x u64;
type DatasecCont0Input<'a, 'b, 'x> = POrSType<DatasecCont0Type<'a, 'b>, DatasecCont0SType<'a, 'x>>;
impl<'a, 'b, 'x> Continuation<DatasecCont0Input<'a, 'b, 'x>> for DatasecCont0 {
    type Output = AndThen<bytes::Variable, DatasecContentCombinator>;

    open spec fn requires(&self, deps: DatasecCont0Input<'a, 'b, 'x>) -> bool { true }

    open spec fn ensures(&self, deps: DatasecCont0Input<'a, 'b, 'x>, o: Self::Output) -> bool {
        o@ == spec_datasec_cont0(deps@)
    }

    fn apply(&self, deps: DatasecCont0Input<'a, 'b, 'x>) -> Self::Output {
        match deps {
            POrSType::P(deps) => {
                let size = *deps;
                AndThen(bytes::Variable(size.ex_into()), datasec_content())
            }
            POrSType::S(deps) => {
                let size = deps;
                let size = *size;
                AndThen(bytes::Variable(size.ex_into()), datasec_content())
            }
        }
    }
}
                

pub struct SpecModule {
    pub magic: Seq<u8>,
    pub version: Seq<u8>,
    pub types: Option<SpecTypesec>,
    pub imports: Option<SpecImportsec>,
    pub typeidxs: Option<SpecFuncsec>,
    pub tables: Option<SpecTablesec>,
    pub mems: Option<SpecMemsec>,
    pub globals: Option<SpecGlobalsec>,
    pub exports: Option<SpecExportsec>,
    pub start: Option<SpecStartsec>,
    pub elems: Option<SpecElemsec>,
    pub datacount: Option<SpecDatacountsec>,
    pub codes: Option<SpecCodesec>,
    pub datas: Option<SpecDatasec>,
}

pub type SpecModuleInner = (Seq<u8>, (Seq<u8>, (Option<SpecTypesec>, (Option<SpecImportsec>, (Option<SpecFuncsec>, (Option<SpecTablesec>, (Option<SpecMemsec>, (Option<SpecGlobalsec>, (Option<SpecExportsec>, (Option<SpecStartsec>, (Option<SpecElemsec>, (Option<SpecDatacountsec>, (Option<SpecCodesec>, Option<SpecDatasec>)))))))))))));


impl SpecFrom<SpecModule> for SpecModuleInner {
    open spec fn spec_from(m: SpecModule) -> SpecModuleInner {
        (m.magic, (m.version, (m.types, (m.imports, (m.typeidxs, (m.tables, (m.mems, (m.globals, (m.exports, (m.start, (m.elems, (m.datacount, (m.codes, m.datas)))))))))))))
    }
}

impl SpecFrom<SpecModuleInner> for SpecModule {
    open spec fn spec_from(m: SpecModuleInner) -> SpecModule {
        let (magic, (version, (types, (imports, (typeidxs, (tables, (mems, (globals, (exports, (start, (elems, (datacount, (codes, datas))))))))))))) = m;
        SpecModule { magic, version, types, imports, typeidxs, tables, mems, globals, exports, start, elems, datacount, codes, datas }
    }
}
#[derive(Debug, Clone, PartialEq, Eq)]

pub struct Module<'a> {
    pub magic: &'a [u8],
    pub version: &'a [u8],
    pub types: Optional<Typesec>,
    pub imports: Optional<Importsec>,
    pub typeidxs: Optional<Funcsec>,
    pub tables: Optional<Tablesec>,
    pub mems: Optional<Memsec>,
    pub globals: Optional<Globalsec<'a>>,
    pub exports: Optional<Exportsec>,
    pub start: Optional<Startsec>,
    pub elems: Optional<Elemsec<'a>>,
    pub datacount: Optional<Datacountsec>,
    pub codes: Optional<Codesec<'a>>,
    pub datas: Optional<Datasec<'a>>,
}

impl View for Module<'_> {
    type V = SpecModule;

    open spec fn view(&self) -> Self::V {
        SpecModule {
            magic: self.magic@,
            version: self.version@,
            types: self.types@,
            imports: self.imports@,
            typeidxs: self.typeidxs@,
            tables: self.tables@,
            mems: self.mems@,
            globals: self.globals@,
            exports: self.exports@,
            start: self.start@,
            elems: self.elems@,
            datacount: self.datacount@,
            codes: self.codes@,
            datas: self.datas@,
        }
    }
}
pub type ModuleInner<'a> = (&'a [u8], (&'a [u8], (Optional<Typesec>, (Optional<Importsec>, (Optional<Funcsec>, (Optional<Tablesec>, (Optional<Memsec>, (Optional<Globalsec<'a>>, (Optional<Exportsec>, (Optional<Startsec>, (Optional<Elemsec<'a>>, (Optional<Datacountsec>, (Optional<Codesec<'a>>, Optional<Datasec<'a>>)))))))))))));

pub type ModuleInnerRef<'a> = (&'a &'a [u8], (&'a &'a [u8], (&'a Optional<Typesec>, (&'a Optional<Importsec>, (&'a Optional<Funcsec>, (&'a Optional<Tablesec>, (&'a Optional<Memsec>, (&'a Optional<Globalsec<'a>>, (&'a Optional<Exportsec>, (&'a Optional<Startsec>, (&'a Optional<Elemsec<'a>>, (&'a Optional<Datacountsec>, (&'a Optional<Codesec<'a>>, &'a Optional<Datasec<'a>>)))))))))))));
impl<'a> From<&'a Module<'a>> for ModuleInnerRef<'a> {
    fn ex_from(m: &'a Module) -> ModuleInnerRef<'a> {
        (&m.magic, (&m.version, (&m.types, (&m.imports, (&m.typeidxs, (&m.tables, (&m.mems, (&m.globals, (&m.exports, (&m.start, (&m.elems, (&m.datacount, (&m.codes, &m.datas)))))))))))))
    }
}

impl<'a> From<ModuleInner<'a>> for Module<'a> {
    fn ex_from(m: ModuleInner) -> Module {
        let (magic, (version, (types, (imports, (typeidxs, (tables, (mems, (globals, (exports, (start, (elems, (datacount, (codes, datas))))))))))))) = m;
        Module { magic, version, types, imports, typeidxs, tables, mems, globals, exports, start, elems, datacount, codes, datas }
    }
}

pub struct ModuleMapper;
impl View for ModuleMapper {
    type V = Self;
    open spec fn view(&self) -> Self::V {
        *self
    }
}
impl SpecIso for ModuleMapper {
    type Src = SpecModuleInner;
    type Dst = SpecModule;
}
impl SpecIsoProof for ModuleMapper {
    proof fn spec_iso(s: Self::Src) {
        assert(Self::Src::spec_from(Self::Dst::spec_from(s)) == s);
    }
    proof fn spec_iso_rev(s: Self::Dst) {
        assert(Self::Dst::spec_from(Self::Src::spec_from(s)) == s);
    }
}
impl<'a> Iso<'a> for ModuleMapper {
    type Src = ModuleInner<'a>;
    type Dst = Module<'a>;
    type RefSrc = ModuleInnerRef<'a>;
}
pub spec const SPEC_MODULEMAGIC_CONST: Seq<u8> = seq![0, 97, 115, 109];pub spec const SPEC_MODULEVERSION_CONST: Seq<u8> = seq![1, 0, 0, 0];pub const MODULETYPES_0_FRONT_CONST: u8 = 1;

pub const MODULEIMPORTS_0_FRONT_CONST: u8 = 2;

pub const MODULETYPEIDXS_0_FRONT_CONST: u8 = 3;

pub const MODULETABLES_0_FRONT_CONST: u8 = 4;

pub const MODULEMEMS_0_FRONT_CONST: u8 = 5;

pub const MODULEGLOBALS_0_FRONT_CONST: u8 = 6;

pub const MODULEEXPORTS_0_FRONT_CONST: u8 = 7;

pub const MODULESTART_0_FRONT_CONST: u8 = 8;

pub const MODULEELEMS_0_FRONT_CONST: u8 = 9;

pub const MODULEDATACOUNT_0_FRONT_CONST: u8 = 12;

pub const MODULECODES_0_FRONT_CONST: u8 = 10;

pub const MODULEDATAS_0_FRONT_CONST: u8 = 11;

type SpecModuleCombinatorAlias1 = (Opt<Preceded<Tag<U8, u8>, SpecCodesecCombinator>>, Opt<Preceded<Tag<U8, u8>, SpecDatasecCombinator>>);
type SpecModuleCombinatorAlias2 = (Opt<Preceded<Tag<U8, u8>, SpecDatacountsecCombinator>>, SpecModuleCombinatorAlias1);
type SpecModuleCombinatorAlias3 = (Opt<Preceded<Tag<U8, u8>, SpecElemsecCombinator>>, SpecModuleCombinatorAlias2);
type SpecModuleCombinatorAlias4 = (Opt<Preceded<Tag<U8, u8>, SpecStartsecCombinator>>, SpecModuleCombinatorAlias3);
type SpecModuleCombinatorAlias5 = (Opt<Preceded<Tag<U8, u8>, SpecExportsecCombinator>>, SpecModuleCombinatorAlias4);
type SpecModuleCombinatorAlias6 = (Opt<Preceded<Tag<U8, u8>, SpecGlobalsecCombinator>>, SpecModuleCombinatorAlias5);
type SpecModuleCombinatorAlias7 = (Opt<Preceded<Tag<U8, u8>, SpecMemsecCombinator>>, SpecModuleCombinatorAlias6);
type SpecModuleCombinatorAlias8 = (Opt<Preceded<Tag<U8, u8>, SpecTablesecCombinator>>, SpecModuleCombinatorAlias7);
type SpecModuleCombinatorAlias9 = (Opt<Preceded<Tag<U8, u8>, SpecFuncsecCombinator>>, SpecModuleCombinatorAlias8);
type SpecModuleCombinatorAlias10 = (Opt<Preceded<Tag<U8, u8>, SpecImportsecCombinator>>, SpecModuleCombinatorAlias9);
type SpecModuleCombinatorAlias11 = (Opt<Preceded<Tag<U8, u8>, SpecTypesecCombinator>>, SpecModuleCombinatorAlias10);
type SpecModuleCombinatorAlias12 = (Refined<bytes::Fixed<4>, TagPred<Seq<u8>>>, SpecModuleCombinatorAlias11);
type SpecModuleCombinatorAlias13 = (Refined<bytes::Fixed<4>, TagPred<Seq<u8>>>, SpecModuleCombinatorAlias12);
pub struct SpecModuleCombinator(pub SpecModuleCombinatorAlias);

impl SpecCombinator for SpecModuleCombinator {
    type Type = SpecModule;
    closed spec fn requires(&self) -> bool
    { self.0.requires() }
    open spec fn wf(&self, v: Self::Type) -> bool
    { self.0.wf(v) }
    closed spec fn spec_parse(&self, s: Seq<u8>) -> Option<(int, Self::Type)> 
    { self.0.spec_parse(s) }
    closed spec fn spec_serialize(&self, v: Self::Type) -> Seq<u8> 
    { self.0.spec_serialize(v) }
}
impl SecureSpecCombinator for SpecModuleCombinator {
    open spec fn is_prefix_secure() -> bool 
    { SpecModuleCombinatorAlias::is_prefix_secure() }
    proof fn theorem_serialize_parse_roundtrip(&self, v: Self::Type)
    { self.0.theorem_serialize_parse_roundtrip(v) }
    proof fn theorem_parse_serialize_roundtrip(&self, buf: Seq<u8>)
    { self.0.theorem_parse_serialize_roundtrip(buf) }
    proof fn lemma_prefix_secure(&self, s1: Seq<u8>, s2: Seq<u8>)
    { self.0.lemma_prefix_secure(s1, s2) }
    proof fn lemma_parse_length(&self, s: Seq<u8>) 
    { self.0.lemma_parse_length(s) }
    closed spec fn is_productive(&self) -> bool 
    { self.0.is_productive() }
    proof fn lemma_parse_productive(&self, s: Seq<u8>) 
    { self.0.lemma_parse_productive(s) }
}
pub type SpecModuleCombinatorAlias = Mapped<SpecModuleCombinatorAlias13, ModuleMapper>;
pub exec static MODULEMAGIC_CONST: [u8; 4]
    ensures MODULEMAGIC_CONST@ == SPEC_MODULEMAGIC_CONST,
{
    let arr: [u8; 4] = [0, 97, 115, 109];
    assert(arr@ == SPEC_MODULEMAGIC_CONST);
    arr
}
pub exec static MODULEVERSION_CONST: [u8; 4]
    ensures MODULEVERSION_CONST@ == SPEC_MODULEVERSION_CONST,
{
    let arr: [u8; 4] = [1, 0, 0, 0];
    assert(arr@ == SPEC_MODULEVERSION_CONST);
    arr
}












type ModuleCombinatorAlias1 = (Opt<Preceded<Tag<U8, u8>, CodesecCombinator>>, Opt<Preceded<Tag<U8, u8>, DatasecCombinator>>);
type ModuleCombinatorAlias2 = (Opt<Preceded<Tag<U8, u8>, DatacountsecCombinator>>, ModuleCombinator1);
type ModuleCombinatorAlias3 = (Opt<Preceded<Tag<U8, u8>, ElemsecCombinator>>, ModuleCombinator2);
type ModuleCombinatorAlias4 = (Opt<Preceded<Tag<U8, u8>, StartsecCombinator>>, ModuleCombinator3);
type ModuleCombinatorAlias5 = (Opt<Preceded<Tag<U8, u8>, ExportsecCombinator>>, ModuleCombinator4);
type ModuleCombinatorAlias6 = (Opt<Preceded<Tag<U8, u8>, GlobalsecCombinator>>, ModuleCombinator5);
type ModuleCombinatorAlias7 = (Opt<Preceded<Tag<U8, u8>, MemsecCombinator>>, ModuleCombinator6);
type ModuleCombinatorAlias8 = (Opt<Preceded<Tag<U8, u8>, TablesecCombinator>>, ModuleCombinator7);
type ModuleCombinatorAlias9 = (Opt<Preceded<Tag<U8, u8>, FuncsecCombinator>>, ModuleCombinator8);
type ModuleCombinatorAlias10 = (Opt<Preceded<Tag<U8, u8>, ImportsecCombinator>>, ModuleCombinator9);
type ModuleCombinatorAlias11 = (Opt<Preceded<Tag<U8, u8>, TypesecCombinator>>, ModuleCombinator10);
type ModuleCombinatorAlias12 = (Refined<bytes::Fixed<4>, TagPred<[u8; 4]>>, ModuleCombinator11);
type ModuleCombinatorAlias13 = (Refined<bytes::Fixed<4>, TagPred<[u8; 4]>>, ModuleCombinator12);
pub struct ModuleCombinator1(pub ModuleCombinatorAlias1);
impl View for ModuleCombinator1 {
    type V = SpecModuleCombinatorAlias1;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ModuleCombinator1, ModuleCombinatorAlias1);

pub struct ModuleCombinator2(pub ModuleCombinatorAlias2);
impl View for ModuleCombinator2 {
    type V = SpecModuleCombinatorAlias2;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ModuleCombinator2, ModuleCombinatorAlias2);

pub struct ModuleCombinator3(pub ModuleCombinatorAlias3);
impl View for ModuleCombinator3 {
    type V = SpecModuleCombinatorAlias3;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ModuleCombinator3, ModuleCombinatorAlias3);

pub struct ModuleCombinator4(pub ModuleCombinatorAlias4);
impl View for ModuleCombinator4 {
    type V = SpecModuleCombinatorAlias4;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ModuleCombinator4, ModuleCombinatorAlias4);

pub struct ModuleCombinator5(pub ModuleCombinatorAlias5);
impl View for ModuleCombinator5 {
    type V = SpecModuleCombinatorAlias5;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ModuleCombinator5, ModuleCombinatorAlias5);

pub struct ModuleCombinator6(pub ModuleCombinatorAlias6);
impl View for ModuleCombinator6 {
    type V = SpecModuleCombinatorAlias6;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ModuleCombinator6, ModuleCombinatorAlias6);

pub struct ModuleCombinator7(pub ModuleCombinatorAlias7);
impl View for ModuleCombinator7 {
    type V = SpecModuleCombinatorAlias7;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ModuleCombinator7, ModuleCombinatorAlias7);

pub struct ModuleCombinator8(pub ModuleCombinatorAlias8);
impl View for ModuleCombinator8 {
    type V = SpecModuleCombinatorAlias8;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ModuleCombinator8, ModuleCombinatorAlias8);

pub struct ModuleCombinator9(pub ModuleCombinatorAlias9);
impl View for ModuleCombinator9 {
    type V = SpecModuleCombinatorAlias9;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ModuleCombinator9, ModuleCombinatorAlias9);

pub struct ModuleCombinator10(pub ModuleCombinatorAlias10);
impl View for ModuleCombinator10 {
    type V = SpecModuleCombinatorAlias10;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ModuleCombinator10, ModuleCombinatorAlias10);

pub struct ModuleCombinator11(pub ModuleCombinatorAlias11);
impl View for ModuleCombinator11 {
    type V = SpecModuleCombinatorAlias11;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ModuleCombinator11, ModuleCombinatorAlias11);

pub struct ModuleCombinator12(pub ModuleCombinatorAlias12);
impl View for ModuleCombinator12 {
    type V = SpecModuleCombinatorAlias12;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ModuleCombinator12, ModuleCombinatorAlias12);

pub struct ModuleCombinator13(pub ModuleCombinatorAlias13);
impl View for ModuleCombinator13 {
    type V = SpecModuleCombinatorAlias13;
    open spec fn view(&self) -> Self::V { self.0@ }
}
impl_wrapper_combinator!(ModuleCombinator13, ModuleCombinatorAlias13);

pub struct ModuleCombinator(pub ModuleCombinatorAlias);

impl View for ModuleCombinator {
    type V = SpecModuleCombinator;
    open spec fn view(&self) -> Self::V { SpecModuleCombinator(self.0@) }
}
impl<'a> Combinator<'a, &'a [u8], Vec<u8>> for ModuleCombinator {
    type Type = Module<'a>;
    type SType = &'a Self::Type;
    fn length(&self, v: Self::SType) -> usize
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&self.0, v) }
    closed spec fn ex_requires(&self) -> bool 
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&self.0) }
    fn parse(&self, s: &'a [u8]) -> (res: Result<(usize, Self::Type), ParseError>) 
    { <_ as Combinator<'a, &'a [u8],Vec<u8>>>::parse(&self.0, s) }
    fn serialize(&self, v: Self::SType, data: &mut Vec<u8>, pos: usize) -> (o: Result<usize, SerializeError>)
    { <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&self.0, v, data, pos) }
} 
pub type ModuleCombinatorAlias = Mapped<ModuleCombinator13, ModuleMapper>;


pub open spec fn spec_module() -> SpecModuleCombinator {
    SpecModuleCombinator(
    Mapped {
        inner: (Refined { inner: bytes::Fixed::<4>, predicate: TagPred(SPEC_MODULEMAGIC_CONST) }, (Refined { inner: bytes::Fixed::<4>, predicate: TagPred(SPEC_MODULEVERSION_CONST) }, (Opt(Preceded(Tag::spec_new(U8, MODULETYPES_0_FRONT_CONST), spec_typesec())), (Opt(Preceded(Tag::spec_new(U8, MODULEIMPORTS_0_FRONT_CONST), spec_importsec())), (Opt(Preceded(Tag::spec_new(U8, MODULETYPEIDXS_0_FRONT_CONST), spec_funcsec())), (Opt(Preceded(Tag::spec_new(U8, MODULETABLES_0_FRONT_CONST), spec_tablesec())), (Opt(Preceded(Tag::spec_new(U8, MODULEMEMS_0_FRONT_CONST), spec_memsec())), (Opt(Preceded(Tag::spec_new(U8, MODULEGLOBALS_0_FRONT_CONST), spec_globalsec())), (Opt(Preceded(Tag::spec_new(U8, MODULEEXPORTS_0_FRONT_CONST), spec_exportsec())), (Opt(Preceded(Tag::spec_new(U8, MODULESTART_0_FRONT_CONST), spec_startsec())), (Opt(Preceded(Tag::spec_new(U8, MODULEELEMS_0_FRONT_CONST), spec_elemsec())), (Opt(Preceded(Tag::spec_new(U8, MODULEDATACOUNT_0_FRONT_CONST), spec_datacountsec())), (Opt(Preceded(Tag::spec_new(U8, MODULECODES_0_FRONT_CONST), spec_codesec())), Opt(Preceded(Tag::spec_new(U8, MODULEDATAS_0_FRONT_CONST), spec_datasec()))))))))))))))),
        mapper: ModuleMapper,
    })
}

                
pub fn module<'a>() -> (o: ModuleCombinator)
    ensures o@ == spec_module(),
            o@.requires(),
            <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&o),
{
    let combinator = ModuleCombinator(
    Mapped {
        inner: ModuleCombinator13((Refined { inner: bytes::Fixed::<4>, predicate: TagPred(MODULEMAGIC_CONST) }, ModuleCombinator12((Refined { inner: bytes::Fixed::<4>, predicate: TagPred(MODULEVERSION_CONST) }, ModuleCombinator11((Opt::new(Preceded(Tag::new(U8, MODULETYPES_0_FRONT_CONST), typesec())), ModuleCombinator10((Opt::new(Preceded(Tag::new(U8, MODULEIMPORTS_0_FRONT_CONST), importsec())), ModuleCombinator9((Opt::new(Preceded(Tag::new(U8, MODULETYPEIDXS_0_FRONT_CONST), funcsec())), ModuleCombinator8((Opt::new(Preceded(Tag::new(U8, MODULETABLES_0_FRONT_CONST), tablesec())), ModuleCombinator7((Opt::new(Preceded(Tag::new(U8, MODULEMEMS_0_FRONT_CONST), memsec())), ModuleCombinator6((Opt::new(Preceded(Tag::new(U8, MODULEGLOBALS_0_FRONT_CONST), globalsec())), ModuleCombinator5((Opt::new(Preceded(Tag::new(U8, MODULEEXPORTS_0_FRONT_CONST), exportsec())), ModuleCombinator4((Opt::new(Preceded(Tag::new(U8, MODULESTART_0_FRONT_CONST), startsec())), ModuleCombinator3((Opt::new(Preceded(Tag::new(U8, MODULEELEMS_0_FRONT_CONST), elemsec())), ModuleCombinator2((Opt::new(Preceded(Tag::new(U8, MODULEDATACOUNT_0_FRONT_CONST), datacountsec())), ModuleCombinator1((Opt::new(Preceded(Tag::new(U8, MODULECODES_0_FRONT_CONST), codesec())), Opt::new(Preceded(Tag::new(U8, MODULEDATAS_0_FRONT_CONST), datasec())))))))))))))))))))))))))))),
        mapper: ModuleMapper,
    });
    assert({
        &&& combinator@ == spec_module()
        &&& combinator@.requires()
        &&& <_ as Combinator<'a, &'a [u8], Vec<u8>>>::ex_requires(&combinator)
    });
    combinator
}

pub fn parse_module<'a>(input: &'a [u8]) -> (res: PResult<<ModuleCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::Type, ParseError>)
    requires
        input.len() <= usize::MAX,
    ensures
        res matches Ok((n, v)) ==> spec_module().spec_parse(input@) == Some((n as int, v@)),
        spec_module().spec_parse(input@) matches Some((n, v))
            ==> res matches Ok((m, u)) && m == n && v == u@,
        res is Err ==> spec_module().spec_parse(input@) is None,
        spec_module().spec_parse(input@) is None ==> res is Err,
{
    let combinator = module();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::parse(&combinator, input)
}

pub fn serialize_module<'a>(v: <ModuleCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType, data: &mut Vec<u8>, pos: usize) -> (o: SResult<usize, SerializeError>)
    requires
        pos <= old(data)@.len() <= usize::MAX,
        spec_module().wf(v@),
    ensures
        o matches Ok(n) ==> {
            &&& data@.len() == old(data)@.len()
            &&& pos <= usize::MAX - n && pos + n <= data@.len()
            &&& n == spec_module().spec_serialize(v@).len()
            &&& data@ == seq_splice(old(data)@, pos, spec_module().spec_serialize(v@))
        },
{
    let combinator = module();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::serialize(&combinator, v, data, pos)
}

pub fn module_len<'a>(v: <ModuleCombinator as Combinator<'a, &'a [u8], Vec<u8>>>::SType) -> (serialize_len: usize)
    requires
        spec_module().wf(v@),
        spec_module().spec_serialize(v@).len() <= usize::MAX,
    ensures
        serialize_len == spec_module().spec_serialize(v@).len(),
{
    let combinator = module();
    <_ as Combinator<'a, &'a [u8], Vec<u8>>>::length(&combinator, v)
}

                

}
